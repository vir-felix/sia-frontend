/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!************************************!*\
  !*** ./js/rendererjs/pluginapi.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _sia = __webpack_require__(/*! sia.js */ 585);
	
	var _sia2 = _interopRequireDefault(_sia);
	
	var _path = __webpack_require__(/*! path */ 521);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _electron = __webpack_require__(/*! electron */ 580);
	
	var _config = __webpack_require__(/*! ../mainjs/config.js */ 582);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// pluginapi.js: Sia-UI plugin API interface exposed to all plugins.
	// This is injected into every plugin's global namespace.
	
	var dialog = _electron.remote.dialog;
	var mainWindow = _electron.remote.getCurrentWindow();
	var config = (0, _config2.default)(_path2.default.join(__dirname, '../config.json'));
	_sia2.default.configure(config.siad);
	
	window.SiaAPI = {
		call: _sia2.default.call,
		config: config,
		hastingsToSiacoins: _sia2.default.hastingsToSiacoins,
		siacoinsToHastings: _sia2.default.siacoinsToHastings,
		openFile: function openFile(options) {
			return dialog.showOpenDialog(mainWindow, options);
		},
		saveFile: function saveFile(options) {
			return dialog.showSaveDialog(mainWindow, options);
		},
		showMessage: function showMessage(options) {
			return dialog.showMessageBox(mainWindow, options);
		},
		showError: function showError(options) {
			return dialog.showErrorBox(options.title, options.content);
		}
	};

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */
/*!*************************************!*\
  !*** ./~/bignumber.js/bignumber.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! bignumber.js v2.3.0 https://github.com/MikeMcl/bignumber.js/LICENCE */
	
	;(function (globalObj) {
	    'use strict';
	
	    /*
	      bignumber.js v2.3.0
	      A JavaScript library for arbitrary-precision arithmetic.
	      https://github.com/MikeMcl/bignumber.js
	      Copyright (c) 2016 Michael Mclaughlin <M8ch88l@gmail.com>
	      MIT Expat Licence
	    */
	
	
	    var cryptoObj, parseNumeric,
	        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
	        mathceil = Math.ceil,
	        mathfloor = Math.floor,
	        notBool = ' not a boolean or binary digit',
	        roundingMode = 'rounding mode',
	        tooManyDigits = 'number type has more than 15 significant digits',
	        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
	        BASE = 1e14,
	        LOG_BASE = 14,
	        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
	        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
	        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
	        SQRT_BASE = 1e7,
	
	        /*
	         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
	         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
	         * exception is thrown (if ERRORS is true).
	         */
	        MAX = 1E9;                                   // 0 to MAX_INT32
	
	    if ( typeof crypto != 'undefined' ) cryptoObj = crypto;
	
	
	    /*
	     * Create and return a BigNumber constructor.
	     */
	    function constructorFactory(configObj) {
	        var div,
	
	            // id tracks the caller function, so its name can be included in error messages.
	            id = 0,
	            P = BigNumber.prototype,
	            ONE = new BigNumber(1),
	
	
	            /********************************* EDITABLE DEFAULTS **********************************/
	
	
	            /*
	             * The default values below must be integers within the inclusive ranges stated.
	             * The values can also be changed at run-time using BigNumber.config.
	             */
	
	            // The maximum number of decimal places for operations involving division.
	            DECIMAL_PLACES = 20,                     // 0 to MAX
	
	            /*
	             * The rounding mode used when rounding to the above decimal places, and when using
	             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
	             * UP         0 Away from zero.
	             * DOWN       1 Towards zero.
	             * CEIL       2 Towards +Infinity.
	             * FLOOR      3 Towards -Infinity.
	             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
	             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
	             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
	             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
	             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
	             */
	            ROUNDING_MODE = 4,                       // 0 to 8
	
	            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]
	
	            // The exponent value at and beneath which toString returns exponential notation.
	            // Number type: -7
	            TO_EXP_NEG = -7,                         // 0 to -MAX
	
	            // The exponent value at and above which toString returns exponential notation.
	            // Number type: 21
	            TO_EXP_POS = 21,                         // 0 to MAX
	
	            // RANGE : [MIN_EXP, MAX_EXP]
	
	            // The minimum exponent value, beneath which underflow to zero occurs.
	            // Number type: -324  (5e-324)
	            MIN_EXP = -1e7,                          // -1 to -MAX
	
	            // The maximum exponent value, above which overflow to Infinity occurs.
	            // Number type:  308  (1.7976931348623157e+308)
	            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
	            MAX_EXP = 1e7,                           // 1 to MAX
	
	            // Whether BigNumber Errors are ever thrown.
	            ERRORS = true,                           // true or false
	
	            // Change to intValidatorNoErrors if ERRORS is false.
	            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors
	
	            // Whether to use cryptographically-secure random number generation, if available.
	            CRYPTO = false,                          // true or false
	
	            /*
	             * The modulo mode used when calculating the modulus: a mod n.
	             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
	             * The remainder (r) is calculated as: r = a - n * q.
	             *
	             * UP        0 The remainder is positive if the dividend is negative, else is negative.
	             * DOWN      1 The remainder has the same sign as the dividend.
	             *             This modulo mode is commonly known as 'truncated division' and is
	             *             equivalent to (a % n) in JavaScript.
	             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
	             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
	             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
	             *             The remainder is always positive.
	             *
	             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
	             * modes are commonly used for the modulus operation.
	             * Although the other rounding modes can also be used, they may not give useful results.
	             */
	            MODULO_MODE = 1,                         // 0 to 9
	
	            // The maximum number of significant digits of the result of the toPower operation.
	            // If POW_PRECISION is 0, there will be unlimited significant digits.
	            POW_PRECISION = 100,                     // 0 to MAX
	
	            // The format specification used by the BigNumber.prototype.toFormat method.
	            FORMAT = {
	                decimalSeparator: '.',
	                groupSeparator: ',',
	                groupSize: 3,
	                secondaryGroupSize: 0,
	                fractionGroupSeparator: '\xA0',      // non-breaking space
	                fractionGroupSize: 0
	            };
	
	
	        /******************************************************************************************/
	
	
	        // CONSTRUCTOR
	
	
	        /*
	         * The BigNumber constructor and exported function.
	         * Create and return a new instance of a BigNumber object.
	         *
	         * n {number|string|BigNumber} A numeric value.
	         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
	         */
	        function BigNumber( n, b ) {
	            var c, e, i, num, len, str,
	                x = this;
	
	            // Enable constructor usage without new.
	            if ( !( x instanceof BigNumber ) ) {
	
	                // 'BigNumber() constructor call without new: {n}'
	                if (ERRORS) raise( 26, 'constructor call without new', n );
	                return new BigNumber( n, b );
	            }
	
	            // 'new BigNumber() base not an integer: {b}'
	            // 'new BigNumber() base out of range: {b}'
	            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {
	
	                // Duplicate.
	                if ( n instanceof BigNumber ) {
	                    x.s = n.s;
	                    x.e = n.e;
	                    x.c = ( n = n.c ) ? n.slice() : n;
	                    id = 0;
	                    return;
	                }
	
	                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
	                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;
	
	                    // Fast path for integers.
	                    if ( n === ~~n ) {
	                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
	                        x.e = e;
	                        x.c = [n];
	                        id = 0;
	                        return;
	                    }
	
	                    str = n + '';
	                } else {
	                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
	                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
	                }
	            } else {
	                b = b | 0;
	                str = n + '';
	
	                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
	                // Allow exponential notation to be used with base 10 argument.
	                if ( b == 10 ) {
	                    x = new BigNumber( n instanceof BigNumber ? n : str );
	                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
	                }
	
	                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
	                // Any number in exponential form will fail due to the [Ee][+-].
	                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
	                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
	                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
	                    return parseNumeric( x, str, num, b );
	                }
	
	                if (num) {
	                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;
	
	                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {
	
	                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
	                        raise( id, tooManyDigits, n );
	                    }
	
	                    // Prevent later check for length on converted number.
	                    num = false;
	                } else {
	                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
	                }
	
	                str = convertBase( str, 10, b, x.s );
	            }
	
	            // Decimal point?
	            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );
	
	            // Exponential form?
	            if ( ( i = str.search( /e/i ) ) > 0 ) {
	
	                // Determine exponent.
	                if ( e < 0 ) e = i;
	                e += +str.slice( i + 1 );
	                str = str.substring( 0, i );
	            } else if ( e < 0 ) {
	
	                // Integer.
	                e = str.length;
	            }
	
	            // Determine leading zeros.
	            for ( i = 0; str.charCodeAt(i) === 48; i++ );
	
	            // Determine trailing zeros.
	            for ( len = str.length; str.charCodeAt(--len) === 48; );
	            str = str.slice( i, len + 1 );
	
	            if (str) {
	                len = str.length;
	
	                // Disallow numbers with over 15 significant digits if number type.
	                // 'new BigNumber() number type has more than 15 significant digits: {n}'
	                if ( num && ERRORS && len > 15 && ( n > MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
	                    raise( id, tooManyDigits, x.s * n );
	                }
	
	                e = e - i - 1;
	
	                 // Overflow?
	                if ( e > MAX_EXP ) {
	
	                    // Infinity.
	                    x.c = x.e = null;
	
	                // Underflow?
	                } else if ( e < MIN_EXP ) {
	
	                    // Zero.
	                    x.c = [ x.e = 0 ];
	                } else {
	                    x.e = e;
	                    x.c = [];
	
	                    // Transform base
	
	                    // e is the base 10 exponent.
	                    // i is where to slice str to get the first element of the coefficient array.
	                    i = ( e + 1 ) % LOG_BASE;
	                    if ( e < 0 ) i += LOG_BASE;
	
	                    if ( i < len ) {
	                        if (i) x.c.push( +str.slice( 0, i ) );
	
	                        for ( len -= LOG_BASE; i < len; ) {
	                            x.c.push( +str.slice( i, i += LOG_BASE ) );
	                        }
	
	                        str = str.slice(i);
	                        i = LOG_BASE - str.length;
	                    } else {
	                        i -= len;
	                    }
	
	                    for ( ; i--; str += '0' );
	                    x.c.push( +str );
	                }
	            } else {
	
	                // Zero.
	                x.c = [ x.e = 0 ];
	            }
	
	            id = 0;
	        }
	
	
	        // CONSTRUCTOR PROPERTIES
	
	
	        BigNumber.another = constructorFactory;
	
	        BigNumber.ROUND_UP = 0;
	        BigNumber.ROUND_DOWN = 1;
	        BigNumber.ROUND_CEIL = 2;
	        BigNumber.ROUND_FLOOR = 3;
	        BigNumber.ROUND_HALF_UP = 4;
	        BigNumber.ROUND_HALF_DOWN = 5;
	        BigNumber.ROUND_HALF_EVEN = 6;
	        BigNumber.ROUND_HALF_CEIL = 7;
	        BigNumber.ROUND_HALF_FLOOR = 8;
	        BigNumber.EUCLID = 9;
	
	
	        /*
	         * Configure infrequently-changing library-wide settings.
	         *
	         * Accept an object or an argument list, with one or many of the following properties or
	         * parameters respectively:
	         *
	         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
	         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
	         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
	         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
	         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
	         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
	         *   ERRORS          {boolean|number}   true, false, 1 or 0
	         *   CRYPTO          {boolean|number}   true, false, 1 or 0
	         *   MODULO_MODE     {number}           0 to 9 inclusive
	         *   POW_PRECISION   {number}           0 to MAX inclusive
	         *   FORMAT          {object}           See BigNumber.prototype.toFormat
	         *      decimalSeparator       {string}
	         *      groupSeparator         {string}
	         *      groupSize              {number}
	         *      secondaryGroupSize     {number}
	         *      fractionGroupSeparator {string}
	         *      fractionGroupSize      {number}
	         *
	         * (The values assigned to the above FORMAT object properties are not checked for validity.)
	         *
	         * E.g.
	         * BigNumber.config(20, 4) is equivalent to
	         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
	         *
	         * Ignore properties/parameters set to null or undefined.
	         * Return an object with the properties current values.
	         */
	        BigNumber.config = function () {
	            var v, p,
	                i = 0,
	                r = {},
	                a = arguments,
	                o = a[0],
	                has = o && typeof o == 'object'
	                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
	                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };
	
	            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
	            // 'config() DECIMAL_PLACES not an integer: {v}'
	            // 'config() DECIMAL_PLACES out of range: {v}'
	            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
	                DECIMAL_PLACES = v | 0;
	            }
	            r[p] = DECIMAL_PLACES;
	
	            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
	            // 'config() ROUNDING_MODE not an integer: {v}'
	            // 'config() ROUNDING_MODE out of range: {v}'
	            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
	                ROUNDING_MODE = v | 0;
	            }
	            r[p] = ROUNDING_MODE;
	
	            // EXPONENTIAL_AT {number|number[]}
	            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
	            // 'config() EXPONENTIAL_AT not an integer: {v}'
	            // 'config() EXPONENTIAL_AT out of range: {v}'
	            if ( has( p = 'EXPONENTIAL_AT' ) ) {
	
	                if ( isArray(v) ) {
	                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
	                        TO_EXP_NEG = v[0] | 0;
	                        TO_EXP_POS = v[1] | 0;
	                    }
	                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
	                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
	                }
	            }
	            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];
	
	            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
	            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
	            // 'config() RANGE not an integer: {v}'
	            // 'config() RANGE cannot be zero: {v}'
	            // 'config() RANGE out of range: {v}'
	            if ( has( p = 'RANGE' ) ) {
	
	                if ( isArray(v) ) {
	                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
	                        MIN_EXP = v[0] | 0;
	                        MAX_EXP = v[1] | 0;
	                    }
	                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
	                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
	                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
	                }
	            }
	            r[p] = [ MIN_EXP, MAX_EXP ];
	
	            // ERRORS {boolean|number} true, false, 1 or 0.
	            // 'config() ERRORS not a boolean or binary digit: {v}'
	            if ( has( p = 'ERRORS' ) ) {
	
	                if ( v === !!v || v === 1 || v === 0 ) {
	                    id = 0;
	                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
	                } else if (ERRORS) {
	                    raise( 2, p + notBool, v );
	                }
	            }
	            r[p] = ERRORS;
	
	            // CRYPTO {boolean|number} true, false, 1 or 0.
	            // 'config() CRYPTO not a boolean or binary digit: {v}'
	            // 'config() crypto unavailable: {crypto}'
	            if ( has( p = 'CRYPTO' ) ) {
	
	                if ( v === !!v || v === 1 || v === 0 ) {
	                    CRYPTO = !!( v && cryptoObj );
	                    if ( v && !CRYPTO && ERRORS ) raise( 2, 'crypto unavailable', cryptoObj );
	                } else if (ERRORS) {
	                    raise( 2, p + notBool, v );
	                }
	            }
	            r[p] = CRYPTO;
	
	            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
	            // 'config() MODULO_MODE not an integer: {v}'
	            // 'config() MODULO_MODE out of range: {v}'
	            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
	                MODULO_MODE = v | 0;
	            }
	            r[p] = MODULO_MODE;
	
	            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
	            // 'config() POW_PRECISION not an integer: {v}'
	            // 'config() POW_PRECISION out of range: {v}'
	            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
	                POW_PRECISION = v | 0;
	            }
	            r[p] = POW_PRECISION;
	
	            // FORMAT {object}
	            // 'config() FORMAT not an object: {v}'
	            if ( has( p = 'FORMAT' ) ) {
	
	                if ( typeof v == 'object' ) {
	                    FORMAT = v;
	                } else if (ERRORS) {
	                    raise( 2, p + ' not an object', v );
	                }
	            }
	            r[p] = FORMAT;
	
	            return r;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the maximum of the arguments.
	         *
	         * arguments {number|string|BigNumber}
	         */
	        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };
	
	
	        /*
	         * Return a new BigNumber whose value is the minimum of the arguments.
	         *
	         * arguments {number|string|BigNumber}
	         */
	        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };
	
	
	        /*
	         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
	         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
	         * zeros are produced).
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         *
	         * 'random() decimal places not an integer: {dp}'
	         * 'random() decimal places out of range: {dp}'
	         * 'random() crypto unavailable: {crypto}'
	         */
	        BigNumber.random = (function () {
	            var pow2_53 = 0x20000000000000;
	
	            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
	            // Check if Math.random() produces more than 32 bits of randomness.
	            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
	            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
	            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
	              ? function () { return mathfloor( Math.random() * pow2_53 ); }
	              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
	                  (Math.random() * 0x800000 | 0); };
	
	            return function (dp) {
	                var a, b, e, k, v,
	                    i = 0,
	                    c = [],
	                    rand = new BigNumber(ONE);
	
	                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
	                k = mathceil( dp / LOG_BASE );
	
	                if (CRYPTO) {
	
	                    // Browsers supporting crypto.getRandomValues.
	                    if ( cryptoObj && cryptoObj.getRandomValues ) {
	
	                        a = cryptoObj.getRandomValues( new Uint32Array( k *= 2 ) );
	
	                        for ( ; i < k; ) {
	
	                            // 53 bits:
	                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
	                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
	                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
	                            //                                     11111 11111111 11111111
	                            // 0x20000 is 2^21.
	                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);
	
	                            // Rejection sampling:
	                            // 0 <= v < 9007199254740992
	                            // Probability that v >= 9e15, is
	                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
	                            if ( v >= 9e15 ) {
	                                b = cryptoObj.getRandomValues( new Uint32Array(2) );
	                                a[i] = b[0];
	                                a[i + 1] = b[1];
	                            } else {
	
	                                // 0 <= v <= 8999999999999999
	                                // 0 <= (v % 1e14) <= 99999999999999
	                                c.push( v % 1e14 );
	                                i += 2;
	                            }
	                        }
	                        i = k / 2;
	
	                    // Node.js supporting crypto.randomBytes.
	                    } else if ( cryptoObj && cryptoObj.randomBytes ) {
	
	                        // buffer
	                        a = cryptoObj.randomBytes( k *= 7 );
	
	                        for ( ; i < k; ) {
	
	                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
	                            // 0x100000000 is 2^32, 0x1000000 is 2^24
	                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
	                            // 0 <= v < 9007199254740992
	                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
	                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
	                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];
	
	                            if ( v >= 9e15 ) {
	                                cryptoObj.randomBytes(7).copy( a, i );
	                            } else {
	
	                                // 0 <= (v % 1e14) <= 99999999999999
	                                c.push( v % 1e14 );
	                                i += 7;
	                            }
	                        }
	                        i = k / 7;
	                    } else if (ERRORS) {
	                        raise( 14, 'crypto unavailable', cryptoObj );
	                    }
	                }
	
	                // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
	                if (!i) {
	
	                    for ( ; i < k; ) {
	                        v = random53bitInt();
	                        if ( v < 9e15 ) c[i++] = v % 1e14;
	                    }
	                }
	
	                k = c[--i];
	                dp %= LOG_BASE;
	
	                // Convert trailing digits to zeros according to dp.
	                if ( k && dp ) {
	                    v = POWS_TEN[LOG_BASE - dp];
	                    c[i] = mathfloor( k / v ) * v;
	                }
	
	                // Remove trailing elements which are zero.
	                for ( ; c[i] === 0; c.pop(), i-- );
	
	                // Zero?
	                if ( i < 0 ) {
	                    c = [ e = 0 ];
	                } else {
	
	                    // Remove leading elements which are zero and adjust exponent accordingly.
	                    for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);
	
	                    // Count the digits of the first element of c to determine leading zeros, and...
	                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);
	
	                    // adjust the exponent accordingly.
	                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
	                }
	
	                rand.e = e;
	                rand.c = c;
	                return rand;
	            };
	        })();
	
	
	        // PRIVATE FUNCTIONS
	
	
	        // Convert a numeric string of baseIn to a numeric string of baseOut.
	        function convertBase( str, baseOut, baseIn, sign ) {
	            var d, e, k, r, x, xc, y,
	                i = str.indexOf( '.' ),
	                dp = DECIMAL_PLACES,
	                rm = ROUNDING_MODE;
	
	            if ( baseIn < 37 ) str = str.toLowerCase();
	
	            // Non-integer.
	            if ( i >= 0 ) {
	                k = POW_PRECISION;
	
	                // Unlimited precision.
	                POW_PRECISION = 0;
	                str = str.replace( '.', '' );
	                y = new BigNumber(baseIn);
	                x = y.pow( str.length - i );
	                POW_PRECISION = k;
	
	                // Convert str as if an integer, then restore the fraction part by dividing the
	                // result by its base raised to a power.
	                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
	                y.e = y.c.length;
	            }
	
	            // Convert the number as integer.
	            xc = toBaseOut( str, baseIn, baseOut );
	            e = k = xc.length;
	
	            // Remove trailing zeros.
	            for ( ; xc[--k] == 0; xc.pop() );
	            if ( !xc[0] ) return '0';
	
	            if ( i < 0 ) {
	                --e;
	            } else {
	                x.c = xc;
	                x.e = e;
	
	                // sign is needed for correct rounding.
	                x.s = sign;
	                x = div( x, y, dp, rm, baseOut );
	                xc = x.c;
	                r = x.r;
	                e = x.e;
	            }
	
	            d = e + dp + 1;
	
	            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
	            i = xc[d];
	            k = baseOut / 2;
	            r = r || d < 0 || xc[d + 1] != null;
	
	            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
	                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
	                         rm == ( x.s < 0 ? 8 : 7 ) );
	
	            if ( d < 1 || !xc[0] ) {
	
	                // 1^-dp or 0.
	                str = r ? toFixedPoint( '1', -dp ) : '0';
	            } else {
	                xc.length = d;
	
	                if (r) {
	
	                    // Rounding up may mean the previous digit has to be rounded up and so on.
	                    for ( --baseOut; ++xc[--d] > baseOut; ) {
	                        xc[d] = 0;
	
	                        if ( !d ) {
	                            ++e;
	                            xc.unshift(1);
	                        }
	                    }
	                }
	
	                // Determine trailing zeros.
	                for ( k = xc.length; !xc[--k]; );
	
	                // E.g. [4, 11, 15] becomes 4bf.
	                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
	                str = toFixedPoint( str, e );
	            }
	
	            // The caller will add the sign.
	            return str;
	        }
	
	
	        // Perform division in the specified base. Called by div and convertBase.
	        div = (function () {
	
	            // Assume non-zero x and k.
	            function multiply( x, k, base ) {
	                var m, temp, xlo, xhi,
	                    carry = 0,
	                    i = x.length,
	                    klo = k % SQRT_BASE,
	                    khi = k / SQRT_BASE | 0;
	
	                for ( x = x.slice(); i--; ) {
	                    xlo = x[i] % SQRT_BASE;
	                    xhi = x[i] / SQRT_BASE | 0;
	                    m = khi * xlo + xhi * klo;
	                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
	                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
	                    x[i] = temp % base;
	                }
	
	                if (carry) x.unshift(carry);
	
	                return x;
	            }
	
	            function compare( a, b, aL, bL ) {
	                var i, cmp;
	
	                if ( aL != bL ) {
	                    cmp = aL > bL ? 1 : -1;
	                } else {
	
	                    for ( i = cmp = 0; i < aL; i++ ) {
	
	                        if ( a[i] != b[i] ) {
	                            cmp = a[i] > b[i] ? 1 : -1;
	                            break;
	                        }
	                    }
	                }
	                return cmp;
	            }
	
	            function subtract( a, b, aL, base ) {
	                var i = 0;
	
	                // Subtract b from a.
	                for ( ; aL--; ) {
	                    a[aL] -= i;
	                    i = a[aL] < b[aL] ? 1 : 0;
	                    a[aL] = i * base + a[aL] - b[aL];
	                }
	
	                // Remove leading zeros.
	                for ( ; !a[0] && a.length > 1; a.shift() );
	            }
	
	            // x: dividend, y: divisor.
	            return function ( x, y, dp, rm, base ) {
	                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
	                    yL, yz,
	                    s = x.s == y.s ? 1 : -1,
	                    xc = x.c,
	                    yc = y.c;
	
	                // Either NaN, Infinity or 0?
	                if ( !xc || !xc[0] || !yc || !yc[0] ) {
	
	                    return new BigNumber(
	
	                      // Return NaN if either NaN, or both Infinity or 0.
	                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :
	
	                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
	                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
	                    );
	                }
	
	                q = new BigNumber(s);
	                qc = q.c = [];
	                e = x.e - y.e;
	                s = dp + e + 1;
	
	                if ( !base ) {
	                    base = BASE;
	                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
	                    s = s / LOG_BASE | 0;
	                }
	
	                // Result exponent may be one less then the current value of e.
	                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
	                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
	                if ( yc[i] > ( xc[i] || 0 ) ) e--;
	
	                if ( s < 0 ) {
	                    qc.push(1);
	                    more = true;
	                } else {
	                    xL = xc.length;
	                    yL = yc.length;
	                    i = 0;
	                    s += 2;
	
	                    // Normalise xc and yc so highest order digit of yc is >= base / 2.
	
	                    n = mathfloor( base / ( yc[0] + 1 ) );
	
	                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
	                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
	                    if ( n > 1 ) {
	                        yc = multiply( yc, n, base );
	                        xc = multiply( xc, n, base );
	                        yL = yc.length;
	                        xL = xc.length;
	                    }
	
	                    xi = yL;
	                    rem = xc.slice( 0, yL );
	                    remL = rem.length;
	
	                    // Add zeros to make remainder as long as divisor.
	                    for ( ; remL < yL; rem[remL++] = 0 );
	                    yz = yc.slice();
	                    yz.unshift(0);
	                    yc0 = yc[0];
	                    if ( yc[1] >= base / 2 ) yc0++;
	                    // Not necessary, but to prevent trial digit n > base, when using base 3.
	                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;
	
	                    do {
	                        n = 0;
	
	                        // Compare divisor and remainder.
	                        cmp = compare( yc, rem, yL, remL );
	
	                        // If divisor < remainder.
	                        if ( cmp < 0 ) {
	
	                            // Calculate trial digit, n.
	
	                            rem0 = rem[0];
	                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );
	
	                            // n is how many times the divisor goes into the current remainder.
	                            n = mathfloor( rem0 / yc0 );
	
	                            //  Algorithm:
	                            //  1. product = divisor * trial digit (n)
	                            //  2. if product > remainder: product -= divisor, n--
	                            //  3. remainder -= product
	                            //  4. if product was < remainder at 2:
	                            //    5. compare new remainder and divisor
	                            //    6. If remainder > divisor: remainder -= divisor, n++
	
	                            if ( n > 1 ) {
	
	                                // n may be > base only when base is 3.
	                                if (n >= base) n = base - 1;
	
	                                // product = divisor * trial digit.
	                                prod = multiply( yc, n, base );
	                                prodL = prod.length;
	                                remL = rem.length;
	
	                                // Compare product and remainder.
	                                // If product > remainder.
	                                // Trial digit n too high.
	                                // n is 1 too high about 5% of the time, and is not known to have
	                                // ever been more than 1 too high.
	                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
	                                    n--;
	
	                                    // Subtract divisor from product.
	                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
	                                    prodL = prod.length;
	                                    cmp = 1;
	                                }
	                            } else {
	
	                                // n is 0 or 1, cmp is -1.
	                                // If n is 0, there is no need to compare yc and rem again below,
	                                // so change cmp to 1 to avoid it.
	                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
	                                if ( n == 0 ) {
	
	                                    // divisor < remainder, so n must be at least 1.
	                                    cmp = n = 1;
	                                }
	
	                                // product = divisor
	                                prod = yc.slice();
	                                prodL = prod.length;
	                            }
	
	                            if ( prodL < remL ) prod.unshift(0);
	
	                            // Subtract product from remainder.
	                            subtract( rem, prod, remL, base );
	                            remL = rem.length;
	
	                             // If product was < remainder.
	                            if ( cmp == -1 ) {
	
	                                // Compare divisor and new remainder.
	                                // If divisor < new remainder, subtract divisor from remainder.
	                                // Trial digit n too low.
	                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
	                                while ( compare( yc, rem, yL, remL ) < 1 ) {
	                                    n++;
	
	                                    // Subtract divisor from remainder.
	                                    subtract( rem, yL < remL ? yz : yc, remL, base );
	                                    remL = rem.length;
	                                }
	                            }
	                        } else if ( cmp === 0 ) {
	                            n++;
	                            rem = [0];
	                        } // else cmp === 1 and n will be 0
	
	                        // Add the next digit, n, to the result array.
	                        qc[i++] = n;
	
	                        // Update the remainder.
	                        if ( rem[0] ) {
	                            rem[remL++] = xc[xi] || 0;
	                        } else {
	                            rem = [ xc[xi] ];
	                            remL = 1;
	                        }
	                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );
	
	                    more = rem[0] != null;
	
	                    // Leading zero?
	                    if ( !qc[0] ) qc.shift();
	                }
	
	                if ( base == BASE ) {
	
	                    // To calculate q.e, first get the number of digits of qc[0].
	                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
	                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );
	
	                // Caller is convertBase.
	                } else {
	                    q.e = e;
	                    q.r = +more;
	                }
	
	                return q;
	            };
	        })();
	
	
	        /*
	         * Return a string representing the value of BigNumber n in fixed-point or exponential
	         * notation rounded to the specified decimal places or significant digits.
	         *
	         * n is a BigNumber.
	         * i is the index of the last digit required (i.e. the digit that may be rounded up).
	         * rm is the rounding mode.
	         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
	         */
	        function format( n, i, rm, caller ) {
	            var c0, e, ne, len, str;
	
	            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
	              ? rm | 0 : ROUNDING_MODE;
	
	            if ( !n.c ) return n.toString();
	            c0 = n.c[0];
	            ne = n.e;
	
	            if ( i == null ) {
	                str = coeffToString( n.c );
	                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
	                  ? toExponential( str, ne )
	                  : toFixedPoint( str, ne );
	            } else {
	                n = round( new BigNumber(n), i, rm );
	
	                // n.e may have changed if the value was rounded up.
	                e = n.e;
	
	                str = coeffToString( n.c );
	                len = str.length;
	
	                // toPrecision returns exponential notation if the number of significant digits
	                // specified is less than the number of digits necessary to represent the integer
	                // part of the value in fixed-point notation.
	
	                // Exponential notation.
	                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {
	
	                    // Append zeros?
	                    for ( ; len < i; str += '0', len++ );
	                    str = toExponential( str, e );
	
	                // Fixed-point notation.
	                } else {
	                    i -= ne;
	                    str = toFixedPoint( str, e );
	
	                    // Append zeros?
	                    if ( e + 1 > len ) {
	                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
	                    } else {
	                        i += e - len;
	                        if ( i > 0 ) {
	                            if ( e + 1 == len ) str += '.';
	                            for ( ; i--; str += '0' );
	                        }
	                    }
	                }
	            }
	
	            return n.s < 0 && c0 ? '-' + str : str;
	        }
	
	
	        // Handle BigNumber.max and BigNumber.min.
	        function maxOrMin( args, method ) {
	            var m, n,
	                i = 0;
	
	            if ( isArray( args[0] ) ) args = args[0];
	            m = new BigNumber( args[0] );
	
	            for ( ; ++i < args.length; ) {
	                n = new BigNumber( args[i] );
	
	                // If any number is NaN, return NaN.
	                if ( !n.s ) {
	                    m = n;
	                    break;
	                } else if ( method.call( m, n ) ) {
	                    m = n;
	                }
	            }
	
	            return m;
	        }
	
	
	        /*
	         * Return true if n is an integer in range, otherwise throw.
	         * Use for argument validation when ERRORS is true.
	         */
	        function intValidatorWithErrors( n, min, max, caller, name ) {
	            if ( n < min || n > max || n != truncate(n) ) {
	                raise( caller, ( name || 'decimal places' ) +
	                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
	            }
	
	            return true;
	        }
	
	
	        /*
	         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
	         * Called by minus, plus and times.
	         */
	        function normalise( n, c, e ) {
	            var i = 1,
	                j = c.length;
	
	             // Remove trailing zeros.
	            for ( ; !c[--j]; c.pop() );
	
	            // Calculate the base 10 exponent. First get the number of digits of c[0].
	            for ( j = c[0]; j >= 10; j /= 10, i++ );
	
	            // Overflow?
	            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {
	
	                // Infinity.
	                n.c = n.e = null;
	
	            // Underflow?
	            } else if ( e < MIN_EXP ) {
	
	                // Zero.
	                n.c = [ n.e = 0 ];
	            } else {
	                n.e = e;
	                n.c = c;
	            }
	
	            return n;
	        }
	
	
	        // Handle values that fail the validity test in BigNumber.
	        parseNumeric = (function () {
	            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
	                dotAfter = /^([^.]+)\.$/,
	                dotBefore = /^\.([^.]+)$/,
	                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
	                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
	
	            return function ( x, str, num, b ) {
	                var base,
	                    s = num ? str : str.replace( whitespaceOrPlus, '' );
	
	                // No exception on ±Infinity or NaN.
	                if ( isInfinityOrNaN.test(s) ) {
	                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
	                } else {
	                    if ( !num ) {
	
	                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
	                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
	                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
	                            return !b || b == base ? p1 : m;
	                        });
	
	                        if (b) {
	                            base = b;
	
	                            // E.g. '1.' to '1', '.1' to '0.1'
	                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
	                        }
	
	                        if ( str != s ) return new BigNumber( s, base );
	                    }
	
	                    // 'new BigNumber() not a number: {n}'
	                    // 'new BigNumber() not a base {b} number: {n}'
	                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
	                    x.s = null;
	                }
	
	                x.c = x.e = null;
	                id = 0;
	            }
	        })();
	
	
	        // Throw a BigNumber Error.
	        function raise( caller, msg, val ) {
	            var error = new Error( [
	                'new BigNumber',     // 0
	                'cmp',               // 1
	                'config',            // 2
	                'div',               // 3
	                'divToInt',          // 4
	                'eq',                // 5
	                'gt',                // 6
	                'gte',               // 7
	                'lt',                // 8
	                'lte',               // 9
	                'minus',             // 10
	                'mod',               // 11
	                'plus',              // 12
	                'precision',         // 13
	                'random',            // 14
	                'round',             // 15
	                'shift',             // 16
	                'times',             // 17
	                'toDigits',          // 18
	                'toExponential',     // 19
	                'toFixed',           // 20
	                'toFormat',          // 21
	                'toFraction',        // 22
	                'pow',               // 23
	                'toPrecision',       // 24
	                'toString',          // 25
	                'BigNumber'          // 26
	            ][caller] + '() ' + msg + ': ' + val );
	
	            error.name = 'BigNumber Error';
	            id = 0;
	            throw error;
	        }
	
	
	        /*
	         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
	         * If r is truthy, it is known that there are more digits after the rounding digit.
	         */
	        function round( x, sd, rm, r ) {
	            var d, i, j, k, n, ni, rd,
	                xc = x.c,
	                pows10 = POWS_TEN;
	
	            // if x is not Infinity or NaN...
	            if (xc) {
	
	                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
	                // n is a base 1e14 number, the value of the element of array x.c containing rd.
	                // ni is the index of n within x.c.
	                // d is the number of digits of n.
	                // i is the index of rd within n including leading zeros.
	                // j is the actual index of rd within n (if < 0, rd is a leading zero).
	                out: {
	
	                    // Get the number of digits of the first element of xc.
	                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
	                    i = sd - d;
	
	                    // If the rounding digit is in the first element of xc...
	                    if ( i < 0 ) {
	                        i += LOG_BASE;
	                        j = sd;
	                        n = xc[ ni = 0 ];
	
	                        // Get the rounding digit at index j of n.
	                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
	                    } else {
	                        ni = mathceil( ( i + 1 ) / LOG_BASE );
	
	                        if ( ni >= xc.length ) {
	
	                            if (r) {
	
	                                // Needed by sqrt.
	                                for ( ; xc.length <= ni; xc.push(0) );
	                                n = rd = 0;
	                                d = 1;
	                                i %= LOG_BASE;
	                                j = i - LOG_BASE + 1;
	                            } else {
	                                break out;
	                            }
	                        } else {
	                            n = k = xc[ni];
	
	                            // Get the number of digits of n.
	                            for ( d = 1; k >= 10; k /= 10, d++ );
	
	                            // Get the index of rd within n.
	                            i %= LOG_BASE;
	
	                            // Get the index of rd within n, adjusted for leading zeros.
	                            // The number of leading zeros of n is given by LOG_BASE - d.
	                            j = i - LOG_BASE + d;
	
	                            // Get the rounding digit at index j of n.
	                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
	                        }
	                    }
	
	                    r = r || sd < 0 ||
	
	                    // Are there any non-zero digits after the rounding digit?
	                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
	                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
	                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );
	
	                    r = rm < 4
	                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
	                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&
	
	                        // Check whether the digit to the left of the rounding digit is odd.
	                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
	                          rm == ( x.s < 0 ? 8 : 7 ) );
	
	                    if ( sd < 1 || !xc[0] ) {
	                        xc.length = 0;
	
	                        if (r) {
	
	                            // Convert sd to decimal places.
	                            sd -= x.e + 1;
	
	                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
	                            xc[0] = pows10[ ( LOG_BASE - sd % LOG_BASE ) % LOG_BASE ];
	                            x.e = -sd || 0;
	                        } else {
	
	                            // Zero.
	                            xc[0] = x.e = 0;
	                        }
	
	                        return x;
	                    }
	
	                    // Remove excess digits.
	                    if ( i == 0 ) {
	                        xc.length = ni;
	                        k = 1;
	                        ni--;
	                    } else {
	                        xc.length = ni + 1;
	                        k = pows10[ LOG_BASE - i ];
	
	                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
	                        // j > 0 means i > number of leading zeros of n.
	                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
	                    }
	
	                    // Round up?
	                    if (r) {
	
	                        for ( ; ; ) {
	
	                            // If the digit to be rounded up is in the first element of xc...
	                            if ( ni == 0 ) {
	
	                                // i will be the length of xc[0] before k is added.
	                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
	                                j = xc[0] += k;
	                                for ( k = 1; j >= 10; j /= 10, k++ );
	
	                                // if i != k the length has increased.
	                                if ( i != k ) {
	                                    x.e++;
	                                    if ( xc[0] == BASE ) xc[0] = 1;
	                                }
	
	                                break;
	                            } else {
	                                xc[ni] += k;
	                                if ( xc[ni] != BASE ) break;
	                                xc[ni--] = 0;
	                                k = 1;
	                            }
	                        }
	                    }
	
	                    // Remove trailing zeros.
	                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
	                }
	
	                // Overflow? Infinity.
	                if ( x.e > MAX_EXP ) {
	                    x.c = x.e = null;
	
	                // Underflow? Zero.
	                } else if ( x.e < MIN_EXP ) {
	                    x.c = [ x.e = 0 ];
	                }
	            }
	
	            return x;
	        }
	
	
	        // PROTOTYPE/INSTANCE METHODS
	
	
	        /*
	         * Return a new BigNumber whose value is the absolute value of this BigNumber.
	         */
	        P.absoluteValue = P.abs = function () {
	            var x = new BigNumber(this);
	            if ( x.s < 0 ) x.s = 1;
	            return x;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
	         * number in the direction of Infinity.
	         */
	        P.ceil = function () {
	            return round( new BigNumber(this), this.e + 1, 2 );
	        };
	
	
	        /*
	         * Return
	         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
	         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
	         * 0 if they have the same value,
	         * or null if the value of either is NaN.
	         */
	        P.comparedTo = P.cmp = function ( y, b ) {
	            id = 1;
	            return compare( this, new BigNumber( y, b ) );
	        };
	
	
	        /*
	         * Return the number of decimal places of the value of this BigNumber, or null if the value
	         * of this BigNumber is ±Infinity or NaN.
	         */
	        P.decimalPlaces = P.dp = function () {
	            var n, v,
	                c = this.c;
	
	            if ( !c ) return null;
	            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;
	
	            // Subtract the number of trailing zeros of the last number.
	            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
	            if ( n < 0 ) n = 0;
	
	            return n;
	        };
	
	
	        /*
	         *  n / 0 = I
	         *  n / N = N
	         *  n / I = 0
	         *  0 / n = 0
	         *  0 / 0 = N
	         *  0 / N = N
	         *  0 / I = 0
	         *  N / n = N
	         *  N / 0 = N
	         *  N / N = N
	         *  N / I = N
	         *  I / n = I
	         *  I / 0 = I
	         *  I / N = N
	         *  I / I = N
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
	         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
	         */
	        P.dividedBy = P.div = function ( y, b ) {
	            id = 3;
	            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the integer part of dividing the value of this
	         * BigNumber by the value of BigNumber(y, b).
	         */
	        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
	            id = 4;
	            return div( this, new BigNumber( y, b ), 0, 1 );
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
	         * otherwise returns false.
	         */
	        P.equals = P.eq = function ( y, b ) {
	            id = 5;
	            return compare( this, new BigNumber( y, b ) ) === 0;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
	         * number in the direction of -Infinity.
	         */
	        P.floor = function () {
	            return round( new BigNumber(this), this.e + 1, 3 );
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
	         * otherwise returns false.
	         */
	        P.greaterThan = P.gt = function ( y, b ) {
	            id = 6;
	            return compare( this, new BigNumber( y, b ) ) > 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is greater than or equal to the value of
	         * BigNumber(y, b), otherwise returns false.
	         */
	        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
	            id = 7;
	            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;
	
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
	         */
	        P.isFinite = function () {
	            return !!this.c;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is an integer, otherwise return false.
	         */
	        P.isInteger = P.isInt = function () {
	            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is NaN, otherwise returns false.
	         */
	        P.isNaN = function () {
	            return !this.s;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is negative, otherwise returns false.
	         */
	        P.isNegative = P.isNeg = function () {
	            return this.s < 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
	         */
	        P.isZero = function () {
	            return !!this.c && this.c[0] == 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
	         * otherwise returns false.
	         */
	        P.lessThan = P.lt = function ( y, b ) {
	            id = 8;
	            return compare( this, new BigNumber( y, b ) ) < 0;
	        };
	
	
	        /*
	         * Return true if the value of this BigNumber is less than or equal to the value of
	         * BigNumber(y, b), otherwise returns false.
	         */
	        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
	            id = 9;
	            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
	        };
	
	
	        /*
	         *  n - 0 = n
	         *  n - N = N
	         *  n - I = -I
	         *  0 - n = -n
	         *  0 - 0 = 0
	         *  0 - N = N
	         *  0 - I = -I
	         *  N - n = N
	         *  N - 0 = N
	         *  N - N = N
	         *  N - I = N
	         *  I - n = I
	         *  I - 0 = I
	         *  I - N = N
	         *  I - I = N
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
	         * BigNumber(y, b).
	         */
	        P.minus = P.sub = function ( y, b ) {
	            var i, j, t, xLTy,
	                x = this,
	                a = x.s;
	
	            id = 10;
	            y = new BigNumber( y, b );
	            b = y.s;
	
	            // Either NaN?
	            if ( !a || !b ) return new BigNumber(NaN);
	
	            // Signs differ?
	            if ( a != b ) {
	                y.s = -b;
	                return x.plus(y);
	            }
	
	            var xe = x.e / LOG_BASE,
	                ye = y.e / LOG_BASE,
	                xc = x.c,
	                yc = y.c;
	
	            if ( !xe || !ye ) {
	
	                // Either Infinity?
	                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );
	
	                // Either zero?
	                if ( !xc[0] || !yc[0] ) {
	
	                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
	                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :
	
	                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
	                      ROUNDING_MODE == 3 ? -0 : 0 );
	                }
	            }
	
	            xe = bitFloor(xe);
	            ye = bitFloor(ye);
	            xc = xc.slice();
	
	            // Determine which is the bigger number.
	            if ( a = xe - ye ) {
	
	                if ( xLTy = a < 0 ) {
	                    a = -a;
	                    t = xc;
	                } else {
	                    ye = xe;
	                    t = yc;
	                }
	
	                t.reverse();
	
	                // Prepend zeros to equalise exponents.
	                for ( b = a; b--; t.push(0) );
	                t.reverse();
	            } else {
	
	                // Exponents equal. Check digit by digit.
	                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;
	
	                for ( a = b = 0; b < j; b++ ) {
	
	                    if ( xc[b] != yc[b] ) {
	                        xLTy = xc[b] < yc[b];
	                        break;
	                    }
	                }
	            }
	
	            // x < y? Point xc to the array of the bigger number.
	            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;
	
	            b = ( j = yc.length ) - ( i = xc.length );
	
	            // Append zeros to xc if shorter.
	            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
	            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
	            b = BASE - 1;
	
	            // Subtract yc from xc.
	            for ( ; j > a; ) {
	
	                if ( xc[--j] < yc[j] ) {
	                    for ( i = j; i && !xc[--i]; xc[i] = b );
	                    --xc[i];
	                    xc[j] += BASE;
	                }
	
	                xc[j] -= yc[j];
	            }
	
	            // Remove leading zeros and adjust exponent accordingly.
	            for ( ; xc[0] == 0; xc.shift(), --ye );
	
	            // Zero?
	            if ( !xc[0] ) {
	
	                // Following IEEE 754 (2008) 6.3,
	                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
	                y.s = ROUNDING_MODE == 3 ? -1 : 1;
	                y.c = [ y.e = 0 ];
	                return y;
	            }
	
	            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
	            // for finite x and y.
	            return normalise( y, xc, ye );
	        };
	
	
	        /*
	         *   n % 0 =  N
	         *   n % N =  N
	         *   n % I =  n
	         *   0 % n =  0
	         *  -0 % n = -0
	         *   0 % 0 =  N
	         *   0 % N =  N
	         *   0 % I =  0
	         *   N % n =  N
	         *   N % 0 =  N
	         *   N % N =  N
	         *   N % I =  N
	         *   I % n =  N
	         *   I % 0 =  N
	         *   I % N =  N
	         *   I % I =  N
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
	         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
	         */
	        P.modulo = P.mod = function ( y, b ) {
	            var q, s,
	                x = this;
	
	            id = 11;
	            y = new BigNumber( y, b );
	
	            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
	            if ( !x.c || !y.s || y.c && !y.c[0] ) {
	                return new BigNumber(NaN);
	
	            // Return x if y is Infinity or x is zero.
	            } else if ( !y.c || x.c && !x.c[0] ) {
	                return new BigNumber(x);
	            }
	
	            if ( MODULO_MODE == 9 ) {
	
	                // Euclidian division: q = sign(y) * floor(x / abs(y))
	                // r = x - qy    where  0 <= r < abs(y)
	                s = y.s;
	                y.s = 1;
	                q = div( x, y, 0, 3 );
	                y.s = s;
	                q.s *= s;
	            } else {
	                q = div( x, y, 0, MODULO_MODE );
	            }
	
	            return x.minus( q.times(y) );
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber negated,
	         * i.e. multiplied by -1.
	         */
	        P.negated = P.neg = function () {
	            var x = new BigNumber(this);
	            x.s = -x.s || null;
	            return x;
	        };
	
	
	        /*
	         *  n + 0 = n
	         *  n + N = N
	         *  n + I = I
	         *  0 + n = n
	         *  0 + 0 = 0
	         *  0 + N = N
	         *  0 + I = I
	         *  N + n = N
	         *  N + 0 = N
	         *  N + N = N
	         *  N + I = N
	         *  I + n = I
	         *  I + 0 = I
	         *  I + N = N
	         *  I + I = I
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
	         * BigNumber(y, b).
	         */
	        P.plus = P.add = function ( y, b ) {
	            var t,
	                x = this,
	                a = x.s;
	
	            id = 12;
	            y = new BigNumber( y, b );
	            b = y.s;
	
	            // Either NaN?
	            if ( !a || !b ) return new BigNumber(NaN);
	
	            // Signs differ?
	             if ( a != b ) {
	                y.s = -b;
	                return x.minus(y);
	            }
	
	            var xe = x.e / LOG_BASE,
	                ye = y.e / LOG_BASE,
	                xc = x.c,
	                yc = y.c;
	
	            if ( !xe || !ye ) {
	
	                // Return ±Infinity if either ±Infinity.
	                if ( !xc || !yc ) return new BigNumber( a / 0 );
	
	                // Either zero?
	                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
	                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
	            }
	
	            xe = bitFloor(xe);
	            ye = bitFloor(ye);
	            xc = xc.slice();
	
	            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
	            if ( a = xe - ye ) {
	                if ( a > 0 ) {
	                    ye = xe;
	                    t = yc;
	                } else {
	                    a = -a;
	                    t = xc;
	                }
	
	                t.reverse();
	                for ( ; a--; t.push(0) );
	                t.reverse();
	            }
	
	            a = xc.length;
	            b = yc.length;
	
	            // Point xc to the longer array, and b to the shorter length.
	            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;
	
	            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
	            for ( a = 0; b; ) {
	                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
	                xc[b] %= BASE;
	            }
	
	            if (a) {
	                xc.unshift(a);
	                ++ye;
	            }
	
	            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
	            // ye = MAX_EXP + 1 possible
	            return normalise( y, xc, ye );
	        };
	
	
	        /*
	         * Return the number of significant digits of the value of this BigNumber.
	         *
	         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
	         */
	        P.precision = P.sd = function (z) {
	            var n, v,
	                x = this,
	                c = x.c;
	
	            // 'precision() argument not a boolean or binary digit: {z}'
	            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
	                if (ERRORS) raise( 13, 'argument' + notBool, z );
	                if ( z != !!z ) z = null;
	            }
	
	            if ( !c ) return null;
	            v = c.length - 1;
	            n = v * LOG_BASE + 1;
	
	            if ( v = c[v] ) {
	
	                // Subtract the number of trailing zeros of the last element.
	                for ( ; v % 10 == 0; v /= 10, n-- );
	
	                // Add the number of digits of the first element.
	                for ( v = c[0]; v >= 10; v /= 10, n++ );
	            }
	
	            if ( z && x.e + 1 > n ) n = x.e + 1;
	
	            return n;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
	         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
	         * omitted.
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'round() decimal places out of range: {dp}'
	         * 'round() decimal places not an integer: {dp}'
	         * 'round() rounding mode not an integer: {rm}'
	         * 'round() rounding mode out of range: {rm}'
	         */
	        P.round = function ( dp, rm ) {
	            var n = new BigNumber(this);
	
	            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
	                round( n, ~~dp + this.e + 1, rm == null ||
	                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
	            }
	
	            return n;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
	         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
	         *
	         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
	         *
	         * If k is out of range and ERRORS is false, the result will be ±0 if k < 0, or ±Infinity
	         * otherwise.
	         *
	         * 'shift() argument not an integer: {k}'
	         * 'shift() argument out of range: {k}'
	         */
	        P.shift = function (k) {
	            var n = this;
	            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )
	
	              // k < 1e+21, or truncate(k) will produce exponential notation.
	              ? n.times( '1e' + truncate(k) )
	              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
	                ? n.s * ( k < 0 ? 0 : 1 / 0 )
	                : n );
	        };
	
	
	        /*
	         *  sqrt(-n) =  N
	         *  sqrt( N) =  N
	         *  sqrt(-I) =  N
	         *  sqrt( I) =  I
	         *  sqrt( 0) =  0
	         *  sqrt(-0) = -0
	         *
	         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
	         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
	         */
	        P.squareRoot = P.sqrt = function () {
	            var m, n, r, rep, t,
	                x = this,
	                c = x.c,
	                s = x.s,
	                e = x.e,
	                dp = DECIMAL_PLACES + 4,
	                half = new BigNumber('0.5');
	
	            // Negative/NaN/Infinity/zero?
	            if ( s !== 1 || !c || !c[0] ) {
	                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
	            }
	
	            // Initial estimate.
	            s = Math.sqrt( +x );
	
	            // Math.sqrt underflow/overflow?
	            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
	            if ( s == 0 || s == 1 / 0 ) {
	                n = coeffToString(c);
	                if ( ( n.length + e ) % 2 == 0 ) n += '0';
	                s = Math.sqrt(n);
	                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );
	
	                if ( s == 1 / 0 ) {
	                    n = '1e' + e;
	                } else {
	                    n = s.toExponential();
	                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
	                }
	
	                r = new BigNumber(n);
	            } else {
	                r = new BigNumber( s + '' );
	            }
	
	            // Check for zero.
	            // r could be zero if MIN_EXP is changed after the this value was created.
	            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
	            // coeffToString to throw.
	            if ( r.c[0] ) {
	                e = r.e;
	                s = e + dp;
	                if ( s < 3 ) s = 0;
	
	                // Newton-Raphson iteration.
	                for ( ; ; ) {
	                    t = r;
	                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );
	
	                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
	                         coeffToString( r.c ) ).slice( 0, s ) ) {
	
	                        // The exponent of r may here be one less than the final result exponent,
	                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
	                        // are indexed correctly.
	                        if ( r.e < e ) --s;
	                        n = n.slice( s - 3, s + 1 );
	
	                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
	                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
	                        // iteration.
	                        if ( n == '9999' || !rep && n == '4999' ) {
	
	                            // On the first iteration only, check to see if rounding up gives the
	                            // exact result as the nines may infinitely repeat.
	                            if ( !rep ) {
	                                round( t, t.e + DECIMAL_PLACES + 2, 0 );
	
	                                if ( t.times(t).eq(x) ) {
	                                    r = t;
	                                    break;
	                                }
	                            }
	
	                            dp += 4;
	                            s += 4;
	                            rep = 1;
	                        } else {
	
	                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
	                            // result. If not, then there are further digits and m will be truthy.
	                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {
	
	                                // Truncate to the first rounding digit.
	                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
	                                m = !r.times(r).eq(x);
	                            }
	
	                            break;
	                        }
	                    }
	                }
	            }
	
	            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
	        };
	
	
	        /*
	         *  n * 0 = 0
	         *  n * N = N
	         *  n * I = I
	         *  0 * n = 0
	         *  0 * 0 = 0
	         *  0 * N = N
	         *  0 * I = N
	         *  N * n = N
	         *  N * 0 = N
	         *  N * N = N
	         *  N * I = N
	         *  I * n = I
	         *  I * 0 = N
	         *  I * N = N
	         *  I * I = I
	         *
	         * Return a new BigNumber whose value is the value of this BigNumber times the value of
	         * BigNumber(y, b).
	         */
	        P.times = P.mul = function ( y, b ) {
	            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
	                base, sqrtBase,
	                x = this,
	                xc = x.c,
	                yc = ( id = 17, y = new BigNumber( y, b ) ).c;
	
	            // Either NaN, ±Infinity or ±0?
	            if ( !xc || !yc || !xc[0] || !yc[0] ) {
	
	                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
	                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
	                    y.c = y.e = y.s = null;
	                } else {
	                    y.s *= x.s;
	
	                    // Return ±Infinity if either is ±Infinity.
	                    if ( !xc || !yc ) {
	                        y.c = y.e = null;
	
	                    // Return ±0 if either is ±0.
	                    } else {
	                        y.c = [0];
	                        y.e = 0;
	                    }
	                }
	
	                return y;
	            }
	
	            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
	            y.s *= x.s;
	            xcL = xc.length;
	            ycL = yc.length;
	
	            // Ensure xc points to longer array and xcL to its length.
	            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
	
	            // Initialise the result array with zeros.
	            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );
	
	            base = BASE;
	            sqrtBase = SQRT_BASE;
	
	            for ( i = ycL; --i >= 0; ) {
	                c = 0;
	                ylo = yc[i] % sqrtBase;
	                yhi = yc[i] / sqrtBase | 0;
	
	                for ( k = xcL, j = i + k; j > i; ) {
	                    xlo = xc[--k] % sqrtBase;
	                    xhi = xc[k] / sqrtBase | 0;
	                    m = yhi * xlo + xhi * ylo;
	                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
	                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
	                    zc[j--] = xlo % base;
	                }
	
	                zc[j] = c;
	            }
	
	            if (c) {
	                ++e;
	            } else {
	                zc.shift();
	            }
	
	            return normalise( y, zc, e );
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
	         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
	         *
	         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toDigits() precision out of range: {sd}'
	         * 'toDigits() precision not an integer: {sd}'
	         * 'toDigits() rounding mode not an integer: {rm}'
	         * 'toDigits() rounding mode out of range: {rm}'
	         */
	        P.toDigits = function ( sd, rm ) {
	            var n = new BigNumber(this);
	            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
	            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
	            return sd ? round( n, sd, rm ) : n;
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in exponential notation and
	         * rounded using ROUNDING_MODE to dp fixed decimal places.
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toExponential() decimal places not an integer: {dp}'
	         * 'toExponential() decimal places out of range: {dp}'
	         * 'toExponential() rounding mode not an integer: {rm}'
	         * 'toExponential() rounding mode out of range: {rm}'
	         */
	        P.toExponential = function ( dp, rm ) {
	            return format( this,
	              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in fixed-point notation rounding
	         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
	         *
	         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
	         * but e.g. (-0.00001).toFixed(0) is '-0'.
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toFixed() decimal places not an integer: {dp}'
	         * 'toFixed() decimal places out of range: {dp}'
	         * 'toFixed() rounding mode not an integer: {rm}'
	         * 'toFixed() rounding mode out of range: {rm}'
	         */
	        P.toFixed = function ( dp, rm ) {
	            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
	              ? ~~dp + this.e + 1 : null, rm, 20 );
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in fixed-point notation rounded
	         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
	         * of the FORMAT object (see BigNumber.config).
	         *
	         * FORMAT = {
	         *      decimalSeparator : '.',
	         *      groupSeparator : ',',
	         *      groupSize : 3,
	         *      secondaryGroupSize : 0,
	         *      fractionGroupSeparator : '\xA0',    // non-breaking space
	         *      fractionGroupSize : 0
	         * };
	         *
	         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toFormat() decimal places not an integer: {dp}'
	         * 'toFormat() decimal places out of range: {dp}'
	         * 'toFormat() rounding mode not an integer: {rm}'
	         * 'toFormat() rounding mode out of range: {rm}'
	         */
	        P.toFormat = function ( dp, rm ) {
	            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
	              ? ~~dp + this.e + 1 : null, rm, 21 );
	
	            if ( this.c ) {
	                var i,
	                    arr = str.split('.'),
	                    g1 = +FORMAT.groupSize,
	                    g2 = +FORMAT.secondaryGroupSize,
	                    groupSeparator = FORMAT.groupSeparator,
	                    intPart = arr[0],
	                    fractionPart = arr[1],
	                    isNeg = this.s < 0,
	                    intDigits = isNeg ? intPart.slice(1) : intPart,
	                    len = intDigits.length;
	
	                if (g2) i = g1, g1 = g2, g2 = i, len -= i;
	
	                if ( g1 > 0 && len > 0 ) {
	                    i = len % g1 || g1;
	                    intPart = intDigits.substr( 0, i );
	
	                    for ( ; i < len; i += g1 ) {
	                        intPart += groupSeparator + intDigits.substr( i, g1 );
	                    }
	
	                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
	                    if (isNeg) intPart = '-' + intPart;
	                }
	
	                str = fractionPart
	                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
	                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
	                      '$&' + FORMAT.fractionGroupSeparator )
	                    : fractionPart )
	                  : intPart;
	            }
	
	            return str;
	        };
	
	
	        /*
	         * Return a string array representing the value of this BigNumber as a simple fraction with
	         * an integer numerator and an integer denominator. The denominator will be a positive
	         * non-zero value less than or equal to the specified maximum denominator. If a maximum
	         * denominator is not specified, the denominator will be the lowest value necessary to
	         * represent the number exactly.
	         *
	         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
	         *
	         * 'toFraction() max denominator not an integer: {md}'
	         * 'toFraction() max denominator out of range: {md}'
	         */
	        P.toFraction = function (md) {
	            var arr, d0, d2, e, exp, n, n0, q, s,
	                k = ERRORS,
	                x = this,
	                xc = x.c,
	                d = new BigNumber(ONE),
	                n1 = d0 = new BigNumber(ONE),
	                d1 = n0 = new BigNumber(ONE);
	
	            if ( md != null ) {
	                ERRORS = false;
	                n = new BigNumber(md);
	                ERRORS = k;
	
	                if ( !( k = n.isInt() ) || n.lt(ONE) ) {
	
	                    if (ERRORS) {
	                        raise( 22,
	                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
	                    }
	
	                    // ERRORS is false:
	                    // If md is a finite non-integer >= 1, round it to an integer and use it.
	                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
	                }
	            }
	
	            if ( !xc ) return x.toString();
	            s = coeffToString(xc);
	
	            // Determine initial denominator.
	            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
	            e = d.e = s.length - x.e - 1;
	            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
	            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;
	
	            exp = MAX_EXP;
	            MAX_EXP = 1 / 0;
	            n = new BigNumber(s);
	
	            // n0 = d1 = 0
	            n0.c[0] = 0;
	
	            for ( ; ; )  {
	                q = div( n, d, 0, 1 );
	                d2 = d0.plus( q.times(d1) );
	                if ( d2.cmp(md) == 1 ) break;
	                d0 = d1;
	                d1 = d2;
	                n1 = n0.plus( q.times( d2 = n1 ) );
	                n0 = d2;
	                d = n.minus( q.times( d2 = d ) );
	                n = d2;
	            }
	
	            d2 = div( md.minus(d0), d1, 0, 1 );
	            n0 = n0.plus( d2.times(n1) );
	            d0 = d0.plus( d2.times(d1) );
	            n0.s = n1.s = x.s;
	            e *= 2;
	
	            // Determine which fraction is closer to x, n0/d0 or n1/d1
	            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
	                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
	                    ? [ n1.toString(), d1.toString() ]
	                    : [ n0.toString(), d0.toString() ];
	
	            MAX_EXP = exp;
	            return arr;
	        };
	
	
	        /*
	         * Return the value of this BigNumber converted to a number primitive.
	         */
	        P.toNumber = function () {
	            return +this;
	        };
	
	
	        /*
	         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
	         * If m is present, return the result modulo m.
	         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
	         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using
	         * ROUNDING_MODE.
	         *
	         * The modular power operation works efficiently when x, n, and m are positive integers,
	         * otherwise it is equivalent to calculating x.toPower(n).modulo(m) (with POW_PRECISION 0).
	         *
	         * n {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
	         * [m] {number|string|BigNumber} The modulus.
	         *
	         * 'pow() exponent not an integer: {n}'
	         * 'pow() exponent out of range: {n}'
	         *
	         * Performs 54 loop iterations for n of 9007199254740991.
	         */
	        P.toPower = P.pow = function ( n, m ) {
	            var k, y, z,
	                i = mathfloor( n < 0 ? -n : +n ),
	                x = this;
	
	            if ( m != null ) {
	                id = 23;
	                m = new BigNumber(m);
	            }
	
	            // Pass ±Infinity to Math.pow if exponent is out of range.
	            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
	              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
	                parseFloat(n) != n && !( n = NaN ) ) || n == 0 ) {
	                k = Math.pow( +x, n );
	                return new BigNumber( m ? k % m : k );
	            }
	
	            if (m) {
	                if ( n > 1 && x.gt(ONE) && x.isInt() && m.gt(ONE) && m.isInt() ) {
	                    x = x.mod(m);
	                } else {
	                    z = m;
	
	                    // Nullify m so only a single mod operation is performed at the end.
	                    m = null;
	                }
	            } else if (POW_PRECISION) {
	
	                // Truncating each coefficient array to a length of k after each multiplication
	                // equates to truncating significant digits to POW_PRECISION + [28, 41],
	                // i.e. there will be a minimum of 28 guard digits retained.
	                // (Using + 1.5 would give [9, 21] guard digits.)
	                k = mathceil( POW_PRECISION / LOG_BASE + 2 );
	            }
	
	            y = new BigNumber(ONE);
	
	            for ( ; ; ) {
	                if ( i % 2 ) {
	                    y = y.times(x);
	                    if ( !y.c ) break;
	                    if (k) {
	                        if ( y.c.length > k ) y.c.length = k;
	                    } else if (m) {
	                        y = y.mod(m);
	                    }
	                }
	
	                i = mathfloor( i / 2 );
	                if ( !i ) break;
	                x = x.times(x);
	                if (k) {
	                    if ( x.c && x.c.length > k ) x.c.length = k;
	                } else if (m) {
	                    x = x.mod(m);
	                }
	            }
	
	            if (m) return y;
	            if ( n < 0 ) y = ONE.div(y);
	
	            return z ? y.mod(z) : k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber rounded to sd significant digits
	         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
	         * necessary to represent the integer part of the value in fixed-point notation, then use
	         * exponential notation.
	         *
	         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
	         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
	         *
	         * 'toPrecision() precision not an integer: {sd}'
	         * 'toPrecision() precision out of range: {sd}'
	         * 'toPrecision() rounding mode not an integer: {rm}'
	         * 'toPrecision() rounding mode out of range: {rm}'
	         */
	        P.toPrecision = function ( sd, rm ) {
	            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
	              ? sd | 0 : null, rm, 24 );
	        };
	
	
	        /*
	         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
	         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
	         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
	         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
	         * TO_EXP_NEG, return exponential notation.
	         *
	         * [b] {number} Integer, 2 to 64 inclusive.
	         *
	         * 'toString() base not an integer: {b}'
	         * 'toString() base out of range: {b}'
	         */
	        P.toString = function (b) {
	            var str,
	                n = this,
	                s = n.s,
	                e = n.e;
	
	            // Infinity or NaN?
	            if ( e === null ) {
	
	                if (s) {
	                    str = 'Infinity';
	                    if ( s < 0 ) str = '-' + str;
	                } else {
	                    str = 'NaN';
	                }
	            } else {
	                str = coeffToString( n.c );
	
	                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
	                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
	                      ? toExponential( str, e )
	                      : toFixedPoint( str, e );
	                } else {
	                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
	                }
	
	                if ( s < 0 && n.c[0] ) str = '-' + str;
	            }
	
	            return str;
	        };
	
	
	        /*
	         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
	         * number.
	         */
	        P.truncated = P.trunc = function () {
	            return round( new BigNumber(this), this.e + 1, 1 );
	        };
	
	
	
	        /*
	         * Return as toString, but do not accept a base argument, and include the minus sign for
	         * negative zero.
	         */
	        P.valueOf = P.toJSON = function () {
	            var str,
	                n = this,
	                e = n.e;
	
	            if ( e === null ) return n.toString();
	
	            str = coeffToString( n.c );
	
	            str = e <= TO_EXP_NEG || e >= TO_EXP_POS
	                ? toExponential( str, e )
	                : toFixedPoint( str, e );
	
	            return n.s < 0 ? '-' + str : str;
	        };
	
	
	        // Aliases for BigDecimal methods.
	        //P.add = P.plus;         // P.add included above
	        //P.subtract = P.minus;   // P.sub included above
	        //P.multiply = P.times;   // P.mul included above
	        //P.divide = P.div;
	        //P.remainder = P.mod;
	        //P.compareTo = P.cmp;
	        //P.negate = P.neg;
	
	
	        if ( configObj != null ) BigNumber.config(configObj);
	
	        return BigNumber;
	    }
	
	
	    // PRIVATE HELPER FUNCTIONS
	
	
	    function bitFloor(n) {
	        var i = n | 0;
	        return n > 0 || n === i ? i : i - 1;
	    }
	
	
	    // Return a coefficient array as a string of base 10 digits.
	    function coeffToString(a) {
	        var s, z,
	            i = 1,
	            j = a.length,
	            r = a[0] + '';
	
	        for ( ; i < j; ) {
	            s = a[i++] + '';
	            z = LOG_BASE - s.length;
	            for ( ; z--; s = '0' + s );
	            r += s;
	        }
	
	        // Determine trailing zeros.
	        for ( j = r.length; r.charCodeAt(--j) === 48; );
	        return r.slice( 0, j + 1 || 1 );
	    }
	
	
	    // Compare the value of BigNumbers x and y.
	    function compare( x, y ) {
	        var a, b,
	            xc = x.c,
	            yc = y.c,
	            i = x.s,
	            j = y.s,
	            k = x.e,
	            l = y.e;
	
	        // Either NaN?
	        if ( !i || !j ) return null;
	
	        a = xc && !xc[0];
	        b = yc && !yc[0];
	
	        // Either zero?
	        if ( a || b ) return a ? b ? 0 : -j : i;
	
	        // Signs differ?
	        if ( i != j ) return i;
	
	        a = i < 0;
	        b = k == l;
	
	        // Either Infinity?
	        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;
	
	        // Compare exponents.
	        if ( !b ) return k > l ^ a ? 1 : -1;
	
	        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;
	
	        // Compare digit by digit.
	        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;
	
	        // Compare lengths.
	        return k == l ? 0 : k > l ^ a ? 1 : -1;
	    }
	
	
	    /*
	     * Return true if n is a valid number in range, otherwise false.
	     * Use for argument validation when ERRORS is false.
	     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
	     */
	    function intValidatorNoErrors( n, min, max ) {
	        return ( n = truncate(n) ) >= min && n <= max;
	    }
	
	
	    function isArray(obj) {
	        return Object.prototype.toString.call(obj) == '[object Array]';
	    }
	
	
	    /*
	     * Convert string of baseIn to an array of numbers of baseOut.
	     * Eg. convertBase('255', 10, 16) returns [15, 15].
	     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
	     */
	    function toBaseOut( str, baseIn, baseOut ) {
	        var j,
	            arr = [0],
	            arrL,
	            i = 0,
	            len = str.length;
	
	        for ( ; i < len; ) {
	            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
	            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );
	
	            for ( ; j < arr.length; j++ ) {
	
	                if ( arr[j] > baseOut - 1 ) {
	                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
	                    arr[j + 1] += arr[j] / baseOut | 0;
	                    arr[j] %= baseOut;
	                }
	            }
	        }
	
	        return arr.reverse();
	    }
	
	
	    function toExponential( str, e ) {
	        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
	          ( e < 0 ? 'e' : 'e+' ) + e;
	    }
	
	
	    function toFixedPoint( str, e ) {
	        var len, z;
	
	        // Negative exponent?
	        if ( e < 0 ) {
	
	            // Prepend zeros.
	            for ( z = '0.'; ++e; z += '0' );
	            str = z + str;
	
	        // Positive exponent
	        } else {
	            len = str.length;
	
	            // Append zeros.
	            if ( ++e > len ) {
	                for ( z = '0', e -= len; --e; z += '0' );
	                str += z;
	            } else if ( e < len ) {
	                str = str.slice( 0, e ) + '.' + str.slice(e);
	            }
	        }
	
	        return str;
	    }
	
	
	    function truncate(n) {
	        n = parseFloat(n);
	        return n < 0 ? mathceil(n) : mathfloor(n);
	    }
	
	
	    // EXPORT
	
	
	   // AMD.
	    if ( true ) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () { return constructorFactory(); }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	    // Node.js and other environments that support module.exports.
	    } else if ( typeof module != 'undefined' && module.exports ) {
	        module.exports = constructorFactory();
	
	        // Split string stops browserify adding crypto shim.
	        if ( !cryptoObj ) try { cryptoObj = require('cry' + 'pto'); } catch (e) {}
	
	    // Browser.
	    } else {
	        if ( !globalObj ) globalObj = typeof self != 'undefined' ? self : Function('return this')();
	        globalObj.BigNumber = constructorFactory();
	    }
	})(this);


/***/ },
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 532 */
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ function(module, exports) {

	module.exports = require("child_process");

/***/ },
/* 533 */
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("http");

/***/ },
/* 534 */
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ function(module, exports) {

	module.exports = require("querystring");

/***/ },
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ function(module, exports) {

	module.exports = require("electron");

/***/ },
/* 581 */,
/* 582 */
/*!*****************************!*\
  !*** ./js/mainjs/config.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = configManager;
	
	var _fs = __webpack_require__(/*! fs */ 531);
	
	var _fs2 = _interopRequireDefault(_fs);
	
	var _path = __webpack_require__(/*! path */ 521);
	
	var _path2 = _interopRequireDefault(_path);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// The default settings
	var defaultConfig = {
		homePlugin: 'Overview',
		siad: {
			path: _path2.default.join(__dirname, '../Sia/siad'),
			datadir: _path2.default.join(__dirname, '../Sia'),
			detached: false
		},
		closeToTray: process.platform === 'win32' || process.platform === 'darwin' ? true : false,
		width: 800,
		height: 600,
		x: 0,
		y: 0
	};
	
	/**
	 * Holds all config.json related logic
	 * @module configManager
	 */
	function configManager(filepath) {
		var config = void 0;
	
		try {
			// TODO: write load() function instead of global require
			var data = _fs2.default.readFileSync(filepath);
			config = JSON.parse(data);
		} catch (err) {
			config = defaultConfig;
		}
	
		/**
	  * Gets or sets a config attribute
	  * @param {object} key - key to get or set
	  * @param {object} value - value to set config[key] as
	  */
		config.attr = function (key, value) {
			if (value !== undefined) {
				config[key] = value;
			}
			if (config[key] === undefined) {
				config[key] = null;
			}
			return config[key];
		};
	
		/**
	  * Writes the current config to defaultConfigPath
	  * @param {string} path - UI's defaultConfigPath
	  */
		config.save = function () {
			_fs2.default.writeFileSync(filepath, JSON.stringify(config, null, '\t'));
		};
	
		/**
	  * Sets config to what it was on disk
	  */
		config.reset = function () {
			config = configManager(filepath);
		};
	
		// Save to disk immediately when loaded
		config.save();
		// Return the config object with the above 3 member functions
		return config;
	}

/***/ },
/* 583 */,
/* 584 */,
/* 585 */
/*!****************************!*\
  !*** ./~/sia.js/js/sia.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	// Library for making requests
	const request = __webpack_require__(/*! request */ 586)
	const BigNumber = __webpack_require__(/*! bignumber.js */ 507)
	
	// Necessary node libraries to make sia.js emit events
	const Util = __webpack_require__(/*! util */ 597)
	const EventEmitter = __webpack_require__(/*! events */ 614)
	const nodePath = __webpack_require__(/*! path */ 521)
	
	/**
	 * SiadWrapper, a closure, initializes siad as a background process and
	 * provides functions to interact with it
	 * @class SiadWrapper
	 */
	function SiadWrapper () {
	  // siad details with default values
	  var settings = {
	    detached: false,
	    address: 'localhost:9980',
	    rpcAddress: ':9981',
	    hostAddress: ':9982',
	    datadir: nodePath.join(__dirname, '..', 'Sia'),
	    path: nodePath.join(__dirname, '..', 'Sia', process.platform === 'win32' ? 'siad.exe' : 'siad')
	  }
	  // Ensure precision for unit conversions
	  BigNumber.config({ DECIMAL_PLACES: 30 })
	  BigNumber.config({ EXPONENTIAL_AT: 1e+9 })
	  // Unit conversion constants
	  const hastingsPerSiacoin = new BigNumber(10).pow(24)
	
	  // Tracks if siad was last known to be running or not
	  var running = false
	  // Keep reference to `this` to emit events from within contexts where `this`
	  // does not point to this class
	  var self = this
	  // Inherit `EventEmitter` properties
	  EventEmitter.call(this)
	
	  /**
	   * Relays calls to daemonAPI with the localhost:port address appended
	   * @function SiadWrapper#call
	   * @param {apiCall} call - function to run if Siad is running
	   * @param {apiResponse} callback
	   * @returns {object} request call object
	   */
	  function apiCall (call, callback) {
	    // Interpret string-only calls. Will default to 'GET' requests
	    if (typeof call === 'string') {
	      call = { url: call }
	    }
	
	    // Setup request
	    call.url = 'http://' + settings.address + call.url
	    call.json = true
	    call.headers = {
	      'User-Agent': 'Sia-Agent'
	    }
	
	    // Return the request sent if the user wants to be creative and get more
	    // information than what's passed to the callback
	    // TODO: Don't understand why the setImmediate is needed, but without it,
	    // some calls seem to not return right after another call but eventually do
	    // return once another call is made. Some sort of resource blocking is
	    // happening
	    setImmediate(function () {
	      request(call, function (err, response, body) {
	        // The error from request should be null if siad is running
	        running = !err
	
	        // If siad puts out an error, pass it as first argument to callback
	        if (!err && response.statusCode !== 200) {
	          err = body
	          body = null
	        }
	
	        // Return results to callback
	        if (callback !== undefined) {
	          callback(err, body)
	        }
	      })
	    })
	  }
	
	  // Checks whether siad is running on the current address
	  function checkIfSiadRunning (callback) {
	    return apiCall('/daemon/version', function (err) {
	      // There should be no reason this call would error if siad were running
	      // and serving requests
	      running = !err
	
	      // Return result to callback
	      if (callback !== undefined) {
	        callback(running)
	      }
	    })
	  }
	
	  /**
	   * Checks whether siad is running and runs ones of two callbacks
	   * @function SiadWrapper#ifRunning
	   * @param {callback} is - called if siad is running
	   * @param {callback} not - called if siad is not running
	   * @returns {object} request call object
	   */
	  function ifSiadRunning (is, not) {
	    return checkIfSiadRunning(function (running) {
	      if (running && is !== undefined) {
	        is()
	      } else if (not !== undefined) {
	        not()
	      }
	    })
	  }
	
	  /**
	   * Synchronous way to check if siad is running, may not be up to date
	   * @function SiadWrapper#isRunning
	   * @returns {boolean} whether siad is running
	   */
	  function isSiadRunning (callback) {
	    return running
	  }
	
	  // Polls the siad API until it comes online
	  function waitUntilLoaded (callback) {
	    return ifSiadRunning(callback, function () {
	      setTimeout(function () {
	        waitUntilLoaded(callback)
	      }, 1000)
	    })
	  }
	
	  /**
	   * Starts the daemon as a long running background process
	   * @param {callback} callback - function to be run if successful
	   * @returns {boolean} if start was attempted
	   */
	  function start (callback) {
	    // Check if siad is already running
	    if (running) {
	      if (callback !== null) {
	        callback(new Error('Attempted to start siad when it was already running'))
	      }
	      return false
	    }
	
	    // Check synchronously if siad doesn't exist at settings.path
	    const fs = __webpack_require__(/*! fs */ 531)
	    try {
	      __webpack_require__(/*! fs */ 531).statSync(settings.path)
	    } catch (e) {
	      if (callback !== null) {
	        callback(e)
	      }
	      return false
	    }
	
	    // Set siad folder as configured settings.datadir
	    var processOptions = {
	      cwd: settings.datadir
	    }
	
	    // If the detached option is set, spawn siad as a separate process to be
	    // run in the background after the parent process has closed
	    if (settings.detached) {
	      let log = nodePath.join(settings.datadir, 'out.log')
	      let out = fs.openSync(log, 'a')
	      let err = fs.openSync(log, 'a')
	      processOptions.detached = true
	      processOptions.stdio = [ 'ignore', out, err ]
	    }
	
	    // Spawn siad
	    const Process = __webpack_require__(/*! child_process */ 532).spawn
	    var daemonProcess = new Process(settings.path, [
	      '--api-addr=' + settings.address,
	      '--rpc-addr=' + settings.rpcAddress,
	      '--host-addr=' + settings.hostAddress,
	      '--sia-directory=' + settings.datadir
	    ], processOptions)
	
	    // Exclude it from the parent process' event loop if detached
	    if (settings.detached) {
	      daemonProcess.unref()
	    } else {
	      // Listen for siad events and emit them from wrapper
	      // TODO: Attach these to siad if it's already running
	      var childProcessEvents = ['close', 'disconnect', 'error', 'message']
	      childProcessEvents.forEach(function (ev) {
	        daemonProcess.on(ev, function (arg1, arg2) {
	          self.emit(ev, arg1, arg2)
	        })
	      })
	      daemonProcess.on('exit', function (code) {
	        running = false
	        self.emit('exit', code)
	      })
	    }
	
	    // Wait until siad finishes loading to call callback
	    waitUntilLoaded(callback)
	    return true
	  }
	
	  /**
	   * Sends a stop call to the daemon
	   * @param {callback} callback - function to be run if successful
	   * @returns {boolean} if stop was attempted, should always be true
	   */
	  function stop (callback) {
	    apiCall('/daemon/stop', function (err) {
	      if (!err) {
	        running = false
	      }
	      if (callback !== undefined) {
	        callback(err)
	      }
	    })
	    return true
	  }
	
	  /**
	   * Sets the member variables based on the passed config. Checks if siad is
	   * running on the new configuration so running should be up to date for
	   * the callback
	   * @param {config} c - the config object derived from config.json
	   * @param {callback} callback - first argument is any errors, second argument
	   * is the new configuration
	   * @returns {object} siad configuration object
	   */
	  function configure (newSettings, callback) {
	    for (let key in settings) {
	      // Set passed in settings within siad
	      if (settings.hasOwnProperty(key) && newSettings.hasOwnProperty(key)) {
	        settings[key] = newSettings[key]
	      } else if (settings.hasOwnProperty(key)) {
	        // Set settings to sync with siad
	        newSettings[key] = settings[key]
	      }
	    }
	    if (callback !== undefined) {
	      checkIfSiadRunning(function (check) {
	        callback(null, settings)
	      })
	    }
	    return settings
	  }
	
	  /**
	   * Downloads siad and siac to a specified or default location
	   * @param {string} path - An optional location of where to download to
	   * @param {callback} callback
	   * @returns {boolean} if download was started, should always be true
	   */
	  function download (path, callback) {
	    if (typeof path === 'string') {
	      settings.path = path
	    } else {
	      // the first argument is either undefined or the callback
	      callback = path
	      path = settings.path
	    }
	    return __webpack_require__(/*! ./download.js */ 743)(path, callback)
	  }
	
	  // Sia unit conversion functions.
	  // Convert Hastings (the base unit) to Siacoin.  Use strings as input to avoid precision loss.
	  // @param {hastings :string}
	  // @return BigNumber
	  function hastingsToSiacoins (hastings) {
	    const hastingsNumber = new BigNumber(hastings)
	    return hastingsNumber.dividedBy(hastingsPerSiacoin)
	  }
	  // Convert Siacoin to Hastings.  Use strings as input to avoid precision loss.
	  // @params {siacoin :string}
	  // @return BigNumber
	  function siacoinsToHastings (siacoins) {
	    const siacoinNumber = new BigNumber(siacoins)
	    return siacoinNumber.times(hastingsPerSiacoin)
	  }
	
	  // Make certain members public
	  this.call = apiCall
	  this.ifRunning = ifSiadRunning
	  this.isRunning = isSiadRunning
	  this.start = start
	  this.stop = stop
	  this.configure = configure
	  this.download = download
	  this.siacoinsToHastings = siacoinsToHastings
	  this.hastingsToSiacoins = hastingsToSiacoins
	}
	
	// Inherit functions from `EventEmitter`'s prototype
	Util.inherits(SiadWrapper, EventEmitter)
	
	module.exports = new SiadWrapper()


/***/ },
/* 586 */
/*!****************************!*\
  !*** ./~/request/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2010-2012 Mikeal Rogers
	//
	//    Licensed under the Apache License, Version 2.0 (the "License");
	//    you may not use this file except in compliance with the License.
	//    You may obtain a copy of the License at
	//
	//        http://www.apache.org/licenses/LICENSE-2.0
	//
	//    Unless required by applicable law or agreed to in writing, software
	//    distributed under the License is distributed on an "AS IS" BASIS,
	//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	//    See the License for the specific language governing permissions and
	//    limitations under the License.
	
	'use strict'
	
	var extend                = __webpack_require__(/*! extend */ 587)
	  , cookies               = __webpack_require__(/*! ./lib/cookies */ 588)
	  , helpers               = __webpack_require__(/*! ./lib/helpers */ 599)
	
	var isFunction            = helpers.isFunction
	  , paramsHaveRequestBody = helpers.paramsHaveRequestBody
	
	
	// organize params for patch, post, put, head, del
	function initParams(uri, options, callback) {
	  if (typeof options === 'function') {
	    callback = options
	  }
	
	  var params = {}
	  if (typeof options === 'object') {
	    extend(params, options, {uri: uri})
	  } else if (typeof uri === 'string') {
	    extend(params, {uri: uri})
	  } else {
	    extend(params, uri)
	  }
	
	  params.callback = callback || params.callback
	  return params
	}
	
	function request (uri, options, callback) {
	  if (typeof uri === 'undefined') {
	    throw new Error('undefined is not a valid uri or options object.')
	  }
	
	  var params = initParams(uri, options, callback)
	
	  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
	    throw new Error('HTTP HEAD requests MUST NOT include a request body.')
	  }
	
	  return new request.Request(params)
	}
	
	function verbFunc (verb) {
	  var method = verb.toUpperCase()
	  return function (uri, options, callback) {
	    var params = initParams(uri, options, callback)
	    params.method = method
	    return request(params, params.callback)
	  }
	}
	
	// define like this to please codeintel/intellisense IDEs
	request.get = verbFunc('get')
	request.head = verbFunc('head')
	request.post = verbFunc('post')
	request.put = verbFunc('put')
	request.patch = verbFunc('patch')
	request.del = verbFunc('delete')
	request['delete'] = verbFunc('delete')
	
	request.jar = function (store) {
	  return cookies.jar(store)
	}
	
	request.cookie = function (str) {
	  return cookies.parse(str)
	}
	
	function wrapRequestMethod (method, options, requester, verb) {
	
	  return function (uri, opts, callback) {
	    var params = initParams(uri, opts, callback)
	
	    var target = {}
	    extend(true, target, options, params)
	
	    target.pool = params.pool || options.pool
	
	    if (verb) {
	      target.method = verb.toUpperCase()
	    }
	
	    if (isFunction(requester)) {
	      method = requester
	    }
	
	    return method(target, target.callback)
	  }
	}
	
	request.defaults = function (options, requester) {
	  var self = this
	
	  options = options || {}
	
	  if (typeof options === 'function') {
	    requester = options
	    options = {}
	  }
	
	  var defaults      = wrapRequestMethod(self, options, requester)
	
	  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete']
	  verbs.forEach(function(verb) {
	    defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)
	  })
	
	  defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)
	  defaults.jar      = self.jar
	  defaults.defaults = self.defaults
	  return defaults
	}
	
	request.forever = function (agentOptions, optionsArg) {
	  var options = {}
	  if (optionsArg) {
	    extend(options, optionsArg)
	  }
	  if (agentOptions) {
	    options.agentOptions = agentOptions
	  }
	
	  options.forever = true
	  return request.defaults(options)
	}
	
	// Exports
	
	module.exports = request
	request.Request = __webpack_require__(/*! ./request */ 602)
	request.initParams = initParams
	
	// Backwards compatibility for request.debug
	Object.defineProperty(request, 'debug', {
	  enumerable : true,
	  get : function() {
	    return request.Request.debug
	  },
	  set : function(debug) {
	    request.Request.debug = debug
	  }
	})


/***/ },
/* 587 */
/*!***************************!*\
  !*** ./~/extend/index.js ***!
  \***************************/
/***/ function(module, exports) {

	'use strict';
	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	
	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}
	
		return toStr.call(arr) === '[object Array]';
	};
	
	var isPlainObject = function isPlainObject(obj) {
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}
	
		var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
			return false;
		}
	
		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) {/**/}
	
		return typeof key === 'undefined' || hasOwn.call(obj, key);
	};
	
	module.exports = function extend() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0],
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
			target = {};
		}
	
		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];
	
					// Prevent never-ending loop
					if (target !== copy) {
						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && isArray(src) ? src : [];
							} else {
								clone = src && isPlainObject(src) ? src : {};
							}
	
							// Never move original objects, clone them
							target[name] = extend(deep, clone, copy);
	
						// Don't bring in undefined values
						} else if (typeof copy !== 'undefined') {
							target[name] = copy;
						}
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	


/***/ },
/* 588 */
/*!**********************************!*\
  !*** ./~/request/lib/cookies.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var tough = __webpack_require__(/*! tough-cookie */ 589)
	
	var Cookie = tough.Cookie
	  , CookieJar = tough.CookieJar
	
	
	exports.parse = function(str) {
	  if (str && str.uri) {
	    str = str.uri
	  }
	  if (typeof str !== 'string') {
	    throw new Error('The cookie function only accepts STRING as param')
	  }
	  return Cookie.parse(str, {loose: true})
	}
	
	// Adapt the sometimes-Async api of tough.CookieJar to our requirements
	function RequestJar(store) {
	  var self = this
	  self._jar = new CookieJar(store, {looseMode: true})
	}
	RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
	  var self = this
	  return self._jar.setCookieSync(cookieOrStr, uri, options || {})
	}
	RequestJar.prototype.getCookieString = function(uri) {
	  var self = this
	  return self._jar.getCookieStringSync(uri)
	}
	RequestJar.prototype.getCookies = function(uri) {
	  var self = this
	  return self._jar.getCookiesSync(uri)
	}
	
	exports.jar = function(store) {
	  return new RequestJar(store)
	}


/***/ },
/* 589 */
/*!**************************************!*\
  !*** ./~/tough-cookie/lib/cookie.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	'use strict';
	var net = __webpack_require__(/*! net */ 590);
	var urlParse = __webpack_require__(/*! url */ 534).parse;
	var pubsuffix = __webpack_require__(/*! ./pubsuffix */ 591);
	var Store = __webpack_require__(/*! ./store */ 593).Store;
	var MemoryCookieStore = __webpack_require__(/*! ./memstore */ 594).MemoryCookieStore;
	var pathMatch = __webpack_require__(/*! ./pathMatch */ 596).pathMatch;
	var VERSION = __webpack_require__(/*! ../package.json */ 598).version;
	
	var punycode;
	try {
	  punycode = __webpack_require__(/*! punycode */ 592);
	} catch(e) {
	  console.warn("cookie: can't load punycode; won't use punycode for domain normalization");
	}
	
	var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
	
	// From RFC6265 S4.1.1
	// note that it excludes \x3B ";"
	var COOKIE_OCTET  = /[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]/;
	var COOKIE_OCTETS = new RegExp('^'+COOKIE_OCTET.source+'+$');
	
	var CONTROL_CHARS = /[\x00-\x1F]/;
	
	// Double quotes are part of the value (see: S4.1.1).
	// '\r', '\n' and '\0' should be treated as a terminator in the "relaxed" mode
	// (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60)
	// '=' and ';' are attribute/values separators
	// (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L64)
	var COOKIE_PAIR = /^(([^=;]+))\s*=\s*([^\n\r\0]*)/;
	
	// Used to parse non-RFC-compliant cookies like '=abc' when given the `loose`
	// option in Cookie.parse:
	var LOOSE_COOKIE_PAIR = /^((?:=)?([^=;]*)\s*=\s*)?([^\n\r\0]*)/;
	
	// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
	// Note ';' is \x3B
	var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
	
	// Used for checking whether or not there is a trailing semi-colon
	var TRAILING_SEMICOLON = /;+$/;
	
	var DAY_OF_MONTH = /^(\d{1,2})[^\d]*$/;
	var TIME = /^(\d{1,2})[^\d]*:(\d{1,2})[^\d]*:(\d{1,2})[^\d]*$/;
	var MONTH = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;
	
	var MONTH_TO_NUM = {
	  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
	  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
	};
	var NUM_TO_MONTH = [
	  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
	];
	var NUM_TO_DAY = [
	  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
	];
	
	var YEAR = /^(\d{2}|\d{4})$/; // 2 to 4 digits
	
	var MAX_TIME = 2147483647000; // 31-bit max
	var MIN_TIME = 0; // 31-bit min
	
	
	// RFC6265 S5.1.1 date parser:
	function parseDate(str) {
	  if (!str) {
	    return;
	  }
	
	  /* RFC6265 S5.1.1:
	   * 2. Process each date-token sequentially in the order the date-tokens
	   * appear in the cookie-date
	   */
	  var tokens = str.split(DATE_DELIM);
	  if (!tokens) {
	    return;
	  }
	
	  var hour = null;
	  var minutes = null;
	  var seconds = null;
	  var day = null;
	  var month = null;
	  var year = null;
	
	  for (var i=0; i<tokens.length; i++) {
	    var token = tokens[i].trim();
	    if (!token.length) {
	      continue;
	    }
	
	    var result;
	
	    /* 2.1. If the found-time flag is not set and the token matches the time
	     * production, set the found-time flag and set the hour- value,
	     * minute-value, and second-value to the numbers denoted by the digits in
	     * the date-token, respectively.  Skip the remaining sub-steps and continue
	     * to the next date-token.
	     */
	    if (seconds === null) {
	      result = TIME.exec(token);
	      if (result) {
	        hour = parseInt(result[1], 10);
	        minutes = parseInt(result[2], 10);
	        seconds = parseInt(result[3], 10);
	        /* RFC6265 S5.1.1.5:
	         * [fail if]
	         * *  the hour-value is greater than 23,
	         * *  the minute-value is greater than 59, or
	         * *  the second-value is greater than 59.
	         */
	        if(hour > 23 || minutes > 59 || seconds > 59) {
	          return;
	        }
	
	        continue;
	      }
	    }
	
	    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
	     * the day-of-month production, set the found-day-of- month flag and set
	     * the day-of-month-value to the number denoted by the date-token.  Skip
	     * the remaining sub-steps and continue to the next date-token.
	     */
	    if (day === null) {
	      result = DAY_OF_MONTH.exec(token);
	      if (result) {
	        day = parseInt(result, 10);
	        /* RFC6265 S5.1.1.5:
	         * [fail if] the day-of-month-value is less than 1 or greater than 31
	         */
	        if(day < 1 || day > 31) {
	          return;
	        }
	        continue;
	      }
	    }
	
	    /* 2.3. If the found-month flag is not set and the date-token matches the
	     * month production, set the found-month flag and set the month-value to
	     * the month denoted by the date-token.  Skip the remaining sub-steps and
	     * continue to the next date-token.
	     */
	    if (month === null) {
	      result = MONTH.exec(token);
	      if (result) {
	        month = MONTH_TO_NUM[result[1].toLowerCase()];
	        continue;
	      }
	    }
	
	    /* 2.4. If the found-year flag is not set and the date-token matches the year
	     * production, set the found-year flag and set the year-value to the number
	     * denoted by the date-token.  Skip the remaining sub-steps and continue to
	     * the next date-token.
	     */
	    if (year === null) {
	      result = YEAR.exec(token);
	      if (result) {
	        year = parseInt(result[0], 10);
	        /* From S5.1.1:
	         * 3.  If the year-value is greater than or equal to 70 and less
	         * than or equal to 99, increment the year-value by 1900.
	         * 4.  If the year-value is greater than or equal to 0 and less
	         * than or equal to 69, increment the year-value by 2000.
	         */
	        if (70 <= year && year <= 99) {
	          year += 1900;
	        } else if (0 <= year && year <= 69) {
	          year += 2000;
	        }
	
	        if (year < 1601) {
	          return; // 5. ... the year-value is less than 1601
	        }
	      }
	    }
	  }
	
	  if (seconds === null || day === null || month === null || year === null) {
	    return; // 5. ... at least one of the found-day-of-month, found-month, found-
	            // year, or found-time flags is not set,
	  }
	
	  return new Date(Date.UTC(year, month, day, hour, minutes, seconds));
	}
	
	function formatDate(date) {
	  var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;
	  var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;
	  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;
	  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;
	  return NUM_TO_DAY[date.getUTCDay()] + ', ' +
	    d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+
	    h+':'+m+':'+s+' GMT';
	}
	
	// S5.1.2 Canonicalized Host Names
	function canonicalDomain(str) {
	  if (str == null) {
	    return null;
	  }
	  str = str.trim().replace(/^\./,''); // S4.1.2.3 & S5.2.3: ignore leading .
	
	  // convert to IDN if any non-ASCII characters
	  if (punycode && /[^\u0001-\u007f]/.test(str)) {
	    str = punycode.toASCII(str);
	  }
	
	  return str.toLowerCase();
	}
	
	// S5.1.3 Domain Matching
	function domainMatch(str, domStr, canonicalize) {
	  if (str == null || domStr == null) {
	    return null;
	  }
	  if (canonicalize !== false) {
	    str = canonicalDomain(str);
	    domStr = canonicalDomain(domStr);
	  }
	
	  /*
	   * "The domain string and the string are identical. (Note that both the
	   * domain string and the string will have been canonicalized to lower case at
	   * this point)"
	   */
	  if (str == domStr) {
	    return true;
	  }
	
	  /* "All of the following [three] conditions hold:" (order adjusted from the RFC) */
	
	  /* "* The string is a host name (i.e., not an IP address)." */
	  if (net.isIP(str)) {
	    return false;
	  }
	
	  /* "* The domain string is a suffix of the string" */
	  var idx = str.indexOf(domStr);
	  if (idx <= 0) {
	    return false; // it's a non-match (-1) or prefix (0)
	  }
	
	  // e.g "a.b.c".indexOf("b.c") === 2
	  // 5 === 3+2
	  if (str.length !== domStr.length + idx) { // it's not a suffix
	    return false;
	  }
	
	  /* "* The last character of the string that is not included in the domain
	  * string is a %x2E (".") character." */
	  if (str.substr(idx-1,1) !== '.') {
	    return false;
	  }
	
	  return true;
	}
	
	
	// RFC6265 S5.1.4 Paths and Path-Match
	
	/*
	 * "The user agent MUST use an algorithm equivalent to the following algorithm
	 * to compute the default-path of a cookie:"
	 *
	 * Assumption: the path (and not query part or absolute uri) is passed in.
	 */
	function defaultPath(path) {
	  // "2. If the uri-path is empty or if the first character of the uri-path is not
	  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
	  if (!path || path.substr(0,1) !== "/") {
	    return "/";
	  }
	
	  // "3. If the uri-path contains no more than one %x2F ("/") character, output
	  // %x2F ("/") and skip the remaining step."
	  if (path === "/") {
	    return path;
	  }
	
	  var rightSlash = path.lastIndexOf("/");
	  if (rightSlash === 0) {
	    return "/";
	  }
	
	  // "4. Output the characters of the uri-path from the first character up to,
	  // but not including, the right-most %x2F ("/")."
	  return path.slice(0, rightSlash);
	}
	
	
	function parse(str, options) {
	  if (!options || typeof options !== 'object') {
	    options = {};
	  }
	  str = str.trim();
	
	  // S4.1.1 Trailing semi-colons are not part of the specification.
	  var semiColonCheck = TRAILING_SEMICOLON.exec(str);
	  if (semiColonCheck) {
	    str = str.slice(0, semiColonCheck.index);
	  }
	
	  // We use a regex to parse the "name-value-pair" part of S5.2
	  var firstSemi = str.indexOf(';'); // S5.2 step 1
	  var pairRe = options.loose ? LOOSE_COOKIE_PAIR : COOKIE_PAIR;
	  var result = pairRe.exec(firstSemi === -1 ? str : str.substr(0,firstSemi));
	
	  // Rx satisfies the "the name string is empty" and "lacks a %x3D ("=")"
	  // constraints as well as trimming any whitespace.
	  if (!result) {
	    return;
	  }
	
	  var c = new Cookie();
	  if (result[1]) {
	    c.key = result[2].trim();
	  } else {
	    c.key = '';
	  }
	  c.value = result[3].trim();
	  if (CONTROL_CHARS.test(c.key) || CONTROL_CHARS.test(c.value)) {
	    return;
	  }
	
	  if (firstSemi === -1) {
	    return c;
	  }
	
	  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
	  // (including the %x3B (";") in question)." plus later on in the same section
	  // "discard the first ";" and trim".
	  var unparsed = str.slice(firstSemi).replace(/^\s*;\s*/,'').trim();
	
	  // "If the unparsed-attributes string is empty, skip the rest of these
	  // steps."
	  if (unparsed.length === 0) {
	    return c;
	  }
	
	  /*
	   * S5.2 says that when looping over the items "[p]rocess the attribute-name
	   * and attribute-value according to the requirements in the following
	   * subsections" for every item.  Plus, for many of the individual attributes
	   * in S5.3 it says to use the "attribute-value of the last attribute in the
	   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
	   * the previous value.
	   */
	  var cookie_avs = unparsed.split(/\s*;\s*/);
	  while (cookie_avs.length) {
	    var av = cookie_avs.shift();
	    var av_sep = av.indexOf('=');
	    var av_key, av_value;
	
	    if (av_sep === -1) {
	      av_key = av;
	      av_value = null;
	    } else {
	      av_key = av.substr(0,av_sep);
	      av_value = av.substr(av_sep+1);
	    }
	
	    av_key = av_key.trim().toLowerCase();
	
	    if (av_value) {
	      av_value = av_value.trim();
	    }
	
	    switch(av_key) {
	    case 'expires': // S5.2.1
	      if (av_value) {
	        var exp = parseDate(av_value);
	        // "If the attribute-value failed to parse as a cookie date, ignore the
	        // cookie-av."
	        if (exp) {
	          // over and underflow not realistically a concern: V8's getTime() seems to
	          // store something larger than a 32-bit time_t (even with 32-bit node)
	          c.expires = exp;
	        }
	      }
	      break;
	
	    case 'max-age': // S5.2.2
	      if (av_value) {
	        // "If the first character of the attribute-value is not a DIGIT or a "-"
	        // character ...[or]... If the remainder of attribute-value contains a
	        // non-DIGIT character, ignore the cookie-av."
	        if (/^-?[0-9]+$/.test(av_value)) {
	          var delta = parseInt(av_value, 10);
	          // "If delta-seconds is less than or equal to zero (0), let expiry-time
	          // be the earliest representable date and time."
	          c.setMaxAge(delta);
	        }
	      }
	      break;
	
	    case 'domain': // S5.2.3
	      // "If the attribute-value is empty, the behavior is undefined.  However,
	      // the user agent SHOULD ignore the cookie-av entirely."
	      if (av_value) {
	        // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
	        // (".") character."
	        var domain = av_value.trim().replace(/^\./, '');
	        if (domain) {
	          // "Convert the cookie-domain to lower case."
	          c.domain = domain.toLowerCase();
	        }
	      }
	      break;
	
	    case 'path': // S5.2.4
	      /*
	       * "If the attribute-value is empty or if the first character of the
	       * attribute-value is not %x2F ("/"):
	       *   Let cookie-path be the default-path.
	       * Otherwise:
	       *   Let cookie-path be the attribute-value."
	       *
	       * We'll represent the default-path as null since it depends on the
	       * context of the parsing.
	       */
	      c.path = av_value && av_value[0] === "/" ? av_value : null;
	      break;
	
	    case 'secure': // S5.2.5
	      /*
	       * "If the attribute-name case-insensitively matches the string "Secure",
	       * the user agent MUST append an attribute to the cookie-attribute-list
	       * with an attribute-name of Secure and an empty attribute-value."
	       */
	      c.secure = true;
	      break;
	
	    case 'httponly': // S5.2.6 -- effectively the same as 'secure'
	      c.httpOnly = true;
	      break;
	
	    default:
	      c.extensions = c.extensions || [];
	      c.extensions.push(av);
	      break;
	    }
	  }
	
	  return c;
	}
	
	// avoid the V8 deoptimization monster!
	function jsonParse(str) {
	  var obj;
	  try {
	    obj = JSON.parse(str);
	  } catch (e) {
	    return e;
	  }
	  return obj;
	}
	
	function fromJSON(str) {
	  if (!str) {
	    return null;
	  }
	
	  var obj;
	  if (typeof str === 'string') {
	    obj = jsonParse(str);
	    if (obj instanceof Error) {
	      return null;
	    }
	  } else {
	    // assume it's an Object
	    obj = str;
	  }
	
	  var c = new Cookie();
	  for (var i=0; i<Cookie.serializableProperties.length; i++) {
	    var prop = Cookie.serializableProperties[i];
	    if (obj[prop] === undefined ||
	        obj[prop] === Cookie.prototype[prop])
	    {
	      continue; // leave as prototype default
	    }
	
	    if (prop === 'expires' ||
	        prop === 'creation' ||
	        prop === 'lastAccessed')
	    {
	      if (obj[prop] === null) {
	        c[prop] = null;
	      } else {
	        c[prop] = obj[prop] == "Infinity" ?
	          "Infinity" : new Date(obj[prop]);
	      }
	    } else {
	      c[prop] = obj[prop];
	    }
	  }
	
	  return c;
	}
	
	/* Section 5.4 part 2:
	 * "*  Cookies with longer paths are listed before cookies with
	 *     shorter paths.
	 *
	 *  *  Among cookies that have equal-length path fields, cookies with
	 *     earlier creation-times are listed before cookies with later
	 *     creation-times."
	 */
	
	function cookieCompare(a,b) {
	  var cmp = 0;
	
	  // descending for length: b CMP a
	  var aPathLen = a.path ? a.path.length : 0;
	  var bPathLen = b.path ? b.path.length : 0;
	  cmp = bPathLen - aPathLen;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  // ascending for time: a CMP b
	  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
	  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
	  cmp = aTime - bTime;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  // break ties for the same millisecond (precision of JavaScript's clock)
	  cmp = a.creationIndex - b.creationIndex;
	
	  return cmp;
	}
	
	// Gives the permutation of all possible pathMatch()es of a given path. The
	// array is in longest-to-shortest order.  Handy for indexing.
	function permutePath(path) {
	  if (path === '/') {
	    return ['/'];
	  }
	  if (path.lastIndexOf('/') === path.length-1) {
	    path = path.substr(0,path.length-1);
	  }
	  var permutations = [path];
	  while (path.length > 1) {
	    var lindex = path.lastIndexOf('/');
	    if (lindex === 0) {
	      break;
	    }
	    path = path.substr(0,lindex);
	    permutations.push(path);
	  }
	  permutations.push('/');
	  return permutations;
	}
	
	function getCookieContext(url) {
	  if (url instanceof Object) {
	    return url;
	  }
	  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
	  // Therefore, we will just skip decoding for such URIs.
	  try {
	    url = decodeURI(url);
	  }
	  catch(err) {
	    // Silently swallow error
	  }
	
	  return urlParse(url);
	}
	
	function Cookie(options) {
	  options = options || {};
	
	  Object.keys(options).forEach(function(prop) {
	    if (Cookie.prototype.hasOwnProperty(prop) &&
	        Cookie.prototype[prop] !== options[prop] &&
	        prop.substr(0,1) !== '_')
	    {
	      this[prop] = options[prop];
	    }
	  }, this);
	
	  this.creation = this.creation || new Date();
	
	  // used to break creation ties in cookieCompare():
	  Object.defineProperty(this, 'creationIndex', {
	    configurable: false,
	    enumerable: false, // important for assert.deepEqual checks
	    writable: true,
	    value: ++Cookie.cookiesCreated
	  });
	}
	
	Cookie.cookiesCreated = 0; // incremented each time a cookie is created
	
	Cookie.parse = parse;
	Cookie.fromJSON = fromJSON;
	
	Cookie.prototype.key = "";
	Cookie.prototype.value = "";
	
	// the order in which the RFC has them:
	Cookie.prototype.expires = "Infinity"; // coerces to literal Infinity
	Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
	Cookie.prototype.domain = null;
	Cookie.prototype.path = null;
	Cookie.prototype.secure = false;
	Cookie.prototype.httpOnly = false;
	Cookie.prototype.extensions = null;
	
	// set by the CookieJar:
	Cookie.prototype.hostOnly = null; // boolean when set
	Cookie.prototype.pathIsDefault = null; // boolean when set
	Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
	Cookie.prototype.lastAccessed = null; // Date when set
	Object.defineProperty(Cookie.prototype, 'creationIndex', {
	  configurable: true,
	  enumerable: false,
	  writable: true,
	  value: 0
	});
	
	Cookie.serializableProperties = Object.keys(Cookie.prototype)
	  .filter(function(prop) {
	    return !(
	      Cookie.prototype[prop] instanceof Function ||
	      prop === 'creationIndex' ||
	      prop.substr(0,1) === '_'
	    );
	  });
	
	Cookie.prototype.inspect = function inspect() {
	  var now = Date.now();
	  return 'Cookie="'+this.toString() +
	    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +
	    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +
	    '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +
	    '"';
	};
	
	Cookie.prototype.toJSON = function() {
	  var obj = {};
	
	  var props = Cookie.serializableProperties;
	  for (var i=0; i<props.length; i++) {
	    var prop = props[i];
	    if (this[prop] === Cookie.prototype[prop]) {
	      continue; // leave as prototype default
	    }
	
	    if (prop === 'expires' ||
	        prop === 'creation' ||
	        prop === 'lastAccessed')
	    {
	      if (this[prop] === null) {
	        obj[prop] = null;
	      } else {
	        obj[prop] = this[prop] == "Infinity" ? // intentionally not ===
	          "Infinity" : this[prop].toISOString();
	      }
	    } else if (prop === 'maxAge') {
	      if (this[prop] !== null) {
	        // again, intentionally not ===
	        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
	          this[prop].toString() : this[prop];
	      }
	    } else {
	      if (this[prop] !== Cookie.prototype[prop]) {
	        obj[prop] = this[prop];
	      }
	    }
	  }
	
	  return obj;
	};
	
	Cookie.prototype.clone = function() {
	  return fromJSON(this.toJSON());
	};
	
	Cookie.prototype.validate = function validate() {
	  if (!COOKIE_OCTETS.test(this.value)) {
	    return false;
	  }
	  if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
	    return false;
	  }
	  if (this.maxAge != null && this.maxAge <= 0) {
	    return false; // "Max-Age=" non-zero-digit *DIGIT
	  }
	  if (this.path != null && !PATH_VALUE.test(this.path)) {
	    return false;
	  }
	
	  var cdomain = this.cdomain();
	  if (cdomain) {
	    if (cdomain.match(/\.$/)) {
	      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
	    }
	    var suffix = pubsuffix.getPublicSuffix(cdomain);
	    if (suffix == null) { // it's a public suffix
	      return false;
	    }
	  }
	  return true;
	};
	
	Cookie.prototype.setExpires = function setExpires(exp) {
	  if (exp instanceof Date) {
	    this.expires = exp;
	  } else {
	    this.expires = parseDate(exp) || "Infinity";
	  }
	};
	
	Cookie.prototype.setMaxAge = function setMaxAge(age) {
	  if (age === Infinity || age === -Infinity) {
	    this.maxAge = age.toString(); // so JSON.stringify() works
	  } else {
	    this.maxAge = age;
	  }
	};
	
	// gives Cookie header format
	Cookie.prototype.cookieString = function cookieString() {
	  var val = this.value;
	  if (val == null) {
	    val = '';
	  }
	  if (this.key === '') {
	    return val;
	  }
	  return this.key+'='+val;
	};
	
	// gives Set-Cookie header format
	Cookie.prototype.toString = function toString() {
	  var str = this.cookieString();
	
	  if (this.expires != Infinity) {
	    if (this.expires instanceof Date) {
	      str += '; Expires='+formatDate(this.expires);
	    } else {
	      str += '; Expires='+this.expires;
	    }
	  }
	
	  if (this.maxAge != null && this.maxAge != Infinity) {
	    str += '; Max-Age='+this.maxAge;
	  }
	
	  if (this.domain && !this.hostOnly) {
	    str += '; Domain='+this.domain;
	  }
	  if (this.path) {
	    str += '; Path='+this.path;
	  }
	
	  if (this.secure) {
	    str += '; Secure';
	  }
	  if (this.httpOnly) {
	    str += '; HttpOnly';
	  }
	  if (this.extensions) {
	    this.extensions.forEach(function(ext) {
	      str += '; '+ext;
	    });
	  }
	
	  return str;
	};
	
	// TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere)
	// S5.3 says to give the "latest representable date" for which we use Infinity
	// For "expired" we use 0
	Cookie.prototype.TTL = function TTL(now) {
	  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
	   * attribute, the Max-Age attribute has precedence and controls the
	   * expiration date of the cookie.
	   * (Concurs with S5.3 step 3)
	   */
	  if (this.maxAge != null) {
	    return this.maxAge<=0 ? 0 : this.maxAge*1000;
	  }
	
	  var expires = this.expires;
	  if (expires != Infinity) {
	    if (!(expires instanceof Date)) {
	      expires = parseDate(expires) || Infinity;
	    }
	
	    if (expires == Infinity) {
	      return Infinity;
	    }
	
	    return expires.getTime() - (now || Date.now());
	  }
	
	  return Infinity;
	};
	
	// expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere)
	Cookie.prototype.expiryTime = function expiryTime(now) {
	  if (this.maxAge != null) {
	    var relativeTo = now || this.creation || new Date();
	    var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;
	    return relativeTo.getTime() + age;
	  }
	
	  if (this.expires == Infinity) {
	    return Infinity;
	  }
	  return this.expires.getTime();
	};
	
	// expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere), except it returns a Date
	Cookie.prototype.expiryDate = function expiryDate(now) {
	  var millisec = this.expiryTime(now);
	  if (millisec == Infinity) {
	    return new Date(MAX_TIME);
	  } else if (millisec == -Infinity) {
	    return new Date(MIN_TIME);
	  } else {
	    return new Date(millisec);
	  }
	};
	
	// This replaces the "persistent-flag" parts of S5.3 step 3
	Cookie.prototype.isPersistent = function isPersistent() {
	  return (this.maxAge != null || this.expires != Infinity);
	};
	
	// Mostly S5.1.2 and S5.2.3:
	Cookie.prototype.cdomain =
	Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
	  if (this.domain == null) {
	    return null;
	  }
	  return canonicalDomain(this.domain);
	};
	
	function CookieJar(store, options) {
	  if (typeof options === "boolean") {
	    options = {rejectPublicSuffixes: options};
	  } else if (options == null) {
	    options = {};
	  }
	  if (options.rejectPublicSuffixes != null) {
	    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
	  }
	  if (options.looseMode != null) {
	    this.enableLooseMode = options.looseMode;
	  }
	
	  if (!store) {
	    store = new MemoryCookieStore();
	  }
	  this.store = store;
	}
	CookieJar.prototype.store = null;
	CookieJar.prototype.rejectPublicSuffixes = true;
	CookieJar.prototype.enableLooseMode = false;
	var CAN_BE_SYNC = [];
	
	CAN_BE_SYNC.push('setCookie');
	CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
	  var err;
	  var context = getCookieContext(url);
	  if (options instanceof Function) {
	    cb = options;
	    options = {};
	  }
	
	  var host = canonicalDomain(context.hostname);
	  var loose = this.enableLooseMode;
	  if (options.loose != null) {
	    loose = options.loose;
	  }
	
	  // S5.3 step 1
	  if (!(cookie instanceof Cookie)) {
	    cookie = Cookie.parse(cookie, { loose: loose });
	  }
	  if (!cookie) {
	    err = new Error("Cookie failed to parse");
	    return cb(options.ignoreError ? null : err);
	  }
	
	  // S5.3 step 2
	  var now = options.now || new Date(); // will assign later to save effort in the face of errors
	
	  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()
	
	  // S5.3 step 4: NOOP; domain is null by default
	
	  // S5.3 step 5: public suffixes
	  if (this.rejectPublicSuffixes && cookie.domain) {
	    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
	    if (suffix == null) { // e.g. "com"
	      err = new Error("Cookie has domain set to a public suffix");
	      return cb(options.ignoreError ? null : err);
	    }
	  }
	
	  // S5.3 step 6:
	  if (cookie.domain) {
	    if (!domainMatch(host, cookie.cdomain(), false)) {
	      err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain()+" Request:"+host);
	      return cb(options.ignoreError ? null : err);
	    }
	
	    if (cookie.hostOnly == null) { // don't reset if already set
	      cookie.hostOnly = false;
	    }
	
	  } else {
	    cookie.hostOnly = true;
	    cookie.domain = host;
	  }
	
	  //S5.2.4 If the attribute-value is empty or if the first character of the
	  //attribute-value is not %x2F ("/"):
	  //Let cookie-path be the default-path.
	  if (!cookie.path || cookie.path[0] !== '/') {
	    cookie.path = defaultPath(context.pathname);
	    cookie.pathIsDefault = true;
	  }
	
	  // S5.3 step 8: NOOP; secure attribute
	  // S5.3 step 9: NOOP; httpOnly attribute
	
	  // S5.3 step 10
	  if (options.http === false && cookie.httpOnly) {
	    err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
	    return cb(options.ignoreError ? null : err);
	  }
	
	  var store = this.store;
	
	  if (!store.updateCookie) {
	    store.updateCookie = function(oldCookie, newCookie, cb) {
	      this.putCookie(newCookie, cb);
	    };
	  }
	
	  function withCookie(err, oldCookie) {
	    if (err) {
	      return cb(err);
	    }
	
	    var next = function(err) {
	      if (err) {
	        return cb(err);
	      } else {
	        cb(null, cookie);
	      }
	    };
	
	    if (oldCookie) {
	      // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
	      // domain, and path as the newly created cookie:"
	      if (options.http === false && oldCookie.httpOnly) { // step 11.2
	        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
	        return cb(options.ignoreError ? null : err);
	      }
	      cookie.creation = oldCookie.creation; // step 11.3
	      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
	      cookie.lastAccessed = now;
	      // Step 11.4 (delete cookie) is implied by just setting the new one:
	      store.updateCookie(oldCookie, cookie, next); // step 12
	
	    } else {
	      cookie.creation = cookie.lastAccessed = now;
	      store.putCookie(cookie, next); // step 12
	    }
	  }
	
	  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
	};
	
	// RFC6365 S5.4
	CAN_BE_SYNC.push('getCookies');
	CookieJar.prototype.getCookies = function(url, options, cb) {
	  var context = getCookieContext(url);
	  if (options instanceof Function) {
	    cb = options;
	    options = {};
	  }
	
	  var host = canonicalDomain(context.hostname);
	  var path = context.pathname || '/';
	
	  var secure = options.secure;
	  if (secure == null && context.protocol &&
	      (context.protocol == 'https:' || context.protocol == 'wss:'))
	  {
	    secure = true;
	  }
	
	  var http = options.http;
	  if (http == null) {
	    http = true;
	  }
	
	  var now = options.now || Date.now();
	  var expireCheck = options.expire !== false;
	  var allPaths = !!options.allPaths;
	  var store = this.store;
	
	  function matchingCookie(c) {
	    // "Either:
	    //   The cookie's host-only-flag is true and the canonicalized
	    //   request-host is identical to the cookie's domain.
	    // Or:
	    //   The cookie's host-only-flag is false and the canonicalized
	    //   request-host domain-matches the cookie's domain."
	    if (c.hostOnly) {
	      if (c.domain != host) {
	        return false;
	      }
	    } else {
	      if (!domainMatch(host, c.domain, false)) {
	        return false;
	      }
	    }
	
	    // "The request-uri's path path-matches the cookie's path."
	    if (!allPaths && !pathMatch(path, c.path)) {
	      return false;
	    }
	
	    // "If the cookie's secure-only-flag is true, then the request-uri's
	    // scheme must denote a "secure" protocol"
	    if (c.secure && !secure) {
	      return false;
	    }
	
	    // "If the cookie's http-only-flag is true, then exclude the cookie if the
	    // cookie-string is being generated for a "non-HTTP" API"
	    if (c.httpOnly && !http) {
	      return false;
	    }
	
	    // deferred from S5.3
	    // non-RFC: allow retention of expired cookies by choice
	    if (expireCheck && c.expiryTime() <= now) {
	      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
	      return false;
	    }
	
	    return true;
	  }
	
	  store.findCookies(host, allPaths ? null : path, function(err,cookies) {
	    if (err) {
	      return cb(err);
	    }
	
	    cookies = cookies.filter(matchingCookie);
	
	    // sorting of S5.4 part 2
	    if (options.sort !== false) {
	      cookies = cookies.sort(cookieCompare);
	    }
	
	    // S5.4 part 3
	    var now = new Date();
	    cookies.forEach(function(c) {
	      c.lastAccessed = now;
	    });
	    // TODO persist lastAccessed
	
	    cb(null,cookies);
	  });
	};
	
	CAN_BE_SYNC.push('getCookieString');
	CookieJar.prototype.getCookieString = function(/*..., cb*/) {
	  var args = Array.prototype.slice.call(arguments,0);
	  var cb = args.pop();
	  var next = function(err,cookies) {
	    if (err) {
	      cb(err);
	    } else {
	      cb(null, cookies
	        .sort(cookieCompare)
	        .map(function(c){
	          return c.cookieString();
	        })
	        .join('; '));
	    }
	  };
	  args.push(next);
	  this.getCookies.apply(this,args);
	};
	
	CAN_BE_SYNC.push('getSetCookieStrings');
	CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
	  var args = Array.prototype.slice.call(arguments,0);
	  var cb = args.pop();
	  var next = function(err,cookies) {
	    if (err) {
	      cb(err);
	    } else {
	      cb(null, cookies.map(function(c){
	        return c.toString();
	      }));
	    }
	  };
	  args.push(next);
	  this.getCookies.apply(this,args);
	};
	
	CAN_BE_SYNC.push('serialize');
	CookieJar.prototype.serialize = function(cb) {
	  var type = this.store.constructor.name;
	  if (type === 'Object') {
	    type = null;
	  }
	
	  // update README.md "Serialization Format" if you change this, please!
	  var serialized = {
	    // The version of tough-cookie that serialized this jar. Generally a good
	    // practice since future versions can make data import decisions based on
	    // known past behavior. When/if this matters, use `semver`.
	    version: 'tough-cookie@'+VERSION,
	
	    // add the store type, to make humans happy:
	    storeType: type,
	
	    // CookieJar configuration:
	    rejectPublicSuffixes: !!this.rejectPublicSuffixes,
	
	    // this gets filled from getAllCookies:
	    cookies: []
	  };
	
	  if (!(this.store.getAllCookies &&
	        typeof this.store.getAllCookies === 'function'))
	  {
	    return cb(new Error('store does not support getAllCookies and cannot be serialized'));
	  }
	
	  this.store.getAllCookies(function(err,cookies) {
	    if (err) {
	      return cb(err);
	    }
	
	    serialized.cookies = cookies.map(function(cookie) {
	      // convert to serialized 'raw' cookies
	      cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;
	
	      // Remove the index so new ones get assigned during deserialization
	      delete cookie.creationIndex;
	
	      return cookie;
	    });
	
	    return cb(null, serialized);
	  });
	};
	
	// well-known name that JSON.stringify calls
	CookieJar.prototype.toJSON = function() {
	  return this.serializeSync();
	};
	
	// use the class method CookieJar.deserialize instead of calling this directly
	CAN_BE_SYNC.push('_importCookies');
	CookieJar.prototype._importCookies = function(serialized, cb) {
	  var jar = this;
	  var cookies = serialized.cookies;
	  if (!cookies || !Array.isArray(cookies)) {
	    return cb(new Error('serialized jar has no cookies array'));
	  }
	
	  function putNext(err) {
	    if (err) {
	      return cb(err);
	    }
	
	    if (!cookies.length) {
	      return cb(err, jar);
	    }
	
	    var cookie;
	    try {
	      cookie = fromJSON(cookies.shift());
	    } catch (e) {
	      return cb(e);
	    }
	
	    if (cookie === null) {
	      return putNext(null); // skip this cookie
	    }
	
	    jar.store.putCookie(cookie, putNext);
	  }
	
	  putNext();
	};
	
	CookieJar.deserialize = function(strOrObj, store, cb) {
	  if (arguments.length !== 3) {
	    // store is optional
	    cb = store;
	    store = null;
	  }
	
	  var serialized;
	  if (typeof strOrObj === 'string') {
	    serialized = jsonParse(strOrObj);
	    if (serialized instanceof Error) {
	      return cb(serialized);
	    }
	  } else {
	    serialized = strOrObj;
	  }
	
	  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
	  jar._importCookies(serialized, function(err) {
	    if (err) {
	      return cb(err);
	    }
	    cb(null, jar);
	  });
	};
	
	CookieJar.deserializeSync = function(strOrObj, store) {
	  var serialized = typeof strOrObj === 'string' ?
	    JSON.parse(strOrObj) : strOrObj;
	  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
	
	  // catch this mistake early:
	  if (!jar.store.synchronous) {
	    throw new Error('CookieJar store is not synchronous; use async API instead.');
	  }
	
	  jar._importCookiesSync(serialized);
	  return jar;
	};
	CookieJar.fromJSON = CookieJar.deserializeSync;
	
	CAN_BE_SYNC.push('clone');
	CookieJar.prototype.clone = function(newStore, cb) {
	  if (arguments.length === 1) {
	    cb = newStore;
	    newStore = null;
	  }
	
	  this.serialize(function(err,serialized) {
	    if (err) {
	      return cb(err);
	    }
	    CookieJar.deserialize(newStore, serialized, cb);
	  });
	};
	
	// Use a closure to provide a true imperative API for synchronous stores.
	function syncWrap(method) {
	  return function() {
	    if (!this.store.synchronous) {
	      throw new Error('CookieJar store is not synchronous; use async API instead.');
	    }
	
	    var args = Array.prototype.slice.call(arguments);
	    var syncErr, syncResult;
	    args.push(function syncCb(err, result) {
	      syncErr = err;
	      syncResult = result;
	    });
	    this[method].apply(this, args);
	
	    if (syncErr) {
	      throw syncErr;
	    }
	    return syncResult;
	  };
	}
	
	// wrap all declared CAN_BE_SYNC methods in the sync wrapper
	CAN_BE_SYNC.forEach(function(method) {
	  CookieJar.prototype[method+'Sync'] = syncWrap(method);
	});
	
	module.exports = {
	  CookieJar: CookieJar,
	  Cookie: Cookie,
	  Store: Store,
	  MemoryCookieStore: MemoryCookieStore,
	  parseDate: parseDate,
	  formatDate: formatDate,
	  parse: parse,
	  fromJSON: fromJSON,
	  domainMatch: domainMatch,
	  defaultPath: defaultPath,
	  pathMatch: pathMatch,
	  getPublicSuffix: pubsuffix.getPublicSuffix,
	  cookieCompare: cookieCompare,
	  permuteDomain: __webpack_require__(/*! ./permuteDomain */ 595).permuteDomain,
	  permutePath: permutePath,
	  canonicalDomain: canonicalDomain
	};


/***/ },
/* 590 */
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 591 */
/*!*****************************************!*\
  !*** ./~/tough-cookie/lib/pubsuffix.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	/****************************************************
	 * AUTOMATICALLY GENERATED by generate-pubsuffix.js *
	 *                  DO NOT EDIT!                    *
	 ****************************************************/
	
	"use strict";
	
	var punycode = __webpack_require__(/*! punycode */ 592);
	
	module.exports.getPublicSuffix = function getPublicSuffix(domain) {
	  /*!
	   * Copyright (c) 2015, Salesforce.com, Inc.
	   * All rights reserved.
	   *
	   * Redistribution and use in source and binary forms, with or without
	   * modification, are permitted provided that the following conditions are met:
	   *
	   * 1. Redistributions of source code must retain the above copyright notice,
	   * this list of conditions and the following disclaimer.
	   *
	   * 2. Redistributions in binary form must reproduce the above copyright notice,
	   * this list of conditions and the following disclaimer in the documentation
	   * and/or other materials provided with the distribution.
	   *
	   * 3. Neither the name of Salesforce.com nor the names of its contributors may
	   * be used to endorse or promote products derived from this software without
	   * specific prior written permission.
	   *
	   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	   * POSSIBILITY OF SUCH DAMAGE.
	   */
	  if (!domain) {
	    return null;
	  }
	  if (domain.match(/^\./)) {
	    return null;
	  }
	  var asciiDomain = punycode.toASCII(domain);
	  var converted = false;
	  if (asciiDomain !== domain) {
	    domain = asciiDomain;
	    converted = true;
	  }
	  if (index[domain]) {
	    return null;
	  }
	
	  domain = domain.toLowerCase();
	  var parts = domain.split('.').reverse();
	
	  var suffix = '';
	  var suffixLen = 0;
	  for (var i=0; i<parts.length; i++) {
	    var part = parts[i];
	    var starstr = '*'+suffix;
	    var partstr = part+suffix;
	
	    if (index[starstr]) { // star rule matches
	      suffixLen = i+1;
	      if (index[partstr] === false) { // exception rule matches (NB: false, not undefined)
	        suffixLen--;
	      }
	    } else if (index[partstr]) { // exact match, not exception
	      suffixLen = i+1;
	    }
	
	    suffix = '.'+partstr;
	  }
	
	  if (index['*'+suffix]) { // *.domain exists (e.g. *.kyoto.jp for domain='kyoto.jp');
	    return null;
	  }
	
	  suffixLen = suffixLen || 1;
	  if (parts.length > suffixLen) {
	    var publicSuffix = parts.slice(0,suffixLen+1).reverse().join('.');
	    return converted ? punycode.toUnicode(publicSuffix) : publicSuffix;
	  }
	
	  return null;
	};
	
	// The following generated structure is used under the MPL version 2.0
	// See public-suffix.txt for more information
	
	var index = module.exports.index = Object.freeze(
	{"ac":true,"com.ac":true,"edu.ac":true,"gov.ac":true,"net.ac":true,"mil.ac":true,"org.ac":true,"ad":true,"nom.ad":true,"ae":true,"co.ae":true,"net.ae":true,"org.ae":true,"sch.ae":true,"ac.ae":true,"gov.ae":true,"mil.ae":true,"aero":true,"accident-investigation.aero":true,"accident-prevention.aero":true,"aerobatic.aero":true,"aeroclub.aero":true,"aerodrome.aero":true,"agents.aero":true,"aircraft.aero":true,"airline.aero":true,"airport.aero":true,"air-surveillance.aero":true,"airtraffic.aero":true,"air-traffic-control.aero":true,"ambulance.aero":true,"amusement.aero":true,"association.aero":true,"author.aero":true,"ballooning.aero":true,"broker.aero":true,"caa.aero":true,"cargo.aero":true,"catering.aero":true,"certification.aero":true,"championship.aero":true,"charter.aero":true,"civilaviation.aero":true,"club.aero":true,"conference.aero":true,"consultant.aero":true,"consulting.aero":true,"control.aero":true,"council.aero":true,"crew.aero":true,"design.aero":true,"dgca.aero":true,"educator.aero":true,"emergency.aero":true,"engine.aero":true,"engineer.aero":true,"entertainment.aero":true,"equipment.aero":true,"exchange.aero":true,"express.aero":true,"federation.aero":true,"flight.aero":true,"freight.aero":true,"fuel.aero":true,"gliding.aero":true,"government.aero":true,"groundhandling.aero":true,"group.aero":true,"hanggliding.aero":true,"homebuilt.aero":true,"insurance.aero":true,"journal.aero":true,"journalist.aero":true,"leasing.aero":true,"logistics.aero":true,"magazine.aero":true,"maintenance.aero":true,"marketplace.aero":true,"media.aero":true,"microlight.aero":true,"modelling.aero":true,"navigation.aero":true,"parachuting.aero":true,"paragliding.aero":true,"passenger-association.aero":true,"pilot.aero":true,"press.aero":true,"production.aero":true,"recreation.aero":true,"repbody.aero":true,"res.aero":true,"research.aero":true,"rotorcraft.aero":true,"safety.aero":true,"scientist.aero":true,"services.aero":true,"show.aero":true,"skydiving.aero":true,"software.aero":true,"student.aero":true,"taxi.aero":true,"trader.aero":true,"trading.aero":true,"trainer.aero":true,"union.aero":true,"workinggroup.aero":true,"works.aero":true,"af":true,"gov.af":true,"com.af":true,"org.af":true,"net.af":true,"edu.af":true,"ag":true,"com.ag":true,"org.ag":true,"net.ag":true,"co.ag":true,"nom.ag":true,"ai":true,"off.ai":true,"com.ai":true,"net.ai":true,"org.ai":true,"al":true,"com.al":true,"edu.al":true,"gov.al":true,"mil.al":true,"net.al":true,"org.al":true,"am":true,"an":true,"com.an":true,"net.an":true,"org.an":true,"edu.an":true,"ao":true,"ed.ao":true,"gv.ao":true,"og.ao":true,"co.ao":true,"pb.ao":true,"it.ao":true,"aq":true,"ar":true,"com.ar":true,"edu.ar":true,"gob.ar":true,"gov.ar":true,"int.ar":true,"mil.ar":true,"net.ar":true,"org.ar":true,"tur.ar":true,"arpa":true,"e164.arpa":true,"in-addr.arpa":true,"ip6.arpa":true,"iris.arpa":true,"uri.arpa":true,"urn.arpa":true,"as":true,"gov.as":true,"asia":true,"at":true,"ac.at":true,"co.at":true,"gv.at":true,"or.at":true,"au":true,"com.au":true,"net.au":true,"org.au":true,"edu.au":true,"gov.au":true,"asn.au":true,"id.au":true,"info.au":true,"conf.au":true,"oz.au":true,"act.au":true,"nsw.au":true,"nt.au":true,"qld.au":true,"sa.au":true,"tas.au":true,"vic.au":true,"wa.au":true,"act.edu.au":true,"nsw.edu.au":true,"nt.edu.au":true,"qld.edu.au":true,"sa.edu.au":true,"tas.edu.au":true,"vic.edu.au":true,"wa.edu.au":true,"qld.gov.au":true,"sa.gov.au":true,"tas.gov.au":true,"vic.gov.au":true,"wa.gov.au":true,"aw":true,"com.aw":true,"ax":true,"az":true,"com.az":true,"net.az":true,"int.az":true,"gov.az":true,"org.az":true,"edu.az":true,"info.az":true,"pp.az":true,"mil.az":true,"name.az":true,"pro.az":true,"biz.az":true,"ba":true,"org.ba":true,"net.ba":true,"edu.ba":true,"gov.ba":true,"mil.ba":true,"unsa.ba":true,"unbi.ba":true,"co.ba":true,"com.ba":true,"rs.ba":true,"bb":true,"biz.bb":true,"co.bb":true,"com.bb":true,"edu.bb":true,"gov.bb":true,"info.bb":true,"net.bb":true,"org.bb":true,"store.bb":true,"tv.bb":true,"*.bd":true,"be":true,"ac.be":true,"bf":true,"gov.bf":true,"bg":true,"a.bg":true,"b.bg":true,"c.bg":true,"d.bg":true,"e.bg":true,"f.bg":true,"g.bg":true,"h.bg":true,"i.bg":true,"j.bg":true,"k.bg":true,"l.bg":true,"m.bg":true,"n.bg":true,"o.bg":true,"p.bg":true,"q.bg":true,"r.bg":true,"s.bg":true,"t.bg":true,"u.bg":true,"v.bg":true,"w.bg":true,"x.bg":true,"y.bg":true,"z.bg":true,"0.bg":true,"1.bg":true,"2.bg":true,"3.bg":true,"4.bg":true,"5.bg":true,"6.bg":true,"7.bg":true,"8.bg":true,"9.bg":true,"bh":true,"com.bh":true,"edu.bh":true,"net.bh":true,"org.bh":true,"gov.bh":true,"bi":true,"co.bi":true,"com.bi":true,"edu.bi":true,"or.bi":true,"org.bi":true,"biz":true,"bj":true,"asso.bj":true,"barreau.bj":true,"gouv.bj":true,"bm":true,"com.bm":true,"edu.bm":true,"gov.bm":true,"net.bm":true,"org.bm":true,"*.bn":true,"bo":true,"com.bo":true,"edu.bo":true,"gov.bo":true,"gob.bo":true,"int.bo":true,"org.bo":true,"net.bo":true,"mil.bo":true,"tv.bo":true,"br":true,"adm.br":true,"adv.br":true,"agr.br":true,"am.br":true,"arq.br":true,"art.br":true,"ato.br":true,"b.br":true,"bio.br":true,"blog.br":true,"bmd.br":true,"cim.br":true,"cng.br":true,"cnt.br":true,"com.br":true,"coop.br":true,"ecn.br":true,"eco.br":true,"edu.br":true,"emp.br":true,"eng.br":true,"esp.br":true,"etc.br":true,"eti.br":true,"far.br":true,"flog.br":true,"fm.br":true,"fnd.br":true,"fot.br":true,"fst.br":true,"g12.br":true,"ggf.br":true,"gov.br":true,"imb.br":true,"ind.br":true,"inf.br":true,"jor.br":true,"jus.br":true,"leg.br":true,"lel.br":true,"mat.br":true,"med.br":true,"mil.br":true,"mp.br":true,"mus.br":true,"net.br":true,"*.nom.br":true,"not.br":true,"ntr.br":true,"odo.br":true,"org.br":true,"ppg.br":true,"pro.br":true,"psc.br":true,"psi.br":true,"qsl.br":true,"radio.br":true,"rec.br":true,"slg.br":true,"srv.br":true,"taxi.br":true,"teo.br":true,"tmp.br":true,"trd.br":true,"tur.br":true,"tv.br":true,"vet.br":true,"vlog.br":true,"wiki.br":true,"zlg.br":true,"bs":true,"com.bs":true,"net.bs":true,"org.bs":true,"edu.bs":true,"gov.bs":true,"bt":true,"com.bt":true,"edu.bt":true,"gov.bt":true,"net.bt":true,"org.bt":true,"bv":true,"bw":true,"co.bw":true,"org.bw":true,"by":true,"gov.by":true,"mil.by":true,"com.by":true,"of.by":true,"bz":true,"com.bz":true,"net.bz":true,"org.bz":true,"edu.bz":true,"gov.bz":true,"ca":true,"ab.ca":true,"bc.ca":true,"mb.ca":true,"nb.ca":true,"nf.ca":true,"nl.ca":true,"ns.ca":true,"nt.ca":true,"nu.ca":true,"on.ca":true,"pe.ca":true,"qc.ca":true,"sk.ca":true,"yk.ca":true,"gc.ca":true,"cat":true,"cc":true,"cd":true,"gov.cd":true,"cf":true,"cg":true,"ch":true,"ci":true,"org.ci":true,"or.ci":true,"com.ci":true,"co.ci":true,"edu.ci":true,"ed.ci":true,"ac.ci":true,"net.ci":true,"go.ci":true,"asso.ci":true,"xn--aroport-bya.ci":true,"int.ci":true,"presse.ci":true,"md.ci":true,"gouv.ci":true,"*.ck":true,"www.ck":false,"cl":true,"gov.cl":true,"gob.cl":true,"co.cl":true,"mil.cl":true,"cm":true,"co.cm":true,"com.cm":true,"gov.cm":true,"net.cm":true,"cn":true,"ac.cn":true,"com.cn":true,"edu.cn":true,"gov.cn":true,"net.cn":true,"org.cn":true,"mil.cn":true,"xn--55qx5d.cn":true,"xn--io0a7i.cn":true,"xn--od0alg.cn":true,"ah.cn":true,"bj.cn":true,"cq.cn":true,"fj.cn":true,"gd.cn":true,"gs.cn":true,"gz.cn":true,"gx.cn":true,"ha.cn":true,"hb.cn":true,"he.cn":true,"hi.cn":true,"hl.cn":true,"hn.cn":true,"jl.cn":true,"js.cn":true,"jx.cn":true,"ln.cn":true,"nm.cn":true,"nx.cn":true,"qh.cn":true,"sc.cn":true,"sd.cn":true,"sh.cn":true,"sn.cn":true,"sx.cn":true,"tj.cn":true,"xj.cn":true,"xz.cn":true,"yn.cn":true,"zj.cn":true,"hk.cn":true,"mo.cn":true,"tw.cn":true,"co":true,"arts.co":true,"com.co":true,"edu.co":true,"firm.co":true,"gov.co":true,"info.co":true,"int.co":true,"mil.co":true,"net.co":true,"nom.co":true,"org.co":true,"rec.co":true,"web.co":true,"com":true,"coop":true,"cr":true,"ac.cr":true,"co.cr":true,"ed.cr":true,"fi.cr":true,"go.cr":true,"or.cr":true,"sa.cr":true,"cu":true,"com.cu":true,"edu.cu":true,"org.cu":true,"net.cu":true,"gov.cu":true,"inf.cu":true,"cv":true,"cw":true,"com.cw":true,"edu.cw":true,"net.cw":true,"org.cw":true,"cx":true,"gov.cx":true,"ac.cy":true,"biz.cy":true,"com.cy":true,"ekloges.cy":true,"gov.cy":true,"ltd.cy":true,"name.cy":true,"net.cy":true,"org.cy":true,"parliament.cy":true,"press.cy":true,"pro.cy":true,"tm.cy":true,"cz":true,"de":true,"dj":true,"dk":true,"dm":true,"com.dm":true,"net.dm":true,"org.dm":true,"edu.dm":true,"gov.dm":true,"do":true,"art.do":true,"com.do":true,"edu.do":true,"gob.do":true,"gov.do":true,"mil.do":true,"net.do":true,"org.do":true,"sld.do":true,"web.do":true,"dz":true,"com.dz":true,"org.dz":true,"net.dz":true,"gov.dz":true,"edu.dz":true,"asso.dz":true,"pol.dz":true,"art.dz":true,"ec":true,"com.ec":true,"info.ec":true,"net.ec":true,"fin.ec":true,"k12.ec":true,"med.ec":true,"pro.ec":true,"org.ec":true,"edu.ec":true,"gov.ec":true,"gob.ec":true,"mil.ec":true,"edu":true,"ee":true,"edu.ee":true,"gov.ee":true,"riik.ee":true,"lib.ee":true,"med.ee":true,"com.ee":true,"pri.ee":true,"aip.ee":true,"org.ee":true,"fie.ee":true,"eg":true,"com.eg":true,"edu.eg":true,"eun.eg":true,"gov.eg":true,"mil.eg":true,"name.eg":true,"net.eg":true,"org.eg":true,"sci.eg":true,"*.er":true,"es":true,"com.es":true,"nom.es":true,"org.es":true,"gob.es":true,"edu.es":true,"et":true,"com.et":true,"gov.et":true,"org.et":true,"edu.et":true,"biz.et":true,"name.et":true,"info.et":true,"net.et":true,"eu":true,"fi":true,"aland.fi":true,"*.fj":true,"*.fk":true,"fm":true,"fo":true,"fr":true,"com.fr":true,"asso.fr":true,"nom.fr":true,"prd.fr":true,"presse.fr":true,"tm.fr":true,"aeroport.fr":true,"assedic.fr":true,"avocat.fr":true,"avoues.fr":true,"cci.fr":true,"chambagri.fr":true,"chirurgiens-dentistes.fr":true,"experts-comptables.fr":true,"geometre-expert.fr":true,"gouv.fr":true,"greta.fr":true,"huissier-justice.fr":true,"medecin.fr":true,"notaires.fr":true,"pharmacien.fr":true,"port.fr":true,"veterinaire.fr":true,"ga":true,"gb":true,"gd":true,"ge":true,"com.ge":true,"edu.ge":true,"gov.ge":true,"org.ge":true,"mil.ge":true,"net.ge":true,"pvt.ge":true,"gf":true,"gg":true,"co.gg":true,"net.gg":true,"org.gg":true,"gh":true,"com.gh":true,"edu.gh":true,"gov.gh":true,"org.gh":true,"mil.gh":true,"gi":true,"com.gi":true,"ltd.gi":true,"gov.gi":true,"mod.gi":true,"edu.gi":true,"org.gi":true,"gl":true,"co.gl":true,"com.gl":true,"edu.gl":true,"net.gl":true,"org.gl":true,"gm":true,"gn":true,"ac.gn":true,"com.gn":true,"edu.gn":true,"gov.gn":true,"org.gn":true,"net.gn":true,"gov":true,"gp":true,"com.gp":true,"net.gp":true,"mobi.gp":true,"edu.gp":true,"org.gp":true,"asso.gp":true,"gq":true,"gr":true,"com.gr":true,"edu.gr":true,"net.gr":true,"org.gr":true,"gov.gr":true,"gs":true,"gt":true,"com.gt":true,"edu.gt":true,"gob.gt":true,"ind.gt":true,"mil.gt":true,"net.gt":true,"org.gt":true,"*.gu":true,"gw":true,"gy":true,"co.gy":true,"com.gy":true,"net.gy":true,"hk":true,"com.hk":true,"edu.hk":true,"gov.hk":true,"idv.hk":true,"net.hk":true,"org.hk":true,"xn--55qx5d.hk":true,"xn--wcvs22d.hk":true,"xn--lcvr32d.hk":true,"xn--mxtq1m.hk":true,"xn--gmqw5a.hk":true,"xn--ciqpn.hk":true,"xn--gmq050i.hk":true,"xn--zf0avx.hk":true,"xn--io0a7i.hk":true,"xn--mk0axi.hk":true,"xn--od0alg.hk":true,"xn--od0aq3b.hk":true,"xn--tn0ag.hk":true,"xn--uc0atv.hk":true,"xn--uc0ay4a.hk":true,"hm":true,"hn":true,"com.hn":true,"edu.hn":true,"org.hn":true,"net.hn":true,"mil.hn":true,"gob.hn":true,"hr":true,"iz.hr":true,"from.hr":true,"name.hr":true,"com.hr":true,"ht":true,"com.ht":true,"shop.ht":true,"firm.ht":true,"info.ht":true,"adult.ht":true,"net.ht":true,"pro.ht":true,"org.ht":true,"med.ht":true,"art.ht":true,"coop.ht":true,"pol.ht":true,"asso.ht":true,"edu.ht":true,"rel.ht":true,"gouv.ht":true,"perso.ht":true,"hu":true,"co.hu":true,"info.hu":true,"org.hu":true,"priv.hu":true,"sport.hu":true,"tm.hu":true,"2000.hu":true,"agrar.hu":true,"bolt.hu":true,"casino.hu":true,"city.hu":true,"erotica.hu":true,"erotika.hu":true,"film.hu":true,"forum.hu":true,"games.hu":true,"hotel.hu":true,"ingatlan.hu":true,"jogasz.hu":true,"konyvelo.hu":true,"lakas.hu":true,"media.hu":true,"news.hu":true,"reklam.hu":true,"sex.hu":true,"shop.hu":true,"suli.hu":true,"szex.hu":true,"tozsde.hu":true,"utazas.hu":true,"video.hu":true,"id":true,"ac.id":true,"biz.id":true,"co.id":true,"desa.id":true,"go.id":true,"mil.id":true,"my.id":true,"net.id":true,"or.id":true,"sch.id":true,"web.id":true,"ie":true,"gov.ie":true,"il":true,"ac.il":true,"co.il":true,"gov.il":true,"idf.il":true,"k12.il":true,"muni.il":true,"net.il":true,"org.il":true,"im":true,"ac.im":true,"co.im":true,"com.im":true,"ltd.co.im":true,"net.im":true,"org.im":true,"plc.co.im":true,"tt.im":true,"tv.im":true,"in":true,"co.in":true,"firm.in":true,"net.in":true,"org.in":true,"gen.in":true,"ind.in":true,"nic.in":true,"ac.in":true,"edu.in":true,"res.in":true,"gov.in":true,"mil.in":true,"info":true,"int":true,"eu.int":true,"io":true,"com.io":true,"iq":true,"gov.iq":true,"edu.iq":true,"mil.iq":true,"com.iq":true,"org.iq":true,"net.iq":true,"ir":true,"ac.ir":true,"co.ir":true,"gov.ir":true,"id.ir":true,"net.ir":true,"org.ir":true,"sch.ir":true,"xn--mgba3a4f16a.ir":true,"xn--mgba3a4fra.ir":true,"is":true,"net.is":true,"com.is":true,"edu.is":true,"gov.is":true,"org.is":true,"int.is":true,"it":true,"gov.it":true,"edu.it":true,"abr.it":true,"abruzzo.it":true,"aosta-valley.it":true,"aostavalley.it":true,"bas.it":true,"basilicata.it":true,"cal.it":true,"calabria.it":true,"cam.it":true,"campania.it":true,"emilia-romagna.it":true,"emiliaromagna.it":true,"emr.it":true,"friuli-v-giulia.it":true,"friuli-ve-giulia.it":true,"friuli-vegiulia.it":true,"friuli-venezia-giulia.it":true,"friuli-veneziagiulia.it":true,"friuli-vgiulia.it":true,"friuliv-giulia.it":true,"friulive-giulia.it":true,"friulivegiulia.it":true,"friulivenezia-giulia.it":true,"friuliveneziagiulia.it":true,"friulivgiulia.it":true,"fvg.it":true,"laz.it":true,"lazio.it":true,"lig.it":true,"liguria.it":true,"lom.it":true,"lombardia.it":true,"lombardy.it":true,"lucania.it":true,"mar.it":true,"marche.it":true,"mol.it":true,"molise.it":true,"piedmont.it":true,"piemonte.it":true,"pmn.it":true,"pug.it":true,"puglia.it":true,"sar.it":true,"sardegna.it":true,"sardinia.it":true,"sic.it":true,"sicilia.it":true,"sicily.it":true,"taa.it":true,"tos.it":true,"toscana.it":true,"trentino-a-adige.it":true,"trentino-aadige.it":true,"trentino-alto-adige.it":true,"trentino-altoadige.it":true,"trentino-s-tirol.it":true,"trentino-stirol.it":true,"trentino-sud-tirol.it":true,"trentino-sudtirol.it":true,"trentino-sued-tirol.it":true,"trentino-suedtirol.it":true,"trentinoa-adige.it":true,"trentinoaadige.it":true,"trentinoalto-adige.it":true,"trentinoaltoadige.it":true,"trentinos-tirol.it":true,"trentinostirol.it":true,"trentinosud-tirol.it":true,"trentinosudtirol.it":true,"trentinosued-tirol.it":true,"trentinosuedtirol.it":true,"tuscany.it":true,"umb.it":true,"umbria.it":true,"val-d-aosta.it":true,"val-daosta.it":true,"vald-aosta.it":true,"valdaosta.it":true,"valle-aosta.it":true,"valle-d-aosta.it":true,"valle-daosta.it":true,"valleaosta.it":true,"valled-aosta.it":true,"valledaosta.it":true,"vallee-aoste.it":true,"valleeaoste.it":true,"vao.it":true,"vda.it":true,"ven.it":true,"veneto.it":true,"ag.it":true,"agrigento.it":true,"al.it":true,"alessandria.it":true,"alto-adige.it":true,"altoadige.it":true,"an.it":true,"ancona.it":true,"andria-barletta-trani.it":true,"andria-trani-barletta.it":true,"andriabarlettatrani.it":true,"andriatranibarletta.it":true,"ao.it":true,"aosta.it":true,"aoste.it":true,"ap.it":true,"aq.it":true,"aquila.it":true,"ar.it":true,"arezzo.it":true,"ascoli-piceno.it":true,"ascolipiceno.it":true,"asti.it":true,"at.it":true,"av.it":true,"avellino.it":true,"ba.it":true,"balsan.it":true,"bari.it":true,"barletta-trani-andria.it":true,"barlettatraniandria.it":true,"belluno.it":true,"benevento.it":true,"bergamo.it":true,"bg.it":true,"bi.it":true,"biella.it":true,"bl.it":true,"bn.it":true,"bo.it":true,"bologna.it":true,"bolzano.it":true,"bozen.it":true,"br.it":true,"brescia.it":true,"brindisi.it":true,"bs.it":true,"bt.it":true,"bz.it":true,"ca.it":true,"cagliari.it":true,"caltanissetta.it":true,"campidano-medio.it":true,"campidanomedio.it":true,"campobasso.it":true,"carbonia-iglesias.it":true,"carboniaiglesias.it":true,"carrara-massa.it":true,"carraramassa.it":true,"caserta.it":true,"catania.it":true,"catanzaro.it":true,"cb.it":true,"ce.it":true,"cesena-forli.it":true,"cesenaforli.it":true,"ch.it":true,"chieti.it":true,"ci.it":true,"cl.it":true,"cn.it":true,"co.it":true,"como.it":true,"cosenza.it":true,"cr.it":true,"cremona.it":true,"crotone.it":true,"cs.it":true,"ct.it":true,"cuneo.it":true,"cz.it":true,"dell-ogliastra.it":true,"dellogliastra.it":true,"en.it":true,"enna.it":true,"fc.it":true,"fe.it":true,"fermo.it":true,"ferrara.it":true,"fg.it":true,"fi.it":true,"firenze.it":true,"florence.it":true,"fm.it":true,"foggia.it":true,"forli-cesena.it":true,"forlicesena.it":true,"fr.it":true,"frosinone.it":true,"ge.it":true,"genoa.it":true,"genova.it":true,"go.it":true,"gorizia.it":true,"gr.it":true,"grosseto.it":true,"iglesias-carbonia.it":true,"iglesiascarbonia.it":true,"im.it":true,"imperia.it":true,"is.it":true,"isernia.it":true,"kr.it":true,"la-spezia.it":true,"laquila.it":true,"laspezia.it":true,"latina.it":true,"lc.it":true,"le.it":true,"lecce.it":true,"lecco.it":true,"li.it":true,"livorno.it":true,"lo.it":true,"lodi.it":true,"lt.it":true,"lu.it":true,"lucca.it":true,"macerata.it":true,"mantova.it":true,"massa-carrara.it":true,"massacarrara.it":true,"matera.it":true,"mb.it":true,"mc.it":true,"me.it":true,"medio-campidano.it":true,"mediocampidano.it":true,"messina.it":true,"mi.it":true,"milan.it":true,"milano.it":true,"mn.it":true,"mo.it":true,"modena.it":true,"monza-brianza.it":true,"monza-e-della-brianza.it":true,"monza.it":true,"monzabrianza.it":true,"monzaebrianza.it":true,"monzaedellabrianza.it":true,"ms.it":true,"mt.it":true,"na.it":true,"naples.it":true,"napoli.it":true,"no.it":true,"novara.it":true,"nu.it":true,"nuoro.it":true,"og.it":true,"ogliastra.it":true,"olbia-tempio.it":true,"olbiatempio.it":true,"or.it":true,"oristano.it":true,"ot.it":true,"pa.it":true,"padova.it":true,"padua.it":true,"palermo.it":true,"parma.it":true,"pavia.it":true,"pc.it":true,"pd.it":true,"pe.it":true,"perugia.it":true,"pesaro-urbino.it":true,"pesarourbino.it":true,"pescara.it":true,"pg.it":true,"pi.it":true,"piacenza.it":true,"pisa.it":true,"pistoia.it":true,"pn.it":true,"po.it":true,"pordenone.it":true,"potenza.it":true,"pr.it":true,"prato.it":true,"pt.it":true,"pu.it":true,"pv.it":true,"pz.it":true,"ra.it":true,"ragusa.it":true,"ravenna.it":true,"rc.it":true,"re.it":true,"reggio-calabria.it":true,"reggio-emilia.it":true,"reggiocalabria.it":true,"reggioemilia.it":true,"rg.it":true,"ri.it":true,"rieti.it":true,"rimini.it":true,"rm.it":true,"rn.it":true,"ro.it":true,"roma.it":true,"rome.it":true,"rovigo.it":true,"sa.it":true,"salerno.it":true,"sassari.it":true,"savona.it":true,"si.it":true,"siena.it":true,"siracusa.it":true,"so.it":true,"sondrio.it":true,"sp.it":true,"sr.it":true,"ss.it":true,"suedtirol.it":true,"sv.it":true,"ta.it":true,"taranto.it":true,"te.it":true,"tempio-olbia.it":true,"tempioolbia.it":true,"teramo.it":true,"terni.it":true,"tn.it":true,"to.it":true,"torino.it":true,"tp.it":true,"tr.it":true,"trani-andria-barletta.it":true,"trani-barletta-andria.it":true,"traniandriabarletta.it":true,"tranibarlettaandria.it":true,"trapani.it":true,"trentino.it":true,"trento.it":true,"treviso.it":true,"trieste.it":true,"ts.it":true,"turin.it":true,"tv.it":true,"ud.it":true,"udine.it":true,"urbino-pesaro.it":true,"urbinopesaro.it":true,"va.it":true,"varese.it":true,"vb.it":true,"vc.it":true,"ve.it":true,"venezia.it":true,"venice.it":true,"verbania.it":true,"vercelli.it":true,"verona.it":true,"vi.it":true,"vibo-valentia.it":true,"vibovalentia.it":true,"vicenza.it":true,"viterbo.it":true,"vr.it":true,"vs.it":true,"vt.it":true,"vv.it":true,"je":true,"co.je":true,"net.je":true,"org.je":true,"*.jm":true,"jo":true,"com.jo":true,"org.jo":true,"net.jo":true,"edu.jo":true,"sch.jo":true,"gov.jo":true,"mil.jo":true,"name.jo":true,"jobs":true,"jp":true,"ac.jp":true,"ad.jp":true,"co.jp":true,"ed.jp":true,"go.jp":true,"gr.jp":true,"lg.jp":true,"ne.jp":true,"or.jp":true,"aichi.jp":true,"akita.jp":true,"aomori.jp":true,"chiba.jp":true,"ehime.jp":true,"fukui.jp":true,"fukuoka.jp":true,"fukushima.jp":true,"gifu.jp":true,"gunma.jp":true,"hiroshima.jp":true,"hokkaido.jp":true,"hyogo.jp":true,"ibaraki.jp":true,"ishikawa.jp":true,"iwate.jp":true,"kagawa.jp":true,"kagoshima.jp":true,"kanagawa.jp":true,"kochi.jp":true,"kumamoto.jp":true,"kyoto.jp":true,"mie.jp":true,"miyagi.jp":true,"miyazaki.jp":true,"nagano.jp":true,"nagasaki.jp":true,"nara.jp":true,"niigata.jp":true,"oita.jp":true,"okayama.jp":true,"okinawa.jp":true,"osaka.jp":true,"saga.jp":true,"saitama.jp":true,"shiga.jp":true,"shimane.jp":true,"shizuoka.jp":true,"tochigi.jp":true,"tokushima.jp":true,"tokyo.jp":true,"tottori.jp":true,"toyama.jp":true,"wakayama.jp":true,"yamagata.jp":true,"yamaguchi.jp":true,"yamanashi.jp":true,"xn--4pvxs.jp":true,"xn--vgu402c.jp":true,"xn--c3s14m.jp":true,"xn--f6qx53a.jp":true,"xn--8pvr4u.jp":true,"xn--uist22h.jp":true,"xn--djrs72d6uy.jp":true,"xn--mkru45i.jp":true,"xn--0trq7p7nn.jp":true,"xn--8ltr62k.jp":true,"xn--2m4a15e.jp":true,"xn--efvn9s.jp":true,"xn--32vp30h.jp":true,"xn--4it797k.jp":true,"xn--1lqs71d.jp":true,"xn--5rtp49c.jp":true,"xn--5js045d.jp":true,"xn--ehqz56n.jp":true,"xn--1lqs03n.jp":true,"xn--qqqt11m.jp":true,"xn--kbrq7o.jp":true,"xn--pssu33l.jp":true,"xn--ntsq17g.jp":true,"xn--uisz3g.jp":true,"xn--6btw5a.jp":true,"xn--1ctwo.jp":true,"xn--6orx2r.jp":true,"xn--rht61e.jp":true,"xn--rht27z.jp":true,"xn--djty4k.jp":true,"xn--nit225k.jp":true,"xn--rht3d.jp":true,"xn--klty5x.jp":true,"xn--kltx9a.jp":true,"xn--kltp7d.jp":true,"xn--uuwu58a.jp":true,"xn--zbx025d.jp":true,"xn--ntso0iqx3a.jp":true,"xn--elqq16h.jp":true,"xn--4it168d.jp":true,"xn--klt787d.jp":true,"xn--rny31h.jp":true,"xn--7t0a264c.jp":true,"xn--5rtq34k.jp":true,"xn--k7yn95e.jp":true,"xn--tor131o.jp":true,"xn--d5qv7z876c.jp":true,"*.kawasaki.jp":true,"*.kitakyushu.jp":true,"*.kobe.jp":true,"*.nagoya.jp":true,"*.sapporo.jp":true,"*.sendai.jp":true,"*.yokohama.jp":true,"city.kawasaki.jp":false,"city.kitakyushu.jp":false,"city.kobe.jp":false,"city.nagoya.jp":false,"city.sapporo.jp":false,"city.sendai.jp":false,"city.yokohama.jp":false,"aisai.aichi.jp":true,"ama.aichi.jp":true,"anjo.aichi.jp":true,"asuke.aichi.jp":true,"chiryu.aichi.jp":true,"chita.aichi.jp":true,"fuso.aichi.jp":true,"gamagori.aichi.jp":true,"handa.aichi.jp":true,"hazu.aichi.jp":true,"hekinan.aichi.jp":true,"higashiura.aichi.jp":true,"ichinomiya.aichi.jp":true,"inazawa.aichi.jp":true,"inuyama.aichi.jp":true,"isshiki.aichi.jp":true,"iwakura.aichi.jp":true,"kanie.aichi.jp":true,"kariya.aichi.jp":true,"kasugai.aichi.jp":true,"kira.aichi.jp":true,"kiyosu.aichi.jp":true,"komaki.aichi.jp":true,"konan.aichi.jp":true,"kota.aichi.jp":true,"mihama.aichi.jp":true,"miyoshi.aichi.jp":true,"nishio.aichi.jp":true,"nisshin.aichi.jp":true,"obu.aichi.jp":true,"oguchi.aichi.jp":true,"oharu.aichi.jp":true,"okazaki.aichi.jp":true,"owariasahi.aichi.jp":true,"seto.aichi.jp":true,"shikatsu.aichi.jp":true,"shinshiro.aichi.jp":true,"shitara.aichi.jp":true,"tahara.aichi.jp":true,"takahama.aichi.jp":true,"tobishima.aichi.jp":true,"toei.aichi.jp":true,"togo.aichi.jp":true,"tokai.aichi.jp":true,"tokoname.aichi.jp":true,"toyoake.aichi.jp":true,"toyohashi.aichi.jp":true,"toyokawa.aichi.jp":true,"toyone.aichi.jp":true,"toyota.aichi.jp":true,"tsushima.aichi.jp":true,"yatomi.aichi.jp":true,"akita.akita.jp":true,"daisen.akita.jp":true,"fujisato.akita.jp":true,"gojome.akita.jp":true,"hachirogata.akita.jp":true,"happou.akita.jp":true,"higashinaruse.akita.jp":true,"honjo.akita.jp":true,"honjyo.akita.jp":true,"ikawa.akita.jp":true,"kamikoani.akita.jp":true,"kamioka.akita.jp":true,"katagami.akita.jp":true,"kazuno.akita.jp":true,"kitaakita.akita.jp":true,"kosaka.akita.jp":true,"kyowa.akita.jp":true,"misato.akita.jp":true,"mitane.akita.jp":true,"moriyoshi.akita.jp":true,"nikaho.akita.jp":true,"noshiro.akita.jp":true,"odate.akita.jp":true,"oga.akita.jp":true,"ogata.akita.jp":true,"semboku.akita.jp":true,"yokote.akita.jp":true,"yurihonjo.akita.jp":true,"aomori.aomori.jp":true,"gonohe.aomori.jp":true,"hachinohe.aomori.jp":true,"hashikami.aomori.jp":true,"hiranai.aomori.jp":true,"hirosaki.aomori.jp":true,"itayanagi.aomori.jp":true,"kuroishi.aomori.jp":true,"misawa.aomori.jp":true,"mutsu.aomori.jp":true,"nakadomari.aomori.jp":true,"noheji.aomori.jp":true,"oirase.aomori.jp":true,"owani.aomori.jp":true,"rokunohe.aomori.jp":true,"sannohe.aomori.jp":true,"shichinohe.aomori.jp":true,"shingo.aomori.jp":true,"takko.aomori.jp":true,"towada.aomori.jp":true,"tsugaru.aomori.jp":true,"tsuruta.aomori.jp":true,"abiko.chiba.jp":true,"asahi.chiba.jp":true,"chonan.chiba.jp":true,"chosei.chiba.jp":true,"choshi.chiba.jp":true,"chuo.chiba.jp":true,"funabashi.chiba.jp":true,"futtsu.chiba.jp":true,"hanamigawa.chiba.jp":true,"ichihara.chiba.jp":true,"ichikawa.chiba.jp":true,"ichinomiya.chiba.jp":true,"inzai.chiba.jp":true,"isumi.chiba.jp":true,"kamagaya.chiba.jp":true,"kamogawa.chiba.jp":true,"kashiwa.chiba.jp":true,"katori.chiba.jp":true,"katsuura.chiba.jp":true,"kimitsu.chiba.jp":true,"kisarazu.chiba.jp":true,"kozaki.chiba.jp":true,"kujukuri.chiba.jp":true,"kyonan.chiba.jp":true,"matsudo.chiba.jp":true,"midori.chiba.jp":true,"mihama.chiba.jp":true,"minamiboso.chiba.jp":true,"mobara.chiba.jp":true,"mutsuzawa.chiba.jp":true,"nagara.chiba.jp":true,"nagareyama.chiba.jp":true,"narashino.chiba.jp":true,"narita.chiba.jp":true,"noda.chiba.jp":true,"oamishirasato.chiba.jp":true,"omigawa.chiba.jp":true,"onjuku.chiba.jp":true,"otaki.chiba.jp":true,"sakae.chiba.jp":true,"sakura.chiba.jp":true,"shimofusa.chiba.jp":true,"shirako.chiba.jp":true,"shiroi.chiba.jp":true,"shisui.chiba.jp":true,"sodegaura.chiba.jp":true,"sosa.chiba.jp":true,"tako.chiba.jp":true,"tateyama.chiba.jp":true,"togane.chiba.jp":true,"tohnosho.chiba.jp":true,"tomisato.chiba.jp":true,"urayasu.chiba.jp":true,"yachimata.chiba.jp":true,"yachiyo.chiba.jp":true,"yokaichiba.chiba.jp":true,"yokoshibahikari.chiba.jp":true,"yotsukaido.chiba.jp":true,"ainan.ehime.jp":true,"honai.ehime.jp":true,"ikata.ehime.jp":true,"imabari.ehime.jp":true,"iyo.ehime.jp":true,"kamijima.ehime.jp":true,"kihoku.ehime.jp":true,"kumakogen.ehime.jp":true,"masaki.ehime.jp":true,"matsuno.ehime.jp":true,"matsuyama.ehime.jp":true,"namikata.ehime.jp":true,"niihama.ehime.jp":true,"ozu.ehime.jp":true,"saijo.ehime.jp":true,"seiyo.ehime.jp":true,"shikokuchuo.ehime.jp":true,"tobe.ehime.jp":true,"toon.ehime.jp":true,"uchiko.ehime.jp":true,"uwajima.ehime.jp":true,"yawatahama.ehime.jp":true,"echizen.fukui.jp":true,"eiheiji.fukui.jp":true,"fukui.fukui.jp":true,"ikeda.fukui.jp":true,"katsuyama.fukui.jp":true,"mihama.fukui.jp":true,"minamiechizen.fukui.jp":true,"obama.fukui.jp":true,"ohi.fukui.jp":true,"ono.fukui.jp":true,"sabae.fukui.jp":true,"sakai.fukui.jp":true,"takahama.fukui.jp":true,"tsuruga.fukui.jp":true,"wakasa.fukui.jp":true,"ashiya.fukuoka.jp":true,"buzen.fukuoka.jp":true,"chikugo.fukuoka.jp":true,"chikuho.fukuoka.jp":true,"chikujo.fukuoka.jp":true,"chikushino.fukuoka.jp":true,"chikuzen.fukuoka.jp":true,"chuo.fukuoka.jp":true,"dazaifu.fukuoka.jp":true,"fukuchi.fukuoka.jp":true,"hakata.fukuoka.jp":true,"higashi.fukuoka.jp":true,"hirokawa.fukuoka.jp":true,"hisayama.fukuoka.jp":true,"iizuka.fukuoka.jp":true,"inatsuki.fukuoka.jp":true,"kaho.fukuoka.jp":true,"kasuga.fukuoka.jp":true,"kasuya.fukuoka.jp":true,"kawara.fukuoka.jp":true,"keisen.fukuoka.jp":true,"koga.fukuoka.jp":true,"kurate.fukuoka.jp":true,"kurogi.fukuoka.jp":true,"kurume.fukuoka.jp":true,"minami.fukuoka.jp":true,"miyako.fukuoka.jp":true,"miyama.fukuoka.jp":true,"miyawaka.fukuoka.jp":true,"mizumaki.fukuoka.jp":true,"munakata.fukuoka.jp":true,"nakagawa.fukuoka.jp":true,"nakama.fukuoka.jp":true,"nishi.fukuoka.jp":true,"nogata.fukuoka.jp":true,"ogori.fukuoka.jp":true,"okagaki.fukuoka.jp":true,"okawa.fukuoka.jp":true,"oki.fukuoka.jp":true,"omuta.fukuoka.jp":true,"onga.fukuoka.jp":true,"onojo.fukuoka.jp":true,"oto.fukuoka.jp":true,"saigawa.fukuoka.jp":true,"sasaguri.fukuoka.jp":true,"shingu.fukuoka.jp":true,"shinyoshitomi.fukuoka.jp":true,"shonai.fukuoka.jp":true,"soeda.fukuoka.jp":true,"sue.fukuoka.jp":true,"tachiarai.fukuoka.jp":true,"tagawa.fukuoka.jp":true,"takata.fukuoka.jp":true,"toho.fukuoka.jp":true,"toyotsu.fukuoka.jp":true,"tsuiki.fukuoka.jp":true,"ukiha.fukuoka.jp":true,"umi.fukuoka.jp":true,"usui.fukuoka.jp":true,"yamada.fukuoka.jp":true,"yame.fukuoka.jp":true,"yanagawa.fukuoka.jp":true,"yukuhashi.fukuoka.jp":true,"aizubange.fukushima.jp":true,"aizumisato.fukushima.jp":true,"aizuwakamatsu.fukushima.jp":true,"asakawa.fukushima.jp":true,"bandai.fukushima.jp":true,"date.fukushima.jp":true,"fukushima.fukushima.jp":true,"furudono.fukushima.jp":true,"futaba.fukushima.jp":true,"hanawa.fukushima.jp":true,"higashi.fukushima.jp":true,"hirata.fukushima.jp":true,"hirono.fukushima.jp":true,"iitate.fukushima.jp":true,"inawashiro.fukushima.jp":true,"ishikawa.fukushima.jp":true,"iwaki.fukushima.jp":true,"izumizaki.fukushima.jp":true,"kagamiishi.fukushima.jp":true,"kaneyama.fukushima.jp":true,"kawamata.fukushima.jp":true,"kitakata.fukushima.jp":true,"kitashiobara.fukushima.jp":true,"koori.fukushima.jp":true,"koriyama.fukushima.jp":true,"kunimi.fukushima.jp":true,"miharu.fukushima.jp":true,"mishima.fukushima.jp":true,"namie.fukushima.jp":true,"nango.fukushima.jp":true,"nishiaizu.fukushima.jp":true,"nishigo.fukushima.jp":true,"okuma.fukushima.jp":true,"omotego.fukushima.jp":true,"ono.fukushima.jp":true,"otama.fukushima.jp":true,"samegawa.fukushima.jp":true,"shimogo.fukushima.jp":true,"shirakawa.fukushima.jp":true,"showa.fukushima.jp":true,"soma.fukushima.jp":true,"sukagawa.fukushima.jp":true,"taishin.fukushima.jp":true,"tamakawa.fukushima.jp":true,"tanagura.fukushima.jp":true,"tenei.fukushima.jp":true,"yabuki.fukushima.jp":true,"yamato.fukushima.jp":true,"yamatsuri.fukushima.jp":true,"yanaizu.fukushima.jp":true,"yugawa.fukushima.jp":true,"anpachi.gifu.jp":true,"ena.gifu.jp":true,"gifu.gifu.jp":true,"ginan.gifu.jp":true,"godo.gifu.jp":true,"gujo.gifu.jp":true,"hashima.gifu.jp":true,"hichiso.gifu.jp":true,"hida.gifu.jp":true,"higashishirakawa.gifu.jp":true,"ibigawa.gifu.jp":true,"ikeda.gifu.jp":true,"kakamigahara.gifu.jp":true,"kani.gifu.jp":true,"kasahara.gifu.jp":true,"kasamatsu.gifu.jp":true,"kawaue.gifu.jp":true,"kitagata.gifu.jp":true,"mino.gifu.jp":true,"minokamo.gifu.jp":true,"mitake.gifu.jp":true,"mizunami.gifu.jp":true,"motosu.gifu.jp":true,"nakatsugawa.gifu.jp":true,"ogaki.gifu.jp":true,"sakahogi.gifu.jp":true,"seki.gifu.jp":true,"sekigahara.gifu.jp":true,"shirakawa.gifu.jp":true,"tajimi.gifu.jp":true,"takayama.gifu.jp":true,"tarui.gifu.jp":true,"toki.gifu.jp":true,"tomika.gifu.jp":true,"wanouchi.gifu.jp":true,"yamagata.gifu.jp":true,"yaotsu.gifu.jp":true,"yoro.gifu.jp":true,"annaka.gunma.jp":true,"chiyoda.gunma.jp":true,"fujioka.gunma.jp":true,"higashiagatsuma.gunma.jp":true,"isesaki.gunma.jp":true,"itakura.gunma.jp":true,"kanna.gunma.jp":true,"kanra.gunma.jp":true,"katashina.gunma.jp":true,"kawaba.gunma.jp":true,"kiryu.gunma.jp":true,"kusatsu.gunma.jp":true,"maebashi.gunma.jp":true,"meiwa.gunma.jp":true,"midori.gunma.jp":true,"minakami.gunma.jp":true,"naganohara.gunma.jp":true,"nakanojo.gunma.jp":true,"nanmoku.gunma.jp":true,"numata.gunma.jp":true,"oizumi.gunma.jp":true,"ora.gunma.jp":true,"ota.gunma.jp":true,"shibukawa.gunma.jp":true,"shimonita.gunma.jp":true,"shinto.gunma.jp":true,"showa.gunma.jp":true,"takasaki.gunma.jp":true,"takayama.gunma.jp":true,"tamamura.gunma.jp":true,"tatebayashi.gunma.jp":true,"tomioka.gunma.jp":true,"tsukiyono.gunma.jp":true,"tsumagoi.gunma.jp":true,"ueno.gunma.jp":true,"yoshioka.gunma.jp":true,"asaminami.hiroshima.jp":true,"daiwa.hiroshima.jp":true,"etajima.hiroshima.jp":true,"fuchu.hiroshima.jp":true,"fukuyama.hiroshima.jp":true,"hatsukaichi.hiroshima.jp":true,"higashihiroshima.hiroshima.jp":true,"hongo.hiroshima.jp":true,"jinsekikogen.hiroshima.jp":true,"kaita.hiroshima.jp":true,"kui.hiroshima.jp":true,"kumano.hiroshima.jp":true,"kure.hiroshima.jp":true,"mihara.hiroshima.jp":true,"miyoshi.hiroshima.jp":true,"naka.hiroshima.jp":true,"onomichi.hiroshima.jp":true,"osakikamijima.hiroshima.jp":true,"otake.hiroshima.jp":true,"saka.hiroshima.jp":true,"sera.hiroshima.jp":true,"seranishi.hiroshima.jp":true,"shinichi.hiroshima.jp":true,"shobara.hiroshima.jp":true,"takehara.hiroshima.jp":true,"abashiri.hokkaido.jp":true,"abira.hokkaido.jp":true,"aibetsu.hokkaido.jp":true,"akabira.hokkaido.jp":true,"akkeshi.hokkaido.jp":true,"asahikawa.hokkaido.jp":true,"ashibetsu.hokkaido.jp":true,"ashoro.hokkaido.jp":true,"assabu.hokkaido.jp":true,"atsuma.hokkaido.jp":true,"bibai.hokkaido.jp":true,"biei.hokkaido.jp":true,"bifuka.hokkaido.jp":true,"bihoro.hokkaido.jp":true,"biratori.hokkaido.jp":true,"chippubetsu.hokkaido.jp":true,"chitose.hokkaido.jp":true,"date.hokkaido.jp":true,"ebetsu.hokkaido.jp":true,"embetsu.hokkaido.jp":true,"eniwa.hokkaido.jp":true,"erimo.hokkaido.jp":true,"esan.hokkaido.jp":true,"esashi.hokkaido.jp":true,"fukagawa.hokkaido.jp":true,"fukushima.hokkaido.jp":true,"furano.hokkaido.jp":true,"furubira.hokkaido.jp":true,"haboro.hokkaido.jp":true,"hakodate.hokkaido.jp":true,"hamatonbetsu.hokkaido.jp":true,"hidaka.hokkaido.jp":true,"higashikagura.hokkaido.jp":true,"higashikawa.hokkaido.jp":true,"hiroo.hokkaido.jp":true,"hokuryu.hokkaido.jp":true,"hokuto.hokkaido.jp":true,"honbetsu.hokkaido.jp":true,"horokanai.hokkaido.jp":true,"horonobe.hokkaido.jp":true,"ikeda.hokkaido.jp":true,"imakane.hokkaido.jp":true,"ishikari.hokkaido.jp":true,"iwamizawa.hokkaido.jp":true,"iwanai.hokkaido.jp":true,"kamifurano.hokkaido.jp":true,"kamikawa.hokkaido.jp":true,"kamishihoro.hokkaido.jp":true,"kamisunagawa.hokkaido.jp":true,"kamoenai.hokkaido.jp":true,"kayabe.hokkaido.jp":true,"kembuchi.hokkaido.jp":true,"kikonai.hokkaido.jp":true,"kimobetsu.hokkaido.jp":true,"kitahiroshima.hokkaido.jp":true,"kitami.hokkaido.jp":true,"kiyosato.hokkaido.jp":true,"koshimizu.hokkaido.jp":true,"kunneppu.hokkaido.jp":true,"kuriyama.hokkaido.jp":true,"kuromatsunai.hokkaido.jp":true,"kushiro.hokkaido.jp":true,"kutchan.hokkaido.jp":true,"kyowa.hokkaido.jp":true,"mashike.hokkaido.jp":true,"matsumae.hokkaido.jp":true,"mikasa.hokkaido.jp":true,"minamifurano.hokkaido.jp":true,"mombetsu.hokkaido.jp":true,"moseushi.hokkaido.jp":true,"mukawa.hokkaido.jp":true,"muroran.hokkaido.jp":true,"naie.hokkaido.jp":true,"nakagawa.hokkaido.jp":true,"nakasatsunai.hokkaido.jp":true,"nakatombetsu.hokkaido.jp":true,"nanae.hokkaido.jp":true,"nanporo.hokkaido.jp":true,"nayoro.hokkaido.jp":true,"nemuro.hokkaido.jp":true,"niikappu.hokkaido.jp":true,"niki.hokkaido.jp":true,"nishiokoppe.hokkaido.jp":true,"noboribetsu.hokkaido.jp":true,"numata.hokkaido.jp":true,"obihiro.hokkaido.jp":true,"obira.hokkaido.jp":true,"oketo.hokkaido.jp":true,"okoppe.hokkaido.jp":true,"otaru.hokkaido.jp":true,"otobe.hokkaido.jp":true,"otofuke.hokkaido.jp":true,"otoineppu.hokkaido.jp":true,"oumu.hokkaido.jp":true,"ozora.hokkaido.jp":true,"pippu.hokkaido.jp":true,"rankoshi.hokkaido.jp":true,"rebun.hokkaido.jp":true,"rikubetsu.hokkaido.jp":true,"rishiri.hokkaido.jp":true,"rishirifuji.hokkaido.jp":true,"saroma.hokkaido.jp":true,"sarufutsu.hokkaido.jp":true,"shakotan.hokkaido.jp":true,"shari.hokkaido.jp":true,"shibecha.hokkaido.jp":true,"shibetsu.hokkaido.jp":true,"shikabe.hokkaido.jp":true,"shikaoi.hokkaido.jp":true,"shimamaki.hokkaido.jp":true,"shimizu.hokkaido.jp":true,"shimokawa.hokkaido.jp":true,"shinshinotsu.hokkaido.jp":true,"shintoku.hokkaido.jp":true,"shiranuka.hokkaido.jp":true,"shiraoi.hokkaido.jp":true,"shiriuchi.hokkaido.jp":true,"sobetsu.hokkaido.jp":true,"sunagawa.hokkaido.jp":true,"taiki.hokkaido.jp":true,"takasu.hokkaido.jp":true,"takikawa.hokkaido.jp":true,"takinoue.hokkaido.jp":true,"teshikaga.hokkaido.jp":true,"tobetsu.hokkaido.jp":true,"tohma.hokkaido.jp":true,"tomakomai.hokkaido.jp":true,"tomari.hokkaido.jp":true,"toya.hokkaido.jp":true,"toyako.hokkaido.jp":true,"toyotomi.hokkaido.jp":true,"toyoura.hokkaido.jp":true,"tsubetsu.hokkaido.jp":true,"tsukigata.hokkaido.jp":true,"urakawa.hokkaido.jp":true,"urausu.hokkaido.jp":true,"uryu.hokkaido.jp":true,"utashinai.hokkaido.jp":true,"wakkanai.hokkaido.jp":true,"wassamu.hokkaido.jp":true,"yakumo.hokkaido.jp":true,"yoichi.hokkaido.jp":true,"aioi.hyogo.jp":true,"akashi.hyogo.jp":true,"ako.hyogo.jp":true,"amagasaki.hyogo.jp":true,"aogaki.hyogo.jp":true,"asago.hyogo.jp":true,"ashiya.hyogo.jp":true,"awaji.hyogo.jp":true,"fukusaki.hyogo.jp":true,"goshiki.hyogo.jp":true,"harima.hyogo.jp":true,"himeji.hyogo.jp":true,"ichikawa.hyogo.jp":true,"inagawa.hyogo.jp":true,"itami.hyogo.jp":true,"kakogawa.hyogo.jp":true,"kamigori.hyogo.jp":true,"kamikawa.hyogo.jp":true,"kasai.hyogo.jp":true,"kasuga.hyogo.jp":true,"kawanishi.hyogo.jp":true,"miki.hyogo.jp":true,"minamiawaji.hyogo.jp":true,"nishinomiya.hyogo.jp":true,"nishiwaki.hyogo.jp":true,"ono.hyogo.jp":true,"sanda.hyogo.jp":true,"sannan.hyogo.jp":true,"sasayama.hyogo.jp":true,"sayo.hyogo.jp":true,"shingu.hyogo.jp":true,"shinonsen.hyogo.jp":true,"shiso.hyogo.jp":true,"sumoto.hyogo.jp":true,"taishi.hyogo.jp":true,"taka.hyogo.jp":true,"takarazuka.hyogo.jp":true,"takasago.hyogo.jp":true,"takino.hyogo.jp":true,"tamba.hyogo.jp":true,"tatsuno.hyogo.jp":true,"toyooka.hyogo.jp":true,"yabu.hyogo.jp":true,"yashiro.hyogo.jp":true,"yoka.hyogo.jp":true,"yokawa.hyogo.jp":true,"ami.ibaraki.jp":true,"asahi.ibaraki.jp":true,"bando.ibaraki.jp":true,"chikusei.ibaraki.jp":true,"daigo.ibaraki.jp":true,"fujishiro.ibaraki.jp":true,"hitachi.ibaraki.jp":true,"hitachinaka.ibaraki.jp":true,"hitachiomiya.ibaraki.jp":true,"hitachiota.ibaraki.jp":true,"ibaraki.ibaraki.jp":true,"ina.ibaraki.jp":true,"inashiki.ibaraki.jp":true,"itako.ibaraki.jp":true,"iwama.ibaraki.jp":true,"joso.ibaraki.jp":true,"kamisu.ibaraki.jp":true,"kasama.ibaraki.jp":true,"kashima.ibaraki.jp":true,"kasumigaura.ibaraki.jp":true,"koga.ibaraki.jp":true,"miho.ibaraki.jp":true,"mito.ibaraki.jp":true,"moriya.ibaraki.jp":true,"naka.ibaraki.jp":true,"namegata.ibaraki.jp":true,"oarai.ibaraki.jp":true,"ogawa.ibaraki.jp":true,"omitama.ibaraki.jp":true,"ryugasaki.ibaraki.jp":true,"sakai.ibaraki.jp":true,"sakuragawa.ibaraki.jp":true,"shimodate.ibaraki.jp":true,"shimotsuma.ibaraki.jp":true,"shirosato.ibaraki.jp":true,"sowa.ibaraki.jp":true,"suifu.ibaraki.jp":true,"takahagi.ibaraki.jp":true,"tamatsukuri.ibaraki.jp":true,"tokai.ibaraki.jp":true,"tomobe.ibaraki.jp":true,"tone.ibaraki.jp":true,"toride.ibaraki.jp":true,"tsuchiura.ibaraki.jp":true,"tsukuba.ibaraki.jp":true,"uchihara.ibaraki.jp":true,"ushiku.ibaraki.jp":true,"yachiyo.ibaraki.jp":true,"yamagata.ibaraki.jp":true,"yawara.ibaraki.jp":true,"yuki.ibaraki.jp":true,"anamizu.ishikawa.jp":true,"hakui.ishikawa.jp":true,"hakusan.ishikawa.jp":true,"kaga.ishikawa.jp":true,"kahoku.ishikawa.jp":true,"kanazawa.ishikawa.jp":true,"kawakita.ishikawa.jp":true,"komatsu.ishikawa.jp":true,"nakanoto.ishikawa.jp":true,"nanao.ishikawa.jp":true,"nomi.ishikawa.jp":true,"nonoichi.ishikawa.jp":true,"noto.ishikawa.jp":true,"shika.ishikawa.jp":true,"suzu.ishikawa.jp":true,"tsubata.ishikawa.jp":true,"tsurugi.ishikawa.jp":true,"uchinada.ishikawa.jp":true,"wajima.ishikawa.jp":true,"fudai.iwate.jp":true,"fujisawa.iwate.jp":true,"hanamaki.iwate.jp":true,"hiraizumi.iwate.jp":true,"hirono.iwate.jp":true,"ichinohe.iwate.jp":true,"ichinoseki.iwate.jp":true,"iwaizumi.iwate.jp":true,"iwate.iwate.jp":true,"joboji.iwate.jp":true,"kamaishi.iwate.jp":true,"kanegasaki.iwate.jp":true,"karumai.iwate.jp":true,"kawai.iwate.jp":true,"kitakami.iwate.jp":true,"kuji.iwate.jp":true,"kunohe.iwate.jp":true,"kuzumaki.iwate.jp":true,"miyako.iwate.jp":true,"mizusawa.iwate.jp":true,"morioka.iwate.jp":true,"ninohe.iwate.jp":true,"noda.iwate.jp":true,"ofunato.iwate.jp":true,"oshu.iwate.jp":true,"otsuchi.iwate.jp":true,"rikuzentakata.iwate.jp":true,"shiwa.iwate.jp":true,"shizukuishi.iwate.jp":true,"sumita.iwate.jp":true,"tanohata.iwate.jp":true,"tono.iwate.jp":true,"yahaba.iwate.jp":true,"yamada.iwate.jp":true,"ayagawa.kagawa.jp":true,"higashikagawa.kagawa.jp":true,"kanonji.kagawa.jp":true,"kotohira.kagawa.jp":true,"manno.kagawa.jp":true,"marugame.kagawa.jp":true,"mitoyo.kagawa.jp":true,"naoshima.kagawa.jp":true,"sanuki.kagawa.jp":true,"tadotsu.kagawa.jp":true,"takamatsu.kagawa.jp":true,"tonosho.kagawa.jp":true,"uchinomi.kagawa.jp":true,"utazu.kagawa.jp":true,"zentsuji.kagawa.jp":true,"akune.kagoshima.jp":true,"amami.kagoshima.jp":true,"hioki.kagoshima.jp":true,"isa.kagoshima.jp":true,"isen.kagoshima.jp":true,"izumi.kagoshima.jp":true,"kagoshima.kagoshima.jp":true,"kanoya.kagoshima.jp":true,"kawanabe.kagoshima.jp":true,"kinko.kagoshima.jp":true,"kouyama.kagoshima.jp":true,"makurazaki.kagoshima.jp":true,"matsumoto.kagoshima.jp":true,"minamitane.kagoshima.jp":true,"nakatane.kagoshima.jp":true,"nishinoomote.kagoshima.jp":true,"satsumasendai.kagoshima.jp":true,"soo.kagoshima.jp":true,"tarumizu.kagoshima.jp":true,"yusui.kagoshima.jp":true,"aikawa.kanagawa.jp":true,"atsugi.kanagawa.jp":true,"ayase.kanagawa.jp":true,"chigasaki.kanagawa.jp":true,"ebina.kanagawa.jp":true,"fujisawa.kanagawa.jp":true,"hadano.kanagawa.jp":true,"hakone.kanagawa.jp":true,"hiratsuka.kanagawa.jp":true,"isehara.kanagawa.jp":true,"kaisei.kanagawa.jp":true,"kamakura.kanagawa.jp":true,"kiyokawa.kanagawa.jp":true,"matsuda.kanagawa.jp":true,"minamiashigara.kanagawa.jp":true,"miura.kanagawa.jp":true,"nakai.kanagawa.jp":true,"ninomiya.kanagawa.jp":true,"odawara.kanagawa.jp":true,"oi.kanagawa.jp":true,"oiso.kanagawa.jp":true,"sagamihara.kanagawa.jp":true,"samukawa.kanagawa.jp":true,"tsukui.kanagawa.jp":true,"yamakita.kanagawa.jp":true,"yamato.kanagawa.jp":true,"yokosuka.kanagawa.jp":true,"yugawara.kanagawa.jp":true,"zama.kanagawa.jp":true,"zushi.kanagawa.jp":true,"aki.kochi.jp":true,"geisei.kochi.jp":true,"hidaka.kochi.jp":true,"higashitsuno.kochi.jp":true,"ino.kochi.jp":true,"kagami.kochi.jp":true,"kami.kochi.jp":true,"kitagawa.kochi.jp":true,"kochi.kochi.jp":true,"mihara.kochi.jp":true,"motoyama.kochi.jp":true,"muroto.kochi.jp":true,"nahari.kochi.jp":true,"nakamura.kochi.jp":true,"nankoku.kochi.jp":true,"nishitosa.kochi.jp":true,"niyodogawa.kochi.jp":true,"ochi.kochi.jp":true,"okawa.kochi.jp":true,"otoyo.kochi.jp":true,"otsuki.kochi.jp":true,"sakawa.kochi.jp":true,"sukumo.kochi.jp":true,"susaki.kochi.jp":true,"tosa.kochi.jp":true,"tosashimizu.kochi.jp":true,"toyo.kochi.jp":true,"tsuno.kochi.jp":true,"umaji.kochi.jp":true,"yasuda.kochi.jp":true,"yusuhara.kochi.jp":true,"amakusa.kumamoto.jp":true,"arao.kumamoto.jp":true,"aso.kumamoto.jp":true,"choyo.kumamoto.jp":true,"gyokuto.kumamoto.jp":true,"hitoyoshi.kumamoto.jp":true,"kamiamakusa.kumamoto.jp":true,"kashima.kumamoto.jp":true,"kikuchi.kumamoto.jp":true,"kosa.kumamoto.jp":true,"kumamoto.kumamoto.jp":true,"mashiki.kumamoto.jp":true,"mifune.kumamoto.jp":true,"minamata.kumamoto.jp":true,"minamioguni.kumamoto.jp":true,"nagasu.kumamoto.jp":true,"nishihara.kumamoto.jp":true,"oguni.kumamoto.jp":true,"ozu.kumamoto.jp":true,"sumoto.kumamoto.jp":true,"takamori.kumamoto.jp":true,"uki.kumamoto.jp":true,"uto.kumamoto.jp":true,"yamaga.kumamoto.jp":true,"yamato.kumamoto.jp":true,"yatsushiro.kumamoto.jp":true,"ayabe.kyoto.jp":true,"fukuchiyama.kyoto.jp":true,"higashiyama.kyoto.jp":true,"ide.kyoto.jp":true,"ine.kyoto.jp":true,"joyo.kyoto.jp":true,"kameoka.kyoto.jp":true,"kamo.kyoto.jp":true,"kita.kyoto.jp":true,"kizu.kyoto.jp":true,"kumiyama.kyoto.jp":true,"kyotamba.kyoto.jp":true,"kyotanabe.kyoto.jp":true,"kyotango.kyoto.jp":true,"maizuru.kyoto.jp":true,"minami.kyoto.jp":true,"minamiyamashiro.kyoto.jp":true,"miyazu.kyoto.jp":true,"muko.kyoto.jp":true,"nagaokakyo.kyoto.jp":true,"nakagyo.kyoto.jp":true,"nantan.kyoto.jp":true,"oyamazaki.kyoto.jp":true,"sakyo.kyoto.jp":true,"seika.kyoto.jp":true,"tanabe.kyoto.jp":true,"uji.kyoto.jp":true,"ujitawara.kyoto.jp":true,"wazuka.kyoto.jp":true,"yamashina.kyoto.jp":true,"yawata.kyoto.jp":true,"asahi.mie.jp":true,"inabe.mie.jp":true,"ise.mie.jp":true,"kameyama.mie.jp":true,"kawagoe.mie.jp":true,"kiho.mie.jp":true,"kisosaki.mie.jp":true,"kiwa.mie.jp":true,"komono.mie.jp":true,"kumano.mie.jp":true,"kuwana.mie.jp":true,"matsusaka.mie.jp":true,"meiwa.mie.jp":true,"mihama.mie.jp":true,"minamiise.mie.jp":true,"misugi.mie.jp":true,"miyama.mie.jp":true,"nabari.mie.jp":true,"shima.mie.jp":true,"suzuka.mie.jp":true,"tado.mie.jp":true,"taiki.mie.jp":true,"taki.mie.jp":true,"tamaki.mie.jp":true,"toba.mie.jp":true,"tsu.mie.jp":true,"udono.mie.jp":true,"ureshino.mie.jp":true,"watarai.mie.jp":true,"yokkaichi.mie.jp":true,"furukawa.miyagi.jp":true,"higashimatsushima.miyagi.jp":true,"ishinomaki.miyagi.jp":true,"iwanuma.miyagi.jp":true,"kakuda.miyagi.jp":true,"kami.miyagi.jp":true,"kawasaki.miyagi.jp":true,"kesennuma.miyagi.jp":true,"marumori.miyagi.jp":true,"matsushima.miyagi.jp":true,"minamisanriku.miyagi.jp":true,"misato.miyagi.jp":true,"murata.miyagi.jp":true,"natori.miyagi.jp":true,"ogawara.miyagi.jp":true,"ohira.miyagi.jp":true,"onagawa.miyagi.jp":true,"osaki.miyagi.jp":true,"rifu.miyagi.jp":true,"semine.miyagi.jp":true,"shibata.miyagi.jp":true,"shichikashuku.miyagi.jp":true,"shikama.miyagi.jp":true,"shiogama.miyagi.jp":true,"shiroishi.miyagi.jp":true,"tagajo.miyagi.jp":true,"taiwa.miyagi.jp":true,"tome.miyagi.jp":true,"tomiya.miyagi.jp":true,"wakuya.miyagi.jp":true,"watari.miyagi.jp":true,"yamamoto.miyagi.jp":true,"zao.miyagi.jp":true,"aya.miyazaki.jp":true,"ebino.miyazaki.jp":true,"gokase.miyazaki.jp":true,"hyuga.miyazaki.jp":true,"kadogawa.miyazaki.jp":true,"kawaminami.miyazaki.jp":true,"kijo.miyazaki.jp":true,"kitagawa.miyazaki.jp":true,"kitakata.miyazaki.jp":true,"kitaura.miyazaki.jp":true,"kobayashi.miyazaki.jp":true,"kunitomi.miyazaki.jp":true,"kushima.miyazaki.jp":true,"mimata.miyazaki.jp":true,"miyakonojo.miyazaki.jp":true,"miyazaki.miyazaki.jp":true,"morotsuka.miyazaki.jp":true,"nichinan.miyazaki.jp":true,"nishimera.miyazaki.jp":true,"nobeoka.miyazaki.jp":true,"saito.miyazaki.jp":true,"shiiba.miyazaki.jp":true,"shintomi.miyazaki.jp":true,"takaharu.miyazaki.jp":true,"takanabe.miyazaki.jp":true,"takazaki.miyazaki.jp":true,"tsuno.miyazaki.jp":true,"achi.nagano.jp":true,"agematsu.nagano.jp":true,"anan.nagano.jp":true,"aoki.nagano.jp":true,"asahi.nagano.jp":true,"azumino.nagano.jp":true,"chikuhoku.nagano.jp":true,"chikuma.nagano.jp":true,"chino.nagano.jp":true,"fujimi.nagano.jp":true,"hakuba.nagano.jp":true,"hara.nagano.jp":true,"hiraya.nagano.jp":true,"iida.nagano.jp":true,"iijima.nagano.jp":true,"iiyama.nagano.jp":true,"iizuna.nagano.jp":true,"ikeda.nagano.jp":true,"ikusaka.nagano.jp":true,"ina.nagano.jp":true,"karuizawa.nagano.jp":true,"kawakami.nagano.jp":true,"kiso.nagano.jp":true,"kisofukushima.nagano.jp":true,"kitaaiki.nagano.jp":true,"komagane.nagano.jp":true,"komoro.nagano.jp":true,"matsukawa.nagano.jp":true,"matsumoto.nagano.jp":true,"miasa.nagano.jp":true,"minamiaiki.nagano.jp":true,"minamimaki.nagano.jp":true,"minamiminowa.nagano.jp":true,"minowa.nagano.jp":true,"miyada.nagano.jp":true,"miyota.nagano.jp":true,"mochizuki.nagano.jp":true,"nagano.nagano.jp":true,"nagawa.nagano.jp":true,"nagiso.nagano.jp":true,"nakagawa.nagano.jp":true,"nakano.nagano.jp":true,"nozawaonsen.nagano.jp":true,"obuse.nagano.jp":true,"ogawa.nagano.jp":true,"okaya.nagano.jp":true,"omachi.nagano.jp":true,"omi.nagano.jp":true,"ookuwa.nagano.jp":true,"ooshika.nagano.jp":true,"otaki.nagano.jp":true,"otari.nagano.jp":true,"sakae.nagano.jp":true,"sakaki.nagano.jp":true,"saku.nagano.jp":true,"sakuho.nagano.jp":true,"shimosuwa.nagano.jp":true,"shinanomachi.nagano.jp":true,"shiojiri.nagano.jp":true,"suwa.nagano.jp":true,"suzaka.nagano.jp":true,"takagi.nagano.jp":true,"takamori.nagano.jp":true,"takayama.nagano.jp":true,"tateshina.nagano.jp":true,"tatsuno.nagano.jp":true,"togakushi.nagano.jp":true,"togura.nagano.jp":true,"tomi.nagano.jp":true,"ueda.nagano.jp":true,"wada.nagano.jp":true,"yamagata.nagano.jp":true,"yamanouchi.nagano.jp":true,"yasaka.nagano.jp":true,"yasuoka.nagano.jp":true,"chijiwa.nagasaki.jp":true,"futsu.nagasaki.jp":true,"goto.nagasaki.jp":true,"hasami.nagasaki.jp":true,"hirado.nagasaki.jp":true,"iki.nagasaki.jp":true,"isahaya.nagasaki.jp":true,"kawatana.nagasaki.jp":true,"kuchinotsu.nagasaki.jp":true,"matsuura.nagasaki.jp":true,"nagasaki.nagasaki.jp":true,"obama.nagasaki.jp":true,"omura.nagasaki.jp":true,"oseto.nagasaki.jp":true,"saikai.nagasaki.jp":true,"sasebo.nagasaki.jp":true,"seihi.nagasaki.jp":true,"shimabara.nagasaki.jp":true,"shinkamigoto.nagasaki.jp":true,"togitsu.nagasaki.jp":true,"tsushima.nagasaki.jp":true,"unzen.nagasaki.jp":true,"ando.nara.jp":true,"gose.nara.jp":true,"heguri.nara.jp":true,"higashiyoshino.nara.jp":true,"ikaruga.nara.jp":true,"ikoma.nara.jp":true,"kamikitayama.nara.jp":true,"kanmaki.nara.jp":true,"kashiba.nara.jp":true,"kashihara.nara.jp":true,"katsuragi.nara.jp":true,"kawai.nara.jp":true,"kawakami.nara.jp":true,"kawanishi.nara.jp":true,"koryo.nara.jp":true,"kurotaki.nara.jp":true,"mitsue.nara.jp":true,"miyake.nara.jp":true,"nara.nara.jp":true,"nosegawa.nara.jp":true,"oji.nara.jp":true,"ouda.nara.jp":true,"oyodo.nara.jp":true,"sakurai.nara.jp":true,"sango.nara.jp":true,"shimoichi.nara.jp":true,"shimokitayama.nara.jp":true,"shinjo.nara.jp":true,"soni.nara.jp":true,"takatori.nara.jp":true,"tawaramoto.nara.jp":true,"tenkawa.nara.jp":true,"tenri.nara.jp":true,"uda.nara.jp":true,"yamatokoriyama.nara.jp":true,"yamatotakada.nara.jp":true,"yamazoe.nara.jp":true,"yoshino.nara.jp":true,"aga.niigata.jp":true,"agano.niigata.jp":true,"gosen.niigata.jp":true,"itoigawa.niigata.jp":true,"izumozaki.niigata.jp":true,"joetsu.niigata.jp":true,"kamo.niigata.jp":true,"kariwa.niigata.jp":true,"kashiwazaki.niigata.jp":true,"minamiuonuma.niigata.jp":true,"mitsuke.niigata.jp":true,"muika.niigata.jp":true,"murakami.niigata.jp":true,"myoko.niigata.jp":true,"nagaoka.niigata.jp":true,"niigata.niigata.jp":true,"ojiya.niigata.jp":true,"omi.niigata.jp":true,"sado.niigata.jp":true,"sanjo.niigata.jp":true,"seiro.niigata.jp":true,"seirou.niigata.jp":true,"sekikawa.niigata.jp":true,"shibata.niigata.jp":true,"tagami.niigata.jp":true,"tainai.niigata.jp":true,"tochio.niigata.jp":true,"tokamachi.niigata.jp":true,"tsubame.niigata.jp":true,"tsunan.niigata.jp":true,"uonuma.niigata.jp":true,"yahiko.niigata.jp":true,"yoita.niigata.jp":true,"yuzawa.niigata.jp":true,"beppu.oita.jp":true,"bungoono.oita.jp":true,"bungotakada.oita.jp":true,"hasama.oita.jp":true,"hiji.oita.jp":true,"himeshima.oita.jp":true,"hita.oita.jp":true,"kamitsue.oita.jp":true,"kokonoe.oita.jp":true,"kuju.oita.jp":true,"kunisaki.oita.jp":true,"kusu.oita.jp":true,"oita.oita.jp":true,"saiki.oita.jp":true,"taketa.oita.jp":true,"tsukumi.oita.jp":true,"usa.oita.jp":true,"usuki.oita.jp":true,"yufu.oita.jp":true,"akaiwa.okayama.jp":true,"asakuchi.okayama.jp":true,"bizen.okayama.jp":true,"hayashima.okayama.jp":true,"ibara.okayama.jp":true,"kagamino.okayama.jp":true,"kasaoka.okayama.jp":true,"kibichuo.okayama.jp":true,"kumenan.okayama.jp":true,"kurashiki.okayama.jp":true,"maniwa.okayama.jp":true,"misaki.okayama.jp":true,"nagi.okayama.jp":true,"niimi.okayama.jp":true,"nishiawakura.okayama.jp":true,"okayama.okayama.jp":true,"satosho.okayama.jp":true,"setouchi.okayama.jp":true,"shinjo.okayama.jp":true,"shoo.okayama.jp":true,"soja.okayama.jp":true,"takahashi.okayama.jp":true,"tamano.okayama.jp":true,"tsuyama.okayama.jp":true,"wake.okayama.jp":true,"yakage.okayama.jp":true,"aguni.okinawa.jp":true,"ginowan.okinawa.jp":true,"ginoza.okinawa.jp":true,"gushikami.okinawa.jp":true,"haebaru.okinawa.jp":true,"higashi.okinawa.jp":true,"hirara.okinawa.jp":true,"iheya.okinawa.jp":true,"ishigaki.okinawa.jp":true,"ishikawa.okinawa.jp":true,"itoman.okinawa.jp":true,"izena.okinawa.jp":true,"kadena.okinawa.jp":true,"kin.okinawa.jp":true,"kitadaito.okinawa.jp":true,"kitanakagusuku.okinawa.jp":true,"kumejima.okinawa.jp":true,"kunigami.okinawa.jp":true,"minamidaito.okinawa.jp":true,"motobu.okinawa.jp":true,"nago.okinawa.jp":true,"naha.okinawa.jp":true,"nakagusuku.okinawa.jp":true,"nakijin.okinawa.jp":true,"nanjo.okinawa.jp":true,"nishihara.okinawa.jp":true,"ogimi.okinawa.jp":true,"okinawa.okinawa.jp":true,"onna.okinawa.jp":true,"shimoji.okinawa.jp":true,"taketomi.okinawa.jp":true,"tarama.okinawa.jp":true,"tokashiki.okinawa.jp":true,"tomigusuku.okinawa.jp":true,"tonaki.okinawa.jp":true,"urasoe.okinawa.jp":true,"uruma.okinawa.jp":true,"yaese.okinawa.jp":true,"yomitan.okinawa.jp":true,"yonabaru.okinawa.jp":true,"yonaguni.okinawa.jp":true,"zamami.okinawa.jp":true,"abeno.osaka.jp":true,"chihayaakasaka.osaka.jp":true,"chuo.osaka.jp":true,"daito.osaka.jp":true,"fujiidera.osaka.jp":true,"habikino.osaka.jp":true,"hannan.osaka.jp":true,"higashiosaka.osaka.jp":true,"higashisumiyoshi.osaka.jp":true,"higashiyodogawa.osaka.jp":true,"hirakata.osaka.jp":true,"ibaraki.osaka.jp":true,"ikeda.osaka.jp":true,"izumi.osaka.jp":true,"izumiotsu.osaka.jp":true,"izumisano.osaka.jp":true,"kadoma.osaka.jp":true,"kaizuka.osaka.jp":true,"kanan.osaka.jp":true,"kashiwara.osaka.jp":true,"katano.osaka.jp":true,"kawachinagano.osaka.jp":true,"kishiwada.osaka.jp":true,"kita.osaka.jp":true,"kumatori.osaka.jp":true,"matsubara.osaka.jp":true,"minato.osaka.jp":true,"minoh.osaka.jp":true,"misaki.osaka.jp":true,"moriguchi.osaka.jp":true,"neyagawa.osaka.jp":true,"nishi.osaka.jp":true,"nose.osaka.jp":true,"osakasayama.osaka.jp":true,"sakai.osaka.jp":true,"sayama.osaka.jp":true,"sennan.osaka.jp":true,"settsu.osaka.jp":true,"shijonawate.osaka.jp":true,"shimamoto.osaka.jp":true,"suita.osaka.jp":true,"tadaoka.osaka.jp":true,"taishi.osaka.jp":true,"tajiri.osaka.jp":true,"takaishi.osaka.jp":true,"takatsuki.osaka.jp":true,"tondabayashi.osaka.jp":true,"toyonaka.osaka.jp":true,"toyono.osaka.jp":true,"yao.osaka.jp":true,"ariake.saga.jp":true,"arita.saga.jp":true,"fukudomi.saga.jp":true,"genkai.saga.jp":true,"hamatama.saga.jp":true,"hizen.saga.jp":true,"imari.saga.jp":true,"kamimine.saga.jp":true,"kanzaki.saga.jp":true,"karatsu.saga.jp":true,"kashima.saga.jp":true,"kitagata.saga.jp":true,"kitahata.saga.jp":true,"kiyama.saga.jp":true,"kouhoku.saga.jp":true,"kyuragi.saga.jp":true,"nishiarita.saga.jp":true,"ogi.saga.jp":true,"omachi.saga.jp":true,"ouchi.saga.jp":true,"saga.saga.jp":true,"shiroishi.saga.jp":true,"taku.saga.jp":true,"tara.saga.jp":true,"tosu.saga.jp":true,"yoshinogari.saga.jp":true,"arakawa.saitama.jp":true,"asaka.saitama.jp":true,"chichibu.saitama.jp":true,"fujimi.saitama.jp":true,"fujimino.saitama.jp":true,"fukaya.saitama.jp":true,"hanno.saitama.jp":true,"hanyu.saitama.jp":true,"hasuda.saitama.jp":true,"hatogaya.saitama.jp":true,"hatoyama.saitama.jp":true,"hidaka.saitama.jp":true,"higashichichibu.saitama.jp":true,"higashimatsuyama.saitama.jp":true,"honjo.saitama.jp":true,"ina.saitama.jp":true,"iruma.saitama.jp":true,"iwatsuki.saitama.jp":true,"kamiizumi.saitama.jp":true,"kamikawa.saitama.jp":true,"kamisato.saitama.jp":true,"kasukabe.saitama.jp":true,"kawagoe.saitama.jp":true,"kawaguchi.saitama.jp":true,"kawajima.saitama.jp":true,"kazo.saitama.jp":true,"kitamoto.saitama.jp":true,"koshigaya.saitama.jp":true,"kounosu.saitama.jp":true,"kuki.saitama.jp":true,"kumagaya.saitama.jp":true,"matsubushi.saitama.jp":true,"minano.saitama.jp":true,"misato.saitama.jp":true,"miyashiro.saitama.jp":true,"miyoshi.saitama.jp":true,"moroyama.saitama.jp":true,"nagatoro.saitama.jp":true,"namegawa.saitama.jp":true,"niiza.saitama.jp":true,"ogano.saitama.jp":true,"ogawa.saitama.jp":true,"ogose.saitama.jp":true,"okegawa.saitama.jp":true,"omiya.saitama.jp":true,"otaki.saitama.jp":true,"ranzan.saitama.jp":true,"ryokami.saitama.jp":true,"saitama.saitama.jp":true,"sakado.saitama.jp":true,"satte.saitama.jp":true,"sayama.saitama.jp":true,"shiki.saitama.jp":true,"shiraoka.saitama.jp":true,"soka.saitama.jp":true,"sugito.saitama.jp":true,"toda.saitama.jp":true,"tokigawa.saitama.jp":true,"tokorozawa.saitama.jp":true,"tsurugashima.saitama.jp":true,"urawa.saitama.jp":true,"warabi.saitama.jp":true,"yashio.saitama.jp":true,"yokoze.saitama.jp":true,"yono.saitama.jp":true,"yorii.saitama.jp":true,"yoshida.saitama.jp":true,"yoshikawa.saitama.jp":true,"yoshimi.saitama.jp":true,"aisho.shiga.jp":true,"gamo.shiga.jp":true,"higashiomi.shiga.jp":true,"hikone.shiga.jp":true,"koka.shiga.jp":true,"konan.shiga.jp":true,"kosei.shiga.jp":true,"koto.shiga.jp":true,"kusatsu.shiga.jp":true,"maibara.shiga.jp":true,"moriyama.shiga.jp":true,"nagahama.shiga.jp":true,"nishiazai.shiga.jp":true,"notogawa.shiga.jp":true,"omihachiman.shiga.jp":true,"otsu.shiga.jp":true,"ritto.shiga.jp":true,"ryuoh.shiga.jp":true,"takashima.shiga.jp":true,"takatsuki.shiga.jp":true,"torahime.shiga.jp":true,"toyosato.shiga.jp":true,"yasu.shiga.jp":true,"akagi.shimane.jp":true,"ama.shimane.jp":true,"gotsu.shimane.jp":true,"hamada.shimane.jp":true,"higashiizumo.shimane.jp":true,"hikawa.shimane.jp":true,"hikimi.shimane.jp":true,"izumo.shimane.jp":true,"kakinoki.shimane.jp":true,"masuda.shimane.jp":true,"matsue.shimane.jp":true,"misato.shimane.jp":true,"nishinoshima.shimane.jp":true,"ohda.shimane.jp":true,"okinoshima.shimane.jp":true,"okuizumo.shimane.jp":true,"shimane.shimane.jp":true,"tamayu.shimane.jp":true,"tsuwano.shimane.jp":true,"unnan.shimane.jp":true,"yakumo.shimane.jp":true,"yasugi.shimane.jp":true,"yatsuka.shimane.jp":true,"arai.shizuoka.jp":true,"atami.shizuoka.jp":true,"fuji.shizuoka.jp":true,"fujieda.shizuoka.jp":true,"fujikawa.shizuoka.jp":true,"fujinomiya.shizuoka.jp":true,"fukuroi.shizuoka.jp":true,"gotemba.shizuoka.jp":true,"haibara.shizuoka.jp":true,"hamamatsu.shizuoka.jp":true,"higashiizu.shizuoka.jp":true,"ito.shizuoka.jp":true,"iwata.shizuoka.jp":true,"izu.shizuoka.jp":true,"izunokuni.shizuoka.jp":true,"kakegawa.shizuoka.jp":true,"kannami.shizuoka.jp":true,"kawanehon.shizuoka.jp":true,"kawazu.shizuoka.jp":true,"kikugawa.shizuoka.jp":true,"kosai.shizuoka.jp":true,"makinohara.shizuoka.jp":true,"matsuzaki.shizuoka.jp":true,"minamiizu.shizuoka.jp":true,"mishima.shizuoka.jp":true,"morimachi.shizuoka.jp":true,"nishiizu.shizuoka.jp":true,"numazu.shizuoka.jp":true,"omaezaki.shizuoka.jp":true,"shimada.shizuoka.jp":true,"shimizu.shizuoka.jp":true,"shimoda.shizuoka.jp":true,"shizuoka.shizuoka.jp":true,"susono.shizuoka.jp":true,"yaizu.shizuoka.jp":true,"yoshida.shizuoka.jp":true,"ashikaga.tochigi.jp":true,"bato.tochigi.jp":true,"haga.tochigi.jp":true,"ichikai.tochigi.jp":true,"iwafune.tochigi.jp":true,"kaminokawa.tochigi.jp":true,"kanuma.tochigi.jp":true,"karasuyama.tochigi.jp":true,"kuroiso.tochigi.jp":true,"mashiko.tochigi.jp":true,"mibu.tochigi.jp":true,"moka.tochigi.jp":true,"motegi.tochigi.jp":true,"nasu.tochigi.jp":true,"nasushiobara.tochigi.jp":true,"nikko.tochigi.jp":true,"nishikata.tochigi.jp":true,"nogi.tochigi.jp":true,"ohira.tochigi.jp":true,"ohtawara.tochigi.jp":true,"oyama.tochigi.jp":true,"sakura.tochigi.jp":true,"sano.tochigi.jp":true,"shimotsuke.tochigi.jp":true,"shioya.tochigi.jp":true,"takanezawa.tochigi.jp":true,"tochigi.tochigi.jp":true,"tsuga.tochigi.jp":true,"ujiie.tochigi.jp":true,"utsunomiya.tochigi.jp":true,"yaita.tochigi.jp":true,"aizumi.tokushima.jp":true,"anan.tokushima.jp":true,"ichiba.tokushima.jp":true,"itano.tokushima.jp":true,"kainan.tokushima.jp":true,"komatsushima.tokushima.jp":true,"matsushige.tokushima.jp":true,"mima.tokushima.jp":true,"minami.tokushima.jp":true,"miyoshi.tokushima.jp":true,"mugi.tokushima.jp":true,"nakagawa.tokushima.jp":true,"naruto.tokushima.jp":true,"sanagochi.tokushima.jp":true,"shishikui.tokushima.jp":true,"tokushima.tokushima.jp":true,"wajiki.tokushima.jp":true,"adachi.tokyo.jp":true,"akiruno.tokyo.jp":true,"akishima.tokyo.jp":true,"aogashima.tokyo.jp":true,"arakawa.tokyo.jp":true,"bunkyo.tokyo.jp":true,"chiyoda.tokyo.jp":true,"chofu.tokyo.jp":true,"chuo.tokyo.jp":true,"edogawa.tokyo.jp":true,"fuchu.tokyo.jp":true,"fussa.tokyo.jp":true,"hachijo.tokyo.jp":true,"hachioji.tokyo.jp":true,"hamura.tokyo.jp":true,"higashikurume.tokyo.jp":true,"higashimurayama.tokyo.jp":true,"higashiyamato.tokyo.jp":true,"hino.tokyo.jp":true,"hinode.tokyo.jp":true,"hinohara.tokyo.jp":true,"inagi.tokyo.jp":true,"itabashi.tokyo.jp":true,"katsushika.tokyo.jp":true,"kita.tokyo.jp":true,"kiyose.tokyo.jp":true,"kodaira.tokyo.jp":true,"koganei.tokyo.jp":true,"kokubunji.tokyo.jp":true,"komae.tokyo.jp":true,"koto.tokyo.jp":true,"kouzushima.tokyo.jp":true,"kunitachi.tokyo.jp":true,"machida.tokyo.jp":true,"meguro.tokyo.jp":true,"minato.tokyo.jp":true,"mitaka.tokyo.jp":true,"mizuho.tokyo.jp":true,"musashimurayama.tokyo.jp":true,"musashino.tokyo.jp":true,"nakano.tokyo.jp":true,"nerima.tokyo.jp":true,"ogasawara.tokyo.jp":true,"okutama.tokyo.jp":true,"ome.tokyo.jp":true,"oshima.tokyo.jp":true,"ota.tokyo.jp":true,"setagaya.tokyo.jp":true,"shibuya.tokyo.jp":true,"shinagawa.tokyo.jp":true,"shinjuku.tokyo.jp":true,"suginami.tokyo.jp":true,"sumida.tokyo.jp":true,"tachikawa.tokyo.jp":true,"taito.tokyo.jp":true,"tama.tokyo.jp":true,"toshima.tokyo.jp":true,"chizu.tottori.jp":true,"hino.tottori.jp":true,"kawahara.tottori.jp":true,"koge.tottori.jp":true,"kotoura.tottori.jp":true,"misasa.tottori.jp":true,"nanbu.tottori.jp":true,"nichinan.tottori.jp":true,"sakaiminato.tottori.jp":true,"tottori.tottori.jp":true,"wakasa.tottori.jp":true,"yazu.tottori.jp":true,"yonago.tottori.jp":true,"asahi.toyama.jp":true,"fuchu.toyama.jp":true,"fukumitsu.toyama.jp":true,"funahashi.toyama.jp":true,"himi.toyama.jp":true,"imizu.toyama.jp":true,"inami.toyama.jp":true,"johana.toyama.jp":true,"kamiichi.toyama.jp":true,"kurobe.toyama.jp":true,"nakaniikawa.toyama.jp":true,"namerikawa.toyama.jp":true,"nanto.toyama.jp":true,"nyuzen.toyama.jp":true,"oyabe.toyama.jp":true,"taira.toyama.jp":true,"takaoka.toyama.jp":true,"tateyama.toyama.jp":true,"toga.toyama.jp":true,"tonami.toyama.jp":true,"toyama.toyama.jp":true,"unazuki.toyama.jp":true,"uozu.toyama.jp":true,"yamada.toyama.jp":true,"arida.wakayama.jp":true,"aridagawa.wakayama.jp":true,"gobo.wakayama.jp":true,"hashimoto.wakayama.jp":true,"hidaka.wakayama.jp":true,"hirogawa.wakayama.jp":true,"inami.wakayama.jp":true,"iwade.wakayama.jp":true,"kainan.wakayama.jp":true,"kamitonda.wakayama.jp":true,"katsuragi.wakayama.jp":true,"kimino.wakayama.jp":true,"kinokawa.wakayama.jp":true,"kitayama.wakayama.jp":true,"koya.wakayama.jp":true,"koza.wakayama.jp":true,"kozagawa.wakayama.jp":true,"kudoyama.wakayama.jp":true,"kushimoto.wakayama.jp":true,"mihama.wakayama.jp":true,"misato.wakayama.jp":true,"nachikatsuura.wakayama.jp":true,"shingu.wakayama.jp":true,"shirahama.wakayama.jp":true,"taiji.wakayama.jp":true,"tanabe.wakayama.jp":true,"wakayama.wakayama.jp":true,"yuasa.wakayama.jp":true,"yura.wakayama.jp":true,"asahi.yamagata.jp":true,"funagata.yamagata.jp":true,"higashine.yamagata.jp":true,"iide.yamagata.jp":true,"kahoku.yamagata.jp":true,"kaminoyama.yamagata.jp":true,"kaneyama.yamagata.jp":true,"kawanishi.yamagata.jp":true,"mamurogawa.yamagata.jp":true,"mikawa.yamagata.jp":true,"murayama.yamagata.jp":true,"nagai.yamagata.jp":true,"nakayama.yamagata.jp":true,"nanyo.yamagata.jp":true,"nishikawa.yamagata.jp":true,"obanazawa.yamagata.jp":true,"oe.yamagata.jp":true,"oguni.yamagata.jp":true,"ohkura.yamagata.jp":true,"oishida.yamagata.jp":true,"sagae.yamagata.jp":true,"sakata.yamagata.jp":true,"sakegawa.yamagata.jp":true,"shinjo.yamagata.jp":true,"shirataka.yamagata.jp":true,"shonai.yamagata.jp":true,"takahata.yamagata.jp":true,"tendo.yamagata.jp":true,"tozawa.yamagata.jp":true,"tsuruoka.yamagata.jp":true,"yamagata.yamagata.jp":true,"yamanobe.yamagata.jp":true,"yonezawa.yamagata.jp":true,"yuza.yamagata.jp":true,"abu.yamaguchi.jp":true,"hagi.yamaguchi.jp":true,"hikari.yamaguchi.jp":true,"hofu.yamaguchi.jp":true,"iwakuni.yamaguchi.jp":true,"kudamatsu.yamaguchi.jp":true,"mitou.yamaguchi.jp":true,"nagato.yamaguchi.jp":true,"oshima.yamaguchi.jp":true,"shimonoseki.yamaguchi.jp":true,"shunan.yamaguchi.jp":true,"tabuse.yamaguchi.jp":true,"tokuyama.yamaguchi.jp":true,"toyota.yamaguchi.jp":true,"ube.yamaguchi.jp":true,"yuu.yamaguchi.jp":true,"chuo.yamanashi.jp":true,"doshi.yamanashi.jp":true,"fuefuki.yamanashi.jp":true,"fujikawa.yamanashi.jp":true,"fujikawaguchiko.yamanashi.jp":true,"fujiyoshida.yamanashi.jp":true,"hayakawa.yamanashi.jp":true,"hokuto.yamanashi.jp":true,"ichikawamisato.yamanashi.jp":true,"kai.yamanashi.jp":true,"kofu.yamanashi.jp":true,"koshu.yamanashi.jp":true,"kosuge.yamanashi.jp":true,"minami-alps.yamanashi.jp":true,"minobu.yamanashi.jp":true,"nakamichi.yamanashi.jp":true,"nanbu.yamanashi.jp":true,"narusawa.yamanashi.jp":true,"nirasaki.yamanashi.jp":true,"nishikatsura.yamanashi.jp":true,"oshino.yamanashi.jp":true,"otsuki.yamanashi.jp":true,"showa.yamanashi.jp":true,"tabayama.yamanashi.jp":true,"tsuru.yamanashi.jp":true,"uenohara.yamanashi.jp":true,"yamanakako.yamanashi.jp":true,"yamanashi.yamanashi.jp":true,"*.ke":true,"kg":true,"org.kg":true,"net.kg":true,"com.kg":true,"edu.kg":true,"gov.kg":true,"mil.kg":true,"*.kh":true,"ki":true,"edu.ki":true,"biz.ki":true,"net.ki":true,"org.ki":true,"gov.ki":true,"info.ki":true,"com.ki":true,"km":true,"org.km":true,"nom.km":true,"gov.km":true,"prd.km":true,"tm.km":true,"edu.km":true,"mil.km":true,"ass.km":true,"com.km":true,"coop.km":true,"asso.km":true,"presse.km":true,"medecin.km":true,"notaires.km":true,"pharmaciens.km":true,"veterinaire.km":true,"gouv.km":true,"kn":true,"net.kn":true,"org.kn":true,"edu.kn":true,"gov.kn":true,"kp":true,"com.kp":true,"edu.kp":true,"gov.kp":true,"org.kp":true,"rep.kp":true,"tra.kp":true,"kr":true,"ac.kr":true,"co.kr":true,"es.kr":true,"go.kr":true,"hs.kr":true,"kg.kr":true,"mil.kr":true,"ms.kr":true,"ne.kr":true,"or.kr":true,"pe.kr":true,"re.kr":true,"sc.kr":true,"busan.kr":true,"chungbuk.kr":true,"chungnam.kr":true,"daegu.kr":true,"daejeon.kr":true,"gangwon.kr":true,"gwangju.kr":true,"gyeongbuk.kr":true,"gyeonggi.kr":true,"gyeongnam.kr":true,"incheon.kr":true,"jeju.kr":true,"jeonbuk.kr":true,"jeonnam.kr":true,"seoul.kr":true,"ulsan.kr":true,"*.kw":true,"ky":true,"edu.ky":true,"gov.ky":true,"com.ky":true,"org.ky":true,"net.ky":true,"kz":true,"org.kz":true,"edu.kz":true,"net.kz":true,"gov.kz":true,"mil.kz":true,"com.kz":true,"la":true,"int.la":true,"net.la":true,"info.la":true,"edu.la":true,"gov.la":true,"per.la":true,"com.la":true,"org.la":true,"lb":true,"com.lb":true,"edu.lb":true,"gov.lb":true,"net.lb":true,"org.lb":true,"lc":true,"com.lc":true,"net.lc":true,"co.lc":true,"org.lc":true,"edu.lc":true,"gov.lc":true,"li":true,"lk":true,"gov.lk":true,"sch.lk":true,"net.lk":true,"int.lk":true,"com.lk":true,"org.lk":true,"edu.lk":true,"ngo.lk":true,"soc.lk":true,"web.lk":true,"ltd.lk":true,"assn.lk":true,"grp.lk":true,"hotel.lk":true,"ac.lk":true,"lr":true,"com.lr":true,"edu.lr":true,"gov.lr":true,"org.lr":true,"net.lr":true,"ls":true,"co.ls":true,"org.ls":true,"lt":true,"gov.lt":true,"lu":true,"lv":true,"com.lv":true,"edu.lv":true,"gov.lv":true,"org.lv":true,"mil.lv":true,"id.lv":true,"net.lv":true,"asn.lv":true,"conf.lv":true,"ly":true,"com.ly":true,"net.ly":true,"gov.ly":true,"plc.ly":true,"edu.ly":true,"sch.ly":true,"med.ly":true,"org.ly":true,"id.ly":true,"ma":true,"co.ma":true,"net.ma":true,"gov.ma":true,"org.ma":true,"ac.ma":true,"press.ma":true,"mc":true,"tm.mc":true,"asso.mc":true,"md":true,"me":true,"co.me":true,"net.me":true,"org.me":true,"edu.me":true,"ac.me":true,"gov.me":true,"its.me":true,"priv.me":true,"mg":true,"org.mg":true,"nom.mg":true,"gov.mg":true,"prd.mg":true,"tm.mg":true,"edu.mg":true,"mil.mg":true,"com.mg":true,"co.mg":true,"mh":true,"mil":true,"mk":true,"com.mk":true,"org.mk":true,"net.mk":true,"edu.mk":true,"gov.mk":true,"inf.mk":true,"name.mk":true,"ml":true,"com.ml":true,"edu.ml":true,"gouv.ml":true,"gov.ml":true,"net.ml":true,"org.ml":true,"presse.ml":true,"*.mm":true,"mn":true,"gov.mn":true,"edu.mn":true,"org.mn":true,"mo":true,"com.mo":true,"net.mo":true,"org.mo":true,"edu.mo":true,"gov.mo":true,"mobi":true,"mp":true,"mq":true,"mr":true,"gov.mr":true,"ms":true,"com.ms":true,"edu.ms":true,"gov.ms":true,"net.ms":true,"org.ms":true,"mt":true,"com.mt":true,"edu.mt":true,"net.mt":true,"org.mt":true,"mu":true,"com.mu":true,"net.mu":true,"org.mu":true,"gov.mu":true,"ac.mu":true,"co.mu":true,"or.mu":true,"museum":true,"academy.museum":true,"agriculture.museum":true,"air.museum":true,"airguard.museum":true,"alabama.museum":true,"alaska.museum":true,"amber.museum":true,"ambulance.museum":true,"american.museum":true,"americana.museum":true,"americanantiques.museum":true,"americanart.museum":true,"amsterdam.museum":true,"and.museum":true,"annefrank.museum":true,"anthro.museum":true,"anthropology.museum":true,"antiques.museum":true,"aquarium.museum":true,"arboretum.museum":true,"archaeological.museum":true,"archaeology.museum":true,"architecture.museum":true,"art.museum":true,"artanddesign.museum":true,"artcenter.museum":true,"artdeco.museum":true,"arteducation.museum":true,"artgallery.museum":true,"arts.museum":true,"artsandcrafts.museum":true,"asmatart.museum":true,"assassination.museum":true,"assisi.museum":true,"association.museum":true,"astronomy.museum":true,"atlanta.museum":true,"austin.museum":true,"australia.museum":true,"automotive.museum":true,"aviation.museum":true,"axis.museum":true,"badajoz.museum":true,"baghdad.museum":true,"bahn.museum":true,"bale.museum":true,"baltimore.museum":true,"barcelona.museum":true,"baseball.museum":true,"basel.museum":true,"baths.museum":true,"bauern.museum":true,"beauxarts.museum":true,"beeldengeluid.museum":true,"bellevue.museum":true,"bergbau.museum":true,"berkeley.museum":true,"berlin.museum":true,"bern.museum":true,"bible.museum":true,"bilbao.museum":true,"bill.museum":true,"birdart.museum":true,"birthplace.museum":true,"bonn.museum":true,"boston.museum":true,"botanical.museum":true,"botanicalgarden.museum":true,"botanicgarden.museum":true,"botany.museum":true,"brandywinevalley.museum":true,"brasil.museum":true,"bristol.museum":true,"british.museum":true,"britishcolumbia.museum":true,"broadcast.museum":true,"brunel.museum":true,"brussel.museum":true,"brussels.museum":true,"bruxelles.museum":true,"building.museum":true,"burghof.museum":true,"bus.museum":true,"bushey.museum":true,"cadaques.museum":true,"california.museum":true,"cambridge.museum":true,"can.museum":true,"canada.museum":true,"capebreton.museum":true,"carrier.museum":true,"cartoonart.museum":true,"casadelamoneda.museum":true,"castle.museum":true,"castres.museum":true,"celtic.museum":true,"center.museum":true,"chattanooga.museum":true,"cheltenham.museum":true,"chesapeakebay.museum":true,"chicago.museum":true,"children.museum":true,"childrens.museum":true,"childrensgarden.museum":true,"chiropractic.museum":true,"chocolate.museum":true,"christiansburg.museum":true,"cincinnati.museum":true,"cinema.museum":true,"circus.museum":true,"civilisation.museum":true,"civilization.museum":true,"civilwar.museum":true,"clinton.museum":true,"clock.museum":true,"coal.museum":true,"coastaldefence.museum":true,"cody.museum":true,"coldwar.museum":true,"collection.museum":true,"colonialwilliamsburg.museum":true,"coloradoplateau.museum":true,"columbia.museum":true,"columbus.museum":true,"communication.museum":true,"communications.museum":true,"community.museum":true,"computer.museum":true,"computerhistory.museum":true,"xn--comunicaes-v6a2o.museum":true,"contemporary.museum":true,"contemporaryart.museum":true,"convent.museum":true,"copenhagen.museum":true,"corporation.museum":true,"xn--correios-e-telecomunicaes-ghc29a.museum":true,"corvette.museum":true,"costume.museum":true,"countryestate.museum":true,"county.museum":true,"crafts.museum":true,"cranbrook.museum":true,"creation.museum":true,"cultural.museum":true,"culturalcenter.museum":true,"culture.museum":true,"cyber.museum":true,"cymru.museum":true,"dali.museum":true,"dallas.museum":true,"database.museum":true,"ddr.museum":true,"decorativearts.museum":true,"delaware.museum":true,"delmenhorst.museum":true,"denmark.museum":true,"depot.museum":true,"design.museum":true,"detroit.museum":true,"dinosaur.museum":true,"discovery.museum":true,"dolls.museum":true,"donostia.museum":true,"durham.museum":true,"eastafrica.museum":true,"eastcoast.museum":true,"education.museum":true,"educational.museum":true,"egyptian.museum":true,"eisenbahn.museum":true,"elburg.museum":true,"elvendrell.museum":true,"embroidery.museum":true,"encyclopedic.museum":true,"england.museum":true,"entomology.museum":true,"environment.museum":true,"environmentalconservation.museum":true,"epilepsy.museum":true,"essex.museum":true,"estate.museum":true,"ethnology.museum":true,"exeter.museum":true,"exhibition.museum":true,"family.museum":true,"farm.museum":true,"farmequipment.museum":true,"farmers.museum":true,"farmstead.museum":true,"field.museum":true,"figueres.museum":true,"filatelia.museum":true,"film.museum":true,"fineart.museum":true,"finearts.museum":true,"finland.museum":true,"flanders.museum":true,"florida.museum":true,"force.museum":true,"fortmissoula.museum":true,"fortworth.museum":true,"foundation.museum":true,"francaise.museum":true,"frankfurt.museum":true,"franziskaner.museum":true,"freemasonry.museum":true,"freiburg.museum":true,"fribourg.museum":true,"frog.museum":true,"fundacio.museum":true,"furniture.museum":true,"gallery.museum":true,"garden.museum":true,"gateway.museum":true,"geelvinck.museum":true,"gemological.museum":true,"geology.museum":true,"georgia.museum":true,"giessen.museum":true,"glas.museum":true,"glass.museum":true,"gorge.museum":true,"grandrapids.museum":true,"graz.museum":true,"guernsey.museum":true,"halloffame.museum":true,"hamburg.museum":true,"handson.museum":true,"harvestcelebration.museum":true,"hawaii.museum":true,"health.museum":true,"heimatunduhren.museum":true,"hellas.museum":true,"helsinki.museum":true,"hembygdsforbund.museum":true,"heritage.museum":true,"histoire.museum":true,"historical.museum":true,"historicalsociety.museum":true,"historichouses.museum":true,"historisch.museum":true,"historisches.museum":true,"history.museum":true,"historyofscience.museum":true,"horology.museum":true,"house.museum":true,"humanities.museum":true,"illustration.museum":true,"imageandsound.museum":true,"indian.museum":true,"indiana.museum":true,"indianapolis.museum":true,"indianmarket.museum":true,"intelligence.museum":true,"interactive.museum":true,"iraq.museum":true,"iron.museum":true,"isleofman.museum":true,"jamison.museum":true,"jefferson.museum":true,"jerusalem.museum":true,"jewelry.museum":true,"jewish.museum":true,"jewishart.museum":true,"jfk.museum":true,"journalism.museum":true,"judaica.museum":true,"judygarland.museum":true,"juedisches.museum":true,"juif.museum":true,"karate.museum":true,"karikatur.museum":true,"kids.museum":true,"koebenhavn.museum":true,"koeln.museum":true,"kunst.museum":true,"kunstsammlung.museum":true,"kunstunddesign.museum":true,"labor.museum":true,"labour.museum":true,"lajolla.museum":true,"lancashire.museum":true,"landes.museum":true,"lans.museum":true,"xn--lns-qla.museum":true,"larsson.museum":true,"lewismiller.museum":true,"lincoln.museum":true,"linz.museum":true,"living.museum":true,"livinghistory.museum":true,"localhistory.museum":true,"london.museum":true,"losangeles.museum":true,"louvre.museum":true,"loyalist.museum":true,"lucerne.museum":true,"luxembourg.museum":true,"luzern.museum":true,"mad.museum":true,"madrid.museum":true,"mallorca.museum":true,"manchester.museum":true,"mansion.museum":true,"mansions.museum":true,"manx.museum":true,"marburg.museum":true,"maritime.museum":true,"maritimo.museum":true,"maryland.museum":true,"marylhurst.museum":true,"media.museum":true,"medical.museum":true,"medizinhistorisches.museum":true,"meeres.museum":true,"memorial.museum":true,"mesaverde.museum":true,"michigan.museum":true,"midatlantic.museum":true,"military.museum":true,"mill.museum":true,"miners.museum":true,"mining.museum":true,"minnesota.museum":true,"missile.museum":true,"missoula.museum":true,"modern.museum":true,"moma.museum":true,"money.museum":true,"monmouth.museum":true,"monticello.museum":true,"montreal.museum":true,"moscow.museum":true,"motorcycle.museum":true,"muenchen.museum":true,"muenster.museum":true,"mulhouse.museum":true,"muncie.museum":true,"museet.museum":true,"museumcenter.museum":true,"museumvereniging.museum":true,"music.museum":true,"national.museum":true,"nationalfirearms.museum":true,"nationalheritage.museum":true,"nativeamerican.museum":true,"naturalhistory.museum":true,"naturalhistorymuseum.museum":true,"naturalsciences.museum":true,"nature.museum":true,"naturhistorisches.museum":true,"natuurwetenschappen.museum":true,"naumburg.museum":true,"naval.museum":true,"nebraska.museum":true,"neues.museum":true,"newhampshire.museum":true,"newjersey.museum":true,"newmexico.museum":true,"newport.museum":true,"newspaper.museum":true,"newyork.museum":true,"niepce.museum":true,"norfolk.museum":true,"north.museum":true,"nrw.museum":true,"nuernberg.museum":true,"nuremberg.museum":true,"nyc.museum":true,"nyny.museum":true,"oceanographic.museum":true,"oceanographique.museum":true,"omaha.museum":true,"online.museum":true,"ontario.museum":true,"openair.museum":true,"oregon.museum":true,"oregontrail.museum":true,"otago.museum":true,"oxford.museum":true,"pacific.museum":true,"paderborn.museum":true,"palace.museum":true,"paleo.museum":true,"palmsprings.museum":true,"panama.museum":true,"paris.museum":true,"pasadena.museum":true,"pharmacy.museum":true,"philadelphia.museum":true,"philadelphiaarea.museum":true,"philately.museum":true,"phoenix.museum":true,"photography.museum":true,"pilots.museum":true,"pittsburgh.museum":true,"planetarium.museum":true,"plantation.museum":true,"plants.museum":true,"plaza.museum":true,"portal.museum":true,"portland.museum":true,"portlligat.museum":true,"posts-and-telecommunications.museum":true,"preservation.museum":true,"presidio.museum":true,"press.museum":true,"project.museum":true,"public.museum":true,"pubol.museum":true,"quebec.museum":true,"railroad.museum":true,"railway.museum":true,"research.museum":true,"resistance.museum":true,"riodejaneiro.museum":true,"rochester.museum":true,"rockart.museum":true,"roma.museum":true,"russia.museum":true,"saintlouis.museum":true,"salem.museum":true,"salvadordali.museum":true,"salzburg.museum":true,"sandiego.museum":true,"sanfrancisco.museum":true,"santabarbara.museum":true,"santacruz.museum":true,"santafe.museum":true,"saskatchewan.museum":true,"satx.museum":true,"savannahga.museum":true,"schlesisches.museum":true,"schoenbrunn.museum":true,"schokoladen.museum":true,"school.museum":true,"schweiz.museum":true,"science.museum":true,"scienceandhistory.museum":true,"scienceandindustry.museum":true,"sciencecenter.museum":true,"sciencecenters.museum":true,"science-fiction.museum":true,"sciencehistory.museum":true,"sciences.museum":true,"sciencesnaturelles.museum":true,"scotland.museum":true,"seaport.museum":true,"settlement.museum":true,"settlers.museum":true,"shell.museum":true,"sherbrooke.museum":true,"sibenik.museum":true,"silk.museum":true,"ski.museum":true,"skole.museum":true,"society.museum":true,"sologne.museum":true,"soundandvision.museum":true,"southcarolina.museum":true,"southwest.museum":true,"space.museum":true,"spy.museum":true,"square.museum":true,"stadt.museum":true,"stalbans.museum":true,"starnberg.museum":true,"state.museum":true,"stateofdelaware.museum":true,"station.museum":true,"steam.museum":true,"steiermark.museum":true,"stjohn.museum":true,"stockholm.museum":true,"stpetersburg.museum":true,"stuttgart.museum":true,"suisse.museum":true,"surgeonshall.museum":true,"surrey.museum":true,"svizzera.museum":true,"sweden.museum":true,"sydney.museum":true,"tank.museum":true,"tcm.museum":true,"technology.museum":true,"telekommunikation.museum":true,"television.museum":true,"texas.museum":true,"textile.museum":true,"theater.museum":true,"time.museum":true,"timekeeping.museum":true,"topology.museum":true,"torino.museum":true,"touch.museum":true,"town.museum":true,"transport.museum":true,"tree.museum":true,"trolley.museum":true,"trust.museum":true,"trustee.museum":true,"uhren.museum":true,"ulm.museum":true,"undersea.museum":true,"university.museum":true,"usa.museum":true,"usantiques.museum":true,"usarts.museum":true,"uscountryestate.museum":true,"usculture.museum":true,"usdecorativearts.museum":true,"usgarden.museum":true,"ushistory.museum":true,"ushuaia.museum":true,"uslivinghistory.museum":true,"utah.museum":true,"uvic.museum":true,"valley.museum":true,"vantaa.museum":true,"versailles.museum":true,"viking.museum":true,"village.museum":true,"virginia.museum":true,"virtual.museum":true,"virtuel.museum":true,"vlaanderen.museum":true,"volkenkunde.museum":true,"wales.museum":true,"wallonie.museum":true,"war.museum":true,"washingtondc.museum":true,"watchandclock.museum":true,"watch-and-clock.museum":true,"western.museum":true,"westfalen.museum":true,"whaling.museum":true,"wildlife.museum":true,"williamsburg.museum":true,"windmill.museum":true,"workshop.museum":true,"york.museum":true,"yorkshire.museum":true,"yosemite.museum":true,"youth.museum":true,"zoological.museum":true,"zoology.museum":true,"xn--9dbhblg6di.museum":true,"xn--h1aegh.museum":true,"mv":true,"aero.mv":true,"biz.mv":true,"com.mv":true,"coop.mv":true,"edu.mv":true,"gov.mv":true,"info.mv":true,"int.mv":true,"mil.mv":true,"museum.mv":true,"name.mv":true,"net.mv":true,"org.mv":true,"pro.mv":true,"mw":true,"ac.mw":true,"biz.mw":true,"co.mw":true,"com.mw":true,"coop.mw":true,"edu.mw":true,"gov.mw":true,"int.mw":true,"museum.mw":true,"net.mw":true,"org.mw":true,"mx":true,"com.mx":true,"org.mx":true,"gob.mx":true,"edu.mx":true,"net.mx":true,"my":true,"com.my":true,"net.my":true,"org.my":true,"gov.my":true,"edu.my":true,"mil.my":true,"name.my":true,"*.mz":true,"teledata.mz":false,"na":true,"info.na":true,"pro.na":true,"name.na":true,"school.na":true,"or.na":true,"dr.na":true,"us.na":true,"mx.na":true,"ca.na":true,"in.na":true,"cc.na":true,"tv.na":true,"ws.na":true,"mobi.na":true,"co.na":true,"com.na":true,"org.na":true,"name":true,"nc":true,"asso.nc":true,"ne":true,"net":true,"nf":true,"com.nf":true,"net.nf":true,"per.nf":true,"rec.nf":true,"web.nf":true,"arts.nf":true,"firm.nf":true,"info.nf":true,"other.nf":true,"store.nf":true,"ng":true,"com.ng":true,"edu.ng":true,"name.ng":true,"net.ng":true,"org.ng":true,"sch.ng":true,"gov.ng":true,"mil.ng":true,"mobi.ng":true,"*.ni":true,"nl":true,"bv.nl":true,"no":true,"fhs.no":true,"vgs.no":true,"fylkesbibl.no":true,"folkebibl.no":true,"museum.no":true,"idrett.no":true,"priv.no":true,"mil.no":true,"stat.no":true,"dep.no":true,"kommune.no":true,"herad.no":true,"aa.no":true,"ah.no":true,"bu.no":true,"fm.no":true,"hl.no":true,"hm.no":true,"jan-mayen.no":true,"mr.no":true,"nl.no":true,"nt.no":true,"of.no":true,"ol.no":true,"oslo.no":true,"rl.no":true,"sf.no":true,"st.no":true,"svalbard.no":true,"tm.no":true,"tr.no":true,"va.no":true,"vf.no":true,"gs.aa.no":true,"gs.ah.no":true,"gs.bu.no":true,"gs.fm.no":true,"gs.hl.no":true,"gs.hm.no":true,"gs.jan-mayen.no":true,"gs.mr.no":true,"gs.nl.no":true,"gs.nt.no":true,"gs.of.no":true,"gs.ol.no":true,"gs.oslo.no":true,"gs.rl.no":true,"gs.sf.no":true,"gs.st.no":true,"gs.svalbard.no":true,"gs.tm.no":true,"gs.tr.no":true,"gs.va.no":true,"gs.vf.no":true,"akrehamn.no":true,"xn--krehamn-dxa.no":true,"algard.no":true,"xn--lgrd-poac.no":true,"arna.no":true,"brumunddal.no":true,"bryne.no":true,"bronnoysund.no":true,"xn--brnnysund-m8ac.no":true,"drobak.no":true,"xn--drbak-wua.no":true,"egersund.no":true,"fetsund.no":true,"floro.no":true,"xn--flor-jra.no":true,"fredrikstad.no":true,"hokksund.no":true,"honefoss.no":true,"xn--hnefoss-q1a.no":true,"jessheim.no":true,"jorpeland.no":true,"xn--jrpeland-54a.no":true,"kirkenes.no":true,"kopervik.no":true,"krokstadelva.no":true,"langevag.no":true,"xn--langevg-jxa.no":true,"leirvik.no":true,"mjondalen.no":true,"xn--mjndalen-64a.no":true,"mo-i-rana.no":true,"mosjoen.no":true,"xn--mosjen-eya.no":true,"nesoddtangen.no":true,"orkanger.no":true,"osoyro.no":true,"xn--osyro-wua.no":true,"raholt.no":true,"xn--rholt-mra.no":true,"sandnessjoen.no":true,"xn--sandnessjen-ogb.no":true,"skedsmokorset.no":true,"slattum.no":true,"spjelkavik.no":true,"stathelle.no":true,"stavern.no":true,"stjordalshalsen.no":true,"xn--stjrdalshalsen-sqb.no":true,"tananger.no":true,"tranby.no":true,"vossevangen.no":true,"afjord.no":true,"xn--fjord-lra.no":true,"agdenes.no":true,"al.no":true,"xn--l-1fa.no":true,"alesund.no":true,"xn--lesund-hua.no":true,"alstahaug.no":true,"alta.no":true,"xn--lt-liac.no":true,"alaheadju.no":true,"xn--laheadju-7ya.no":true,"alvdal.no":true,"amli.no":true,"xn--mli-tla.no":true,"amot.no":true,"xn--mot-tla.no":true,"andebu.no":true,"andoy.no":true,"xn--andy-ira.no":true,"andasuolo.no":true,"ardal.no":true,"xn--rdal-poa.no":true,"aremark.no":true,"arendal.no":true,"xn--s-1fa.no":true,"aseral.no":true,"xn--seral-lra.no":true,"asker.no":true,"askim.no":true,"askvoll.no":true,"askoy.no":true,"xn--asky-ira.no":true,"asnes.no":true,"xn--snes-poa.no":true,"audnedaln.no":true,"aukra.no":true,"aure.no":true,"aurland.no":true,"aurskog-holand.no":true,"xn--aurskog-hland-jnb.no":true,"austevoll.no":true,"austrheim.no":true,"averoy.no":true,"xn--avery-yua.no":true,"balestrand.no":true,"ballangen.no":true,"balat.no":true,"xn--blt-elab.no":true,"balsfjord.no":true,"bahccavuotna.no":true,"xn--bhccavuotna-k7a.no":true,"bamble.no":true,"bardu.no":true,"beardu.no":true,"beiarn.no":true,"bajddar.no":true,"xn--bjddar-pta.no":true,"baidar.no":true,"xn--bidr-5nac.no":true,"berg.no":true,"bergen.no":true,"berlevag.no":true,"xn--berlevg-jxa.no":true,"bearalvahki.no":true,"xn--bearalvhki-y4a.no":true,"bindal.no":true,"birkenes.no":true,"bjarkoy.no":true,"xn--bjarky-fya.no":true,"bjerkreim.no":true,"bjugn.no":true,"bodo.no":true,"xn--bod-2na.no":true,"badaddja.no":true,"xn--bdddj-mrabd.no":true,"budejju.no":true,"bokn.no":true,"bremanger.no":true,"bronnoy.no":true,"xn--brnny-wuac.no":true,"bygland.no":true,"bykle.no":true,"barum.no":true,"xn--brum-voa.no":true,"bo.telemark.no":true,"xn--b-5ga.telemark.no":true,"bo.nordland.no":true,"xn--b-5ga.nordland.no":true,"bievat.no":true,"xn--bievt-0qa.no":true,"bomlo.no":true,"xn--bmlo-gra.no":true,"batsfjord.no":true,"xn--btsfjord-9za.no":true,"bahcavuotna.no":true,"xn--bhcavuotna-s4a.no":true,"dovre.no":true,"drammen.no":true,"drangedal.no":true,"dyroy.no":true,"xn--dyry-ira.no":true,"donna.no":true,"xn--dnna-gra.no":true,"eid.no":true,"eidfjord.no":true,"eidsberg.no":true,"eidskog.no":true,"eidsvoll.no":true,"eigersund.no":true,"elverum.no":true,"enebakk.no":true,"engerdal.no":true,"etne.no":true,"etnedal.no":true,"evenes.no":true,"evenassi.no":true,"xn--eveni-0qa01ga.no":true,"evje-og-hornnes.no":true,"farsund.no":true,"fauske.no":true,"fuossko.no":true,"fuoisku.no":true,"fedje.no":true,"fet.no":true,"finnoy.no":true,"xn--finny-yua.no":true,"fitjar.no":true,"fjaler.no":true,"fjell.no":true,"flakstad.no":true,"flatanger.no":true,"flekkefjord.no":true,"flesberg.no":true,"flora.no":true,"fla.no":true,"xn--fl-zia.no":true,"folldal.no":true,"forsand.no":true,"fosnes.no":true,"frei.no":true,"frogn.no":true,"froland.no":true,"frosta.no":true,"frana.no":true,"xn--frna-woa.no":true,"froya.no":true,"xn--frya-hra.no":true,"fusa.no":true,"fyresdal.no":true,"forde.no":true,"xn--frde-gra.no":true,"gamvik.no":true,"gangaviika.no":true,"xn--ggaviika-8ya47h.no":true,"gaular.no":true,"gausdal.no":true,"gildeskal.no":true,"xn--gildeskl-g0a.no":true,"giske.no":true,"gjemnes.no":true,"gjerdrum.no":true,"gjerstad.no":true,"gjesdal.no":true,"gjovik.no":true,"xn--gjvik-wua.no":true,"gloppen.no":true,"gol.no":true,"gran.no":true,"grane.no":true,"granvin.no":true,"gratangen.no":true,"grimstad.no":true,"grong.no":true,"kraanghke.no":true,"xn--kranghke-b0a.no":true,"grue.no":true,"gulen.no":true,"hadsel.no":true,"halden.no":true,"halsa.no":true,"hamar.no":true,"hamaroy.no":true,"habmer.no":true,"xn--hbmer-xqa.no":true,"hapmir.no":true,"xn--hpmir-xqa.no":true,"hammerfest.no":true,"hammarfeasta.no":true,"xn--hmmrfeasta-s4ac.no":true,"haram.no":true,"hareid.no":true,"harstad.no":true,"hasvik.no":true,"aknoluokta.no":true,"xn--koluokta-7ya57h.no":true,"hattfjelldal.no":true,"aarborte.no":true,"haugesund.no":true,"hemne.no":true,"hemnes.no":true,"hemsedal.no":true,"heroy.more-og-romsdal.no":true,"xn--hery-ira.xn--mre-og-romsdal-qqb.no":true,"heroy.nordland.no":true,"xn--hery-ira.nordland.no":true,"hitra.no":true,"hjartdal.no":true,"hjelmeland.no":true,"hobol.no":true,"xn--hobl-ira.no":true,"hof.no":true,"hol.no":true,"hole.no":true,"holmestrand.no":true,"holtalen.no":true,"xn--holtlen-hxa.no":true,"hornindal.no":true,"horten.no":true,"hurdal.no":true,"hurum.no":true,"hvaler.no":true,"hyllestad.no":true,"hagebostad.no":true,"xn--hgebostad-g3a.no":true,"hoyanger.no":true,"xn--hyanger-q1a.no":true,"hoylandet.no":true,"xn--hylandet-54a.no":true,"ha.no":true,"xn--h-2fa.no":true,"ibestad.no":true,"inderoy.no":true,"xn--indery-fya.no":true,"iveland.no":true,"jevnaker.no":true,"jondal.no":true,"jolster.no":true,"xn--jlster-bya.no":true,"karasjok.no":true,"karasjohka.no":true,"xn--krjohka-hwab49j.no":true,"karlsoy.no":true,"galsa.no":true,"xn--gls-elac.no":true,"karmoy.no":true,"xn--karmy-yua.no":true,"kautokeino.no":true,"guovdageaidnu.no":true,"klepp.no":true,"klabu.no":true,"xn--klbu-woa.no":true,"kongsberg.no":true,"kongsvinger.no":true,"kragero.no":true,"xn--krager-gya.no":true,"kristiansand.no":true,"kristiansund.no":true,"krodsherad.no":true,"xn--krdsherad-m8a.no":true,"kvalsund.no":true,"rahkkeravju.no":true,"xn--rhkkervju-01af.no":true,"kvam.no":true,"kvinesdal.no":true,"kvinnherad.no":true,"kviteseid.no":true,"kvitsoy.no":true,"xn--kvitsy-fya.no":true,"kvafjord.no":true,"xn--kvfjord-nxa.no":true,"giehtavuoatna.no":true,"kvanangen.no":true,"xn--kvnangen-k0a.no":true,"navuotna.no":true,"xn--nvuotna-hwa.no":true,"kafjord.no":true,"xn--kfjord-iua.no":true,"gaivuotna.no":true,"xn--givuotna-8ya.no":true,"larvik.no":true,"lavangen.no":true,"lavagis.no":true,"loabat.no":true,"xn--loabt-0qa.no":true,"lebesby.no":true,"davvesiida.no":true,"leikanger.no":true,"leirfjord.no":true,"leka.no":true,"leksvik.no":true,"lenvik.no":true,"leangaviika.no":true,"xn--leagaviika-52b.no":true,"lesja.no":true,"levanger.no":true,"lier.no":true,"lierne.no":true,"lillehammer.no":true,"lillesand.no":true,"lindesnes.no":true,"lindas.no":true,"xn--linds-pra.no":true,"lom.no":true,"loppa.no":true,"lahppi.no":true,"xn--lhppi-xqa.no":true,"lund.no":true,"lunner.no":true,"luroy.no":true,"xn--lury-ira.no":true,"luster.no":true,"lyngdal.no":true,"lyngen.no":true,"ivgu.no":true,"lardal.no":true,"lerdal.no":true,"xn--lrdal-sra.no":true,"lodingen.no":true,"xn--ldingen-q1a.no":true,"lorenskog.no":true,"xn--lrenskog-54a.no":true,"loten.no":true,"xn--lten-gra.no":true,"malvik.no":true,"masoy.no":true,"xn--msy-ula0h.no":true,"muosat.no":true,"xn--muost-0qa.no":true,"mandal.no":true,"marker.no":true,"marnardal.no":true,"masfjorden.no":true,"meland.no":true,"meldal.no":true,"melhus.no":true,"meloy.no":true,"xn--mely-ira.no":true,"meraker.no":true,"xn--merker-kua.no":true,"moareke.no":true,"xn--moreke-jua.no":true,"midsund.no":true,"midtre-gauldal.no":true,"modalen.no":true,"modum.no":true,"molde.no":true,"moskenes.no":true,"moss.no":true,"mosvik.no":true,"malselv.no":true,"xn--mlselv-iua.no":true,"malatvuopmi.no":true,"xn--mlatvuopmi-s4a.no":true,"namdalseid.no":true,"aejrie.no":true,"namsos.no":true,"namsskogan.no":true,"naamesjevuemie.no":true,"xn--nmesjevuemie-tcba.no":true,"laakesvuemie.no":true,"nannestad.no":true,"narvik.no":true,"narviika.no":true,"naustdal.no":true,"nedre-eiker.no":true,"nes.akershus.no":true,"nes.buskerud.no":true,"nesna.no":true,"nesodden.no":true,"nesseby.no":true,"unjarga.no":true,"xn--unjrga-rta.no":true,"nesset.no":true,"nissedal.no":true,"nittedal.no":true,"nord-aurdal.no":true,"nord-fron.no":true,"nord-odal.no":true,"norddal.no":true,"nordkapp.no":true,"davvenjarga.no":true,"xn--davvenjrga-y4a.no":true,"nordre-land.no":true,"nordreisa.no":true,"raisa.no":true,"xn--risa-5na.no":true,"nore-og-uvdal.no":true,"notodden.no":true,"naroy.no":true,"xn--nry-yla5g.no":true,"notteroy.no":true,"xn--nttery-byae.no":true,"odda.no":true,"oksnes.no":true,"xn--ksnes-uua.no":true,"oppdal.no":true,"oppegard.no":true,"xn--oppegrd-ixa.no":true,"orkdal.no":true,"orland.no":true,"xn--rland-uua.no":true,"orskog.no":true,"xn--rskog-uua.no":true,"orsta.no":true,"xn--rsta-fra.no":true,"os.hedmark.no":true,"os.hordaland.no":true,"osen.no":true,"osteroy.no":true,"xn--ostery-fya.no":true,"ostre-toten.no":true,"xn--stre-toten-zcb.no":true,"overhalla.no":true,"ovre-eiker.no":true,"xn--vre-eiker-k8a.no":true,"oyer.no":true,"xn--yer-zna.no":true,"oygarden.no":true,"xn--ygarden-p1a.no":true,"oystre-slidre.no":true,"xn--ystre-slidre-ujb.no":true,"porsanger.no":true,"porsangu.no":true,"xn--porsgu-sta26f.no":true,"porsgrunn.no":true,"radoy.no":true,"xn--rady-ira.no":true,"rakkestad.no":true,"rana.no":true,"ruovat.no":true,"randaberg.no":true,"rauma.no":true,"rendalen.no":true,"rennebu.no":true,"rennesoy.no":true,"xn--rennesy-v1a.no":true,"rindal.no":true,"ringebu.no":true,"ringerike.no":true,"ringsaker.no":true,"rissa.no":true,"risor.no":true,"xn--risr-ira.no":true,"roan.no":true,"rollag.no":true,"rygge.no":true,"ralingen.no":true,"xn--rlingen-mxa.no":true,"rodoy.no":true,"xn--rdy-0nab.no":true,"romskog.no":true,"xn--rmskog-bya.no":true,"roros.no":true,"xn--rros-gra.no":true,"rost.no":true,"xn--rst-0na.no":true,"royken.no":true,"xn--ryken-vua.no":true,"royrvik.no":true,"xn--ryrvik-bya.no":true,"rade.no":true,"xn--rde-ula.no":true,"salangen.no":true,"siellak.no":true,"saltdal.no":true,"salat.no":true,"xn--slt-elab.no":true,"xn--slat-5na.no":true,"samnanger.no":true,"sande.more-og-romsdal.no":true,"sande.xn--mre-og-romsdal-qqb.no":true,"sande.vestfold.no":true,"sandefjord.no":true,"sandnes.no":true,"sandoy.no":true,"xn--sandy-yua.no":true,"sarpsborg.no":true,"sauda.no":true,"sauherad.no":true,"sel.no":true,"selbu.no":true,"selje.no":true,"seljord.no":true,"sigdal.no":true,"siljan.no":true,"sirdal.no":true,"skaun.no":true,"skedsmo.no":true,"ski.no":true,"skien.no":true,"skiptvet.no":true,"skjervoy.no":true,"xn--skjervy-v1a.no":true,"skierva.no":true,"xn--skierv-uta.no":true,"skjak.no":true,"xn--skjk-soa.no":true,"skodje.no":true,"skanland.no":true,"xn--sknland-fxa.no":true,"skanit.no":true,"xn--sknit-yqa.no":true,"smola.no":true,"xn--smla-hra.no":true,"snillfjord.no":true,"snasa.no":true,"xn--snsa-roa.no":true,"snoasa.no":true,"snaase.no":true,"xn--snase-nra.no":true,"sogndal.no":true,"sokndal.no":true,"sola.no":true,"solund.no":true,"songdalen.no":true,"sortland.no":true,"spydeberg.no":true,"stange.no":true,"stavanger.no":true,"steigen.no":true,"steinkjer.no":true,"stjordal.no":true,"xn--stjrdal-s1a.no":true,"stokke.no":true,"stor-elvdal.no":true,"stord.no":true,"stordal.no":true,"storfjord.no":true,"omasvuotna.no":true,"strand.no":true,"stranda.no":true,"stryn.no":true,"sula.no":true,"suldal.no":true,"sund.no":true,"sunndal.no":true,"surnadal.no":true,"sveio.no":true,"svelvik.no":true,"sykkylven.no":true,"sogne.no":true,"xn--sgne-gra.no":true,"somna.no":true,"xn--smna-gra.no":true,"sondre-land.no":true,"xn--sndre-land-0cb.no":true,"sor-aurdal.no":true,"xn--sr-aurdal-l8a.no":true,"sor-fron.no":true,"xn--sr-fron-q1a.no":true,"sor-odal.no":true,"xn--sr-odal-q1a.no":true,"sor-varanger.no":true,"xn--sr-varanger-ggb.no":true,"matta-varjjat.no":true,"xn--mtta-vrjjat-k7af.no":true,"sorfold.no":true,"xn--srfold-bya.no":true,"sorreisa.no":true,"xn--srreisa-q1a.no":true,"sorum.no":true,"xn--srum-gra.no":true,"tana.no":true,"deatnu.no":true,"time.no":true,"tingvoll.no":true,"tinn.no":true,"tjeldsund.no":true,"dielddanuorri.no":true,"tjome.no":true,"xn--tjme-hra.no":true,"tokke.no":true,"tolga.no":true,"torsken.no":true,"tranoy.no":true,"xn--trany-yua.no":true,"tromso.no":true,"xn--troms-zua.no":true,"tromsa.no":true,"romsa.no":true,"trondheim.no":true,"troandin.no":true,"trysil.no":true,"trana.no":true,"xn--trna-woa.no":true,"trogstad.no":true,"xn--trgstad-r1a.no":true,"tvedestrand.no":true,"tydal.no":true,"tynset.no":true,"tysfjord.no":true,"divtasvuodna.no":true,"divttasvuotna.no":true,"tysnes.no":true,"tysvar.no":true,"xn--tysvr-vra.no":true,"tonsberg.no":true,"xn--tnsberg-q1a.no":true,"ullensaker.no":true,"ullensvang.no":true,"ulvik.no":true,"utsira.no":true,"vadso.no":true,"xn--vads-jra.no":true,"cahcesuolo.no":true,"xn--hcesuolo-7ya35b.no":true,"vaksdal.no":true,"valle.no":true,"vang.no":true,"vanylven.no":true,"vardo.no":true,"xn--vard-jra.no":true,"varggat.no":true,"xn--vrggt-xqad.no":true,"vefsn.no":true,"vaapste.no":true,"vega.no":true,"vegarshei.no":true,"xn--vegrshei-c0a.no":true,"vennesla.no":true,"verdal.no":true,"verran.no":true,"vestby.no":true,"vestnes.no":true,"vestre-slidre.no":true,"vestre-toten.no":true,"vestvagoy.no":true,"xn--vestvgy-ixa6o.no":true,"vevelstad.no":true,"vik.no":true,"vikna.no":true,"vindafjord.no":true,"volda.no":true,"voss.no":true,"varoy.no":true,"xn--vry-yla5g.no":true,"vagan.no":true,"xn--vgan-qoa.no":true,"voagat.no":true,"vagsoy.no":true,"xn--vgsy-qoa0j.no":true,"vaga.no":true,"xn--vg-yiab.no":true,"valer.ostfold.no":true,"xn--vler-qoa.xn--stfold-9xa.no":true,"valer.hedmark.no":true,"xn--vler-qoa.hedmark.no":true,"*.np":true,"nr":true,"biz.nr":true,"info.nr":true,"gov.nr":true,"edu.nr":true,"org.nr":true,"net.nr":true,"com.nr":true,"nu":true,"nz":true,"ac.nz":true,"co.nz":true,"cri.nz":true,"geek.nz":true,"gen.nz":true,"govt.nz":true,"health.nz":true,"iwi.nz":true,"kiwi.nz":true,"maori.nz":true,"mil.nz":true,"xn--mori-qsa.nz":true,"net.nz":true,"org.nz":true,"parliament.nz":true,"school.nz":true,"om":true,"co.om":true,"com.om":true,"edu.om":true,"gov.om":true,"med.om":true,"museum.om":true,"net.om":true,"org.om":true,"pro.om":true,"org":true,"pa":true,"ac.pa":true,"gob.pa":true,"com.pa":true,"org.pa":true,"sld.pa":true,"edu.pa":true,"net.pa":true,"ing.pa":true,"abo.pa":true,"med.pa":true,"nom.pa":true,"pe":true,"edu.pe":true,"gob.pe":true,"nom.pe":true,"mil.pe":true,"org.pe":true,"com.pe":true,"net.pe":true,"pf":true,"com.pf":true,"org.pf":true,"edu.pf":true,"*.pg":true,"ph":true,"com.ph":true,"net.ph":true,"org.ph":true,"gov.ph":true,"edu.ph":true,"ngo.ph":true,"mil.ph":true,"i.ph":true,"pk":true,"com.pk":true,"net.pk":true,"edu.pk":true,"org.pk":true,"fam.pk":true,"biz.pk":true,"web.pk":true,"gov.pk":true,"gob.pk":true,"gok.pk":true,"gon.pk":true,"gop.pk":true,"gos.pk":true,"info.pk":true,"pl":true,"com.pl":true,"net.pl":true,"org.pl":true,"aid.pl":true,"agro.pl":true,"atm.pl":true,"auto.pl":true,"biz.pl":true,"edu.pl":true,"gmina.pl":true,"gsm.pl":true,"info.pl":true,"mail.pl":true,"miasta.pl":true,"media.pl":true,"mil.pl":true,"nieruchomosci.pl":true,"nom.pl":true,"pc.pl":true,"powiat.pl":true,"priv.pl":true,"realestate.pl":true,"rel.pl":true,"sex.pl":true,"shop.pl":true,"sklep.pl":true,"sos.pl":true,"szkola.pl":true,"targi.pl":true,"tm.pl":true,"tourism.pl":true,"travel.pl":true,"turystyka.pl":true,"gov.pl":true,"ap.gov.pl":true,"ic.gov.pl":true,"is.gov.pl":true,"us.gov.pl":true,"kmpsp.gov.pl":true,"kppsp.gov.pl":true,"kwpsp.gov.pl":true,"psp.gov.pl":true,"wskr.gov.pl":true,"kwp.gov.pl":true,"mw.gov.pl":true,"ug.gov.pl":true,"um.gov.pl":true,"umig.gov.pl":true,"ugim.gov.pl":true,"upow.gov.pl":true,"uw.gov.pl":true,"starostwo.gov.pl":true,"pa.gov.pl":true,"po.gov.pl":true,"psse.gov.pl":true,"pup.gov.pl":true,"rzgw.gov.pl":true,"sa.gov.pl":true,"so.gov.pl":true,"sr.gov.pl":true,"wsa.gov.pl":true,"sko.gov.pl":true,"uzs.gov.pl":true,"wiih.gov.pl":true,"winb.gov.pl":true,"pinb.gov.pl":true,"wios.gov.pl":true,"witd.gov.pl":true,"wzmiuw.gov.pl":true,"piw.gov.pl":true,"wiw.gov.pl":true,"griw.gov.pl":true,"wif.gov.pl":true,"oum.gov.pl":true,"sdn.gov.pl":true,"zp.gov.pl":true,"uppo.gov.pl":true,"mup.gov.pl":true,"wuoz.gov.pl":true,"konsulat.gov.pl":true,"oirm.gov.pl":true,"augustow.pl":true,"babia-gora.pl":true,"bedzin.pl":true,"beskidy.pl":true,"bialowieza.pl":true,"bialystok.pl":true,"bielawa.pl":true,"bieszczady.pl":true,"boleslawiec.pl":true,"bydgoszcz.pl":true,"bytom.pl":true,"cieszyn.pl":true,"czeladz.pl":true,"czest.pl":true,"dlugoleka.pl":true,"elblag.pl":true,"elk.pl":true,"glogow.pl":true,"gniezno.pl":true,"gorlice.pl":true,"grajewo.pl":true,"ilawa.pl":true,"jaworzno.pl":true,"jelenia-gora.pl":true,"jgora.pl":true,"kalisz.pl":true,"kazimierz-dolny.pl":true,"karpacz.pl":true,"kartuzy.pl":true,"kaszuby.pl":true,"katowice.pl":true,"kepno.pl":true,"ketrzyn.pl":true,"klodzko.pl":true,"kobierzyce.pl":true,"kolobrzeg.pl":true,"konin.pl":true,"konskowola.pl":true,"kutno.pl":true,"lapy.pl":true,"lebork.pl":true,"legnica.pl":true,"lezajsk.pl":true,"limanowa.pl":true,"lomza.pl":true,"lowicz.pl":true,"lubin.pl":true,"lukow.pl":true,"malbork.pl":true,"malopolska.pl":true,"mazowsze.pl":true,"mazury.pl":true,"mielec.pl":true,"mielno.pl":true,"mragowo.pl":true,"naklo.pl":true,"nowaruda.pl":true,"nysa.pl":true,"olawa.pl":true,"olecko.pl":true,"olkusz.pl":true,"olsztyn.pl":true,"opoczno.pl":true,"opole.pl":true,"ostroda.pl":true,"ostroleka.pl":true,"ostrowiec.pl":true,"ostrowwlkp.pl":true,"pila.pl":true,"pisz.pl":true,"podhale.pl":true,"podlasie.pl":true,"polkowice.pl":true,"pomorze.pl":true,"pomorskie.pl":true,"prochowice.pl":true,"pruszkow.pl":true,"przeworsk.pl":true,"pulawy.pl":true,"radom.pl":true,"rawa-maz.pl":true,"rybnik.pl":true,"rzeszow.pl":true,"sanok.pl":true,"sejny.pl":true,"slask.pl":true,"slupsk.pl":true,"sosnowiec.pl":true,"stalowa-wola.pl":true,"skoczow.pl":true,"starachowice.pl":true,"stargard.pl":true,"suwalki.pl":true,"swidnica.pl":true,"swiebodzin.pl":true,"swinoujscie.pl":true,"szczecin.pl":true,"szczytno.pl":true,"tarnobrzeg.pl":true,"tgory.pl":true,"turek.pl":true,"tychy.pl":true,"ustka.pl":true,"walbrzych.pl":true,"warmia.pl":true,"warszawa.pl":true,"waw.pl":true,"wegrow.pl":true,"wielun.pl":true,"wlocl.pl":true,"wloclawek.pl":true,"wodzislaw.pl":true,"wolomin.pl":true,"wroclaw.pl":true,"zachpomor.pl":true,"zagan.pl":true,"zarow.pl":true,"zgora.pl":true,"zgorzelec.pl":true,"pm":true,"pn":true,"gov.pn":true,"co.pn":true,"org.pn":true,"edu.pn":true,"net.pn":true,"post":true,"pr":true,"com.pr":true,"net.pr":true,"org.pr":true,"gov.pr":true,"edu.pr":true,"isla.pr":true,"pro.pr":true,"biz.pr":true,"info.pr":true,"name.pr":true,"est.pr":true,"prof.pr":true,"ac.pr":true,"pro":true,"aca.pro":true,"bar.pro":true,"cpa.pro":true,"jur.pro":true,"law.pro":true,"med.pro":true,"eng.pro":true,"ps":true,"edu.ps":true,"gov.ps":true,"sec.ps":true,"plo.ps":true,"com.ps":true,"org.ps":true,"net.ps":true,"pt":true,"net.pt":true,"gov.pt":true,"org.pt":true,"edu.pt":true,"int.pt":true,"publ.pt":true,"com.pt":true,"nome.pt":true,"pw":true,"co.pw":true,"ne.pw":true,"or.pw":true,"ed.pw":true,"go.pw":true,"belau.pw":true,"py":true,"com.py":true,"coop.py":true,"edu.py":true,"gov.py":true,"mil.py":true,"net.py":true,"org.py":true,"qa":true,"com.qa":true,"edu.qa":true,"gov.qa":true,"mil.qa":true,"name.qa":true,"net.qa":true,"org.qa":true,"sch.qa":true,"re":true,"com.re":true,"asso.re":true,"nom.re":true,"ro":true,"com.ro":true,"org.ro":true,"tm.ro":true,"nt.ro":true,"nom.ro":true,"info.ro":true,"rec.ro":true,"arts.ro":true,"firm.ro":true,"store.ro":true,"www.ro":true,"rs":true,"co.rs":true,"org.rs":true,"edu.rs":true,"ac.rs":true,"gov.rs":true,"in.rs":true,"ru":true,"ac.ru":true,"com.ru":true,"edu.ru":true,"int.ru":true,"net.ru":true,"org.ru":true,"pp.ru":true,"adygeya.ru":true,"altai.ru":true,"amur.ru":true,"arkhangelsk.ru":true,"astrakhan.ru":true,"bashkiria.ru":true,"belgorod.ru":true,"bir.ru":true,"bryansk.ru":true,"buryatia.ru":true,"cbg.ru":true,"chel.ru":true,"chelyabinsk.ru":true,"chita.ru":true,"chukotka.ru":true,"chuvashia.ru":true,"dagestan.ru":true,"dudinka.ru":true,"e-burg.ru":true,"grozny.ru":true,"irkutsk.ru":true,"ivanovo.ru":true,"izhevsk.ru":true,"jar.ru":true,"joshkar-ola.ru":true,"kalmykia.ru":true,"kaluga.ru":true,"kamchatka.ru":true,"karelia.ru":true,"kazan.ru":true,"kchr.ru":true,"kemerovo.ru":true,"khabarovsk.ru":true,"khakassia.ru":true,"khv.ru":true,"kirov.ru":true,"koenig.ru":true,"komi.ru":true,"kostroma.ru":true,"krasnoyarsk.ru":true,"kuban.ru":true,"kurgan.ru":true,"kursk.ru":true,"lipetsk.ru":true,"magadan.ru":true,"mari.ru":true,"mari-el.ru":true,"marine.ru":true,"mordovia.ru":true,"msk.ru":true,"murmansk.ru":true,"nalchik.ru":true,"nnov.ru":true,"nov.ru":true,"novosibirsk.ru":true,"nsk.ru":true,"omsk.ru":true,"orenburg.ru":true,"oryol.ru":true,"palana.ru":true,"penza.ru":true,"perm.ru":true,"ptz.ru":true,"rnd.ru":true,"ryazan.ru":true,"sakhalin.ru":true,"samara.ru":true,"saratov.ru":true,"simbirsk.ru":true,"smolensk.ru":true,"spb.ru":true,"stavropol.ru":true,"stv.ru":true,"surgut.ru":true,"tambov.ru":true,"tatarstan.ru":true,"tom.ru":true,"tomsk.ru":true,"tsaritsyn.ru":true,"tsk.ru":true,"tula.ru":true,"tuva.ru":true,"tver.ru":true,"tyumen.ru":true,"udm.ru":true,"udmurtia.ru":true,"ulan-ude.ru":true,"vladikavkaz.ru":true,"vladimir.ru":true,"vladivostok.ru":true,"volgograd.ru":true,"vologda.ru":true,"voronezh.ru":true,"vrn.ru":true,"vyatka.ru":true,"yakutia.ru":true,"yamal.ru":true,"yaroslavl.ru":true,"yekaterinburg.ru":true,"yuzhno-sakhalinsk.ru":true,"amursk.ru":true,"baikal.ru":true,"cmw.ru":true,"fareast.ru":true,"jamal.ru":true,"kms.ru":true,"k-uralsk.ru":true,"kustanai.ru":true,"kuzbass.ru":true,"magnitka.ru":true,"mytis.ru":true,"nakhodka.ru":true,"nkz.ru":true,"norilsk.ru":true,"oskol.ru":true,"pyatigorsk.ru":true,"rubtsovsk.ru":true,"snz.ru":true,"syzran.ru":true,"vdonsk.ru":true,"zgrad.ru":true,"gov.ru":true,"mil.ru":true,"test.ru":true,"rw":true,"gov.rw":true,"net.rw":true,"edu.rw":true,"ac.rw":true,"com.rw":true,"co.rw":true,"int.rw":true,"mil.rw":true,"gouv.rw":true,"sa":true,"com.sa":true,"net.sa":true,"org.sa":true,"gov.sa":true,"med.sa":true,"pub.sa":true,"edu.sa":true,"sch.sa":true,"sb":true,"com.sb":true,"edu.sb":true,"gov.sb":true,"net.sb":true,"org.sb":true,"sc":true,"com.sc":true,"gov.sc":true,"net.sc":true,"org.sc":true,"edu.sc":true,"sd":true,"com.sd":true,"net.sd":true,"org.sd":true,"edu.sd":true,"med.sd":true,"tv.sd":true,"gov.sd":true,"info.sd":true,"se":true,"a.se":true,"ac.se":true,"b.se":true,"bd.se":true,"brand.se":true,"c.se":true,"d.se":true,"e.se":true,"f.se":true,"fh.se":true,"fhsk.se":true,"fhv.se":true,"g.se":true,"h.se":true,"i.se":true,"k.se":true,"komforb.se":true,"kommunalforbund.se":true,"komvux.se":true,"l.se":true,"lanbib.se":true,"m.se":true,"n.se":true,"naturbruksgymn.se":true,"o.se":true,"org.se":true,"p.se":true,"parti.se":true,"pp.se":true,"press.se":true,"r.se":true,"s.se":true,"t.se":true,"tm.se":true,"u.se":true,"w.se":true,"x.se":true,"y.se":true,"z.se":true,"sg":true,"com.sg":true,"net.sg":true,"org.sg":true,"gov.sg":true,"edu.sg":true,"per.sg":true,"sh":true,"com.sh":true,"net.sh":true,"gov.sh":true,"org.sh":true,"mil.sh":true,"si":true,"sj":true,"sk":true,"sl":true,"com.sl":true,"net.sl":true,"edu.sl":true,"gov.sl":true,"org.sl":true,"sm":true,"sn":true,"art.sn":true,"com.sn":true,"edu.sn":true,"gouv.sn":true,"org.sn":true,"perso.sn":true,"univ.sn":true,"so":true,"com.so":true,"net.so":true,"org.so":true,"sr":true,"st":true,"co.st":true,"com.st":true,"consulado.st":true,"edu.st":true,"embaixada.st":true,"gov.st":true,"mil.st":true,"net.st":true,"org.st":true,"principe.st":true,"saotome.st":true,"store.st":true,"su":true,"adygeya.su":true,"arkhangelsk.su":true,"balashov.su":true,"bashkiria.su":true,"bryansk.su":true,"dagestan.su":true,"grozny.su":true,"ivanovo.su":true,"kalmykia.su":true,"kaluga.su":true,"karelia.su":true,"khakassia.su":true,"krasnodar.su":true,"kurgan.su":true,"lenug.su":true,"mordovia.su":true,"msk.su":true,"murmansk.su":true,"nalchik.su":true,"nov.su":true,"obninsk.su":true,"penza.su":true,"pokrovsk.su":true,"sochi.su":true,"spb.su":true,"togliatti.su":true,"troitsk.su":true,"tula.su":true,"tuva.su":true,"vladikavkaz.su":true,"vladimir.su":true,"vologda.su":true,"sv":true,"com.sv":true,"edu.sv":true,"gob.sv":true,"org.sv":true,"red.sv":true,"sx":true,"gov.sx":true,"sy":true,"edu.sy":true,"gov.sy":true,"net.sy":true,"mil.sy":true,"com.sy":true,"org.sy":true,"sz":true,"co.sz":true,"ac.sz":true,"org.sz":true,"tc":true,"td":true,"tel":true,"tf":true,"tg":true,"th":true,"ac.th":true,"co.th":true,"go.th":true,"in.th":true,"mi.th":true,"net.th":true,"or.th":true,"tj":true,"ac.tj":true,"biz.tj":true,"co.tj":true,"com.tj":true,"edu.tj":true,"go.tj":true,"gov.tj":true,"int.tj":true,"mil.tj":true,"name.tj":true,"net.tj":true,"nic.tj":true,"org.tj":true,"test.tj":true,"web.tj":true,"tk":true,"tl":true,"gov.tl":true,"tm":true,"com.tm":true,"co.tm":true,"org.tm":true,"net.tm":true,"nom.tm":true,"gov.tm":true,"mil.tm":true,"edu.tm":true,"tn":true,"com.tn":true,"ens.tn":true,"fin.tn":true,"gov.tn":true,"ind.tn":true,"intl.tn":true,"nat.tn":true,"net.tn":true,"org.tn":true,"info.tn":true,"perso.tn":true,"tourism.tn":true,"edunet.tn":true,"rnrt.tn":true,"rns.tn":true,"rnu.tn":true,"mincom.tn":true,"agrinet.tn":true,"defense.tn":true,"turen.tn":true,"to":true,"com.to":true,"gov.to":true,"net.to":true,"org.to":true,"edu.to":true,"mil.to":true,"tp":true,"tr":true,"com.tr":true,"info.tr":true,"biz.tr":true,"net.tr":true,"org.tr":true,"web.tr":true,"gen.tr":true,"tv.tr":true,"av.tr":true,"dr.tr":true,"bbs.tr":true,"name.tr":true,"tel.tr":true,"gov.tr":true,"bel.tr":true,"pol.tr":true,"mil.tr":true,"k12.tr":true,"edu.tr":true,"kep.tr":true,"nc.tr":true,"gov.nc.tr":true,"travel":true,"tt":true,"co.tt":true,"com.tt":true,"org.tt":true,"net.tt":true,"biz.tt":true,"info.tt":true,"pro.tt":true,"int.tt":true,"coop.tt":true,"jobs.tt":true,"mobi.tt":true,"travel.tt":true,"museum.tt":true,"aero.tt":true,"name.tt":true,"gov.tt":true,"edu.tt":true,"tv":true,"tw":true,"edu.tw":true,"gov.tw":true,"mil.tw":true,"com.tw":true,"net.tw":true,"org.tw":true,"idv.tw":true,"game.tw":true,"ebiz.tw":true,"club.tw":true,"xn--zf0ao64a.tw":true,"xn--uc0atv.tw":true,"xn--czrw28b.tw":true,"tz":true,"ac.tz":true,"co.tz":true,"go.tz":true,"hotel.tz":true,"info.tz":true,"me.tz":true,"mil.tz":true,"mobi.tz":true,"ne.tz":true,"or.tz":true,"sc.tz":true,"tv.tz":true,"ua":true,"com.ua":true,"edu.ua":true,"gov.ua":true,"in.ua":true,"net.ua":true,"org.ua":true,"cherkassy.ua":true,"cherkasy.ua":true,"chernigov.ua":true,"chernihiv.ua":true,"chernivtsi.ua":true,"chernovtsy.ua":true,"ck.ua":true,"cn.ua":true,"cr.ua":true,"crimea.ua":true,"cv.ua":true,"dn.ua":true,"dnepropetrovsk.ua":true,"dnipropetrovsk.ua":true,"dominic.ua":true,"donetsk.ua":true,"dp.ua":true,"if.ua":true,"ivano-frankivsk.ua":true,"kh.ua":true,"kharkiv.ua":true,"kharkov.ua":true,"kherson.ua":true,"khmelnitskiy.ua":true,"khmelnytskyi.ua":true,"kiev.ua":true,"kirovograd.ua":true,"km.ua":true,"kr.ua":true,"krym.ua":true,"ks.ua":true,"kv.ua":true,"kyiv.ua":true,"lg.ua":true,"lt.ua":true,"lugansk.ua":true,"lutsk.ua":true,"lv.ua":true,"lviv.ua":true,"mk.ua":true,"mykolaiv.ua":true,"nikolaev.ua":true,"od.ua":true,"odesa.ua":true,"odessa.ua":true,"pl.ua":true,"poltava.ua":true,"rivne.ua":true,"rovno.ua":true,"rv.ua":true,"sb.ua":true,"sebastopol.ua":true,"sevastopol.ua":true,"sm.ua":true,"sumy.ua":true,"te.ua":true,"ternopil.ua":true,"uz.ua":true,"uzhgorod.ua":true,"vinnica.ua":true,"vinnytsia.ua":true,"vn.ua":true,"volyn.ua":true,"yalta.ua":true,"zaporizhzhe.ua":true,"zaporizhzhia.ua":true,"zhitomir.ua":true,"zhytomyr.ua":true,"zp.ua":true,"zt.ua":true,"ug":true,"co.ug":true,"or.ug":true,"ac.ug":true,"sc.ug":true,"go.ug":true,"ne.ug":true,"com.ug":true,"org.ug":true,"uk":true,"ac.uk":true,"co.uk":true,"gov.uk":true,"ltd.uk":true,"me.uk":true,"net.uk":true,"nhs.uk":true,"org.uk":true,"plc.uk":true,"police.uk":true,"*.sch.uk":true,"us":true,"dni.us":true,"fed.us":true,"isa.us":true,"kids.us":true,"nsn.us":true,"ak.us":true,"al.us":true,"ar.us":true,"as.us":true,"az.us":true,"ca.us":true,"co.us":true,"ct.us":true,"dc.us":true,"de.us":true,"fl.us":true,"ga.us":true,"gu.us":true,"hi.us":true,"ia.us":true,"id.us":true,"il.us":true,"in.us":true,"ks.us":true,"ky.us":true,"la.us":true,"ma.us":true,"md.us":true,"me.us":true,"mi.us":true,"mn.us":true,"mo.us":true,"ms.us":true,"mt.us":true,"nc.us":true,"nd.us":true,"ne.us":true,"nh.us":true,"nj.us":true,"nm.us":true,"nv.us":true,"ny.us":true,"oh.us":true,"ok.us":true,"or.us":true,"pa.us":true,"pr.us":true,"ri.us":true,"sc.us":true,"sd.us":true,"tn.us":true,"tx.us":true,"ut.us":true,"vi.us":true,"vt.us":true,"va.us":true,"wa.us":true,"wi.us":true,"wv.us":true,"wy.us":true,"k12.ak.us":true,"k12.al.us":true,"k12.ar.us":true,"k12.as.us":true,"k12.az.us":true,"k12.ca.us":true,"k12.co.us":true,"k12.ct.us":true,"k12.dc.us":true,"k12.de.us":true,"k12.fl.us":true,"k12.ga.us":true,"k12.gu.us":true,"k12.ia.us":true,"k12.id.us":true,"k12.il.us":true,"k12.in.us":true,"k12.ks.us":true,"k12.ky.us":true,"k12.la.us":true,"k12.ma.us":true,"k12.md.us":true,"k12.me.us":true,"k12.mi.us":true,"k12.mn.us":true,"k12.mo.us":true,"k12.ms.us":true,"k12.mt.us":true,"k12.nc.us":true,"k12.ne.us":true,"k12.nh.us":true,"k12.nj.us":true,"k12.nm.us":true,"k12.nv.us":true,"k12.ny.us":true,"k12.oh.us":true,"k12.ok.us":true,"k12.or.us":true,"k12.pa.us":true,"k12.pr.us":true,"k12.ri.us":true,"k12.sc.us":true,"k12.tn.us":true,"k12.tx.us":true,"k12.ut.us":true,"k12.vi.us":true,"k12.vt.us":true,"k12.va.us":true,"k12.wa.us":true,"k12.wi.us":true,"k12.wy.us":true,"cc.ak.us":true,"cc.al.us":true,"cc.ar.us":true,"cc.as.us":true,"cc.az.us":true,"cc.ca.us":true,"cc.co.us":true,"cc.ct.us":true,"cc.dc.us":true,"cc.de.us":true,"cc.fl.us":true,"cc.ga.us":true,"cc.gu.us":true,"cc.hi.us":true,"cc.ia.us":true,"cc.id.us":true,"cc.il.us":true,"cc.in.us":true,"cc.ks.us":true,"cc.ky.us":true,"cc.la.us":true,"cc.ma.us":true,"cc.md.us":true,"cc.me.us":true,"cc.mi.us":true,"cc.mn.us":true,"cc.mo.us":true,"cc.ms.us":true,"cc.mt.us":true,"cc.nc.us":true,"cc.nd.us":true,"cc.ne.us":true,"cc.nh.us":true,"cc.nj.us":true,"cc.nm.us":true,"cc.nv.us":true,"cc.ny.us":true,"cc.oh.us":true,"cc.ok.us":true,"cc.or.us":true,"cc.pa.us":true,"cc.pr.us":true,"cc.ri.us":true,"cc.sc.us":true,"cc.sd.us":true,"cc.tn.us":true,"cc.tx.us":true,"cc.ut.us":true,"cc.vi.us":true,"cc.vt.us":true,"cc.va.us":true,"cc.wa.us":true,"cc.wi.us":true,"cc.wv.us":true,"cc.wy.us":true,"lib.ak.us":true,"lib.al.us":true,"lib.ar.us":true,"lib.as.us":true,"lib.az.us":true,"lib.ca.us":true,"lib.co.us":true,"lib.ct.us":true,"lib.dc.us":true,"lib.de.us":true,"lib.fl.us":true,"lib.ga.us":true,"lib.gu.us":true,"lib.hi.us":true,"lib.ia.us":true,"lib.id.us":true,"lib.il.us":true,"lib.in.us":true,"lib.ks.us":true,"lib.ky.us":true,"lib.la.us":true,"lib.ma.us":true,"lib.md.us":true,"lib.me.us":true,"lib.mi.us":true,"lib.mn.us":true,"lib.mo.us":true,"lib.ms.us":true,"lib.mt.us":true,"lib.nc.us":true,"lib.nd.us":true,"lib.ne.us":true,"lib.nh.us":true,"lib.nj.us":true,"lib.nm.us":true,"lib.nv.us":true,"lib.ny.us":true,"lib.oh.us":true,"lib.ok.us":true,"lib.or.us":true,"lib.pa.us":true,"lib.pr.us":true,"lib.ri.us":true,"lib.sc.us":true,"lib.sd.us":true,"lib.tn.us":true,"lib.tx.us":true,"lib.ut.us":true,"lib.vi.us":true,"lib.vt.us":true,"lib.va.us":true,"lib.wa.us":true,"lib.wi.us":true,"lib.wy.us":true,"pvt.k12.ma.us":true,"chtr.k12.ma.us":true,"paroch.k12.ma.us":true,"uy":true,"com.uy":true,"edu.uy":true,"gub.uy":true,"mil.uy":true,"net.uy":true,"org.uy":true,"uz":true,"co.uz":true,"com.uz":true,"net.uz":true,"org.uz":true,"va":true,"vc":true,"com.vc":true,"net.vc":true,"org.vc":true,"gov.vc":true,"mil.vc":true,"edu.vc":true,"ve":true,"arts.ve":true,"co.ve":true,"com.ve":true,"e12.ve":true,"edu.ve":true,"firm.ve":true,"gob.ve":true,"gov.ve":true,"info.ve":true,"int.ve":true,"mil.ve":true,"net.ve":true,"org.ve":true,"rec.ve":true,"store.ve":true,"tec.ve":true,"web.ve":true,"vg":true,"vi":true,"co.vi":true,"com.vi":true,"k12.vi":true,"net.vi":true,"org.vi":true,"vn":true,"com.vn":true,"net.vn":true,"org.vn":true,"edu.vn":true,"gov.vn":true,"int.vn":true,"ac.vn":true,"biz.vn":true,"info.vn":true,"name.vn":true,"pro.vn":true,"health.vn":true,"vu":true,"com.vu":true,"edu.vu":true,"net.vu":true,"org.vu":true,"wf":true,"ws":true,"com.ws":true,"net.ws":true,"org.ws":true,"gov.ws":true,"edu.ws":true,"yt":true,"xn--mgbaam7a8h":true,"xn--y9a3aq":true,"xn--54b7fta0cc":true,"xn--90ais":true,"xn--fiqs8s":true,"xn--fiqz9s":true,"xn--lgbbat1ad8j":true,"xn--wgbh1c":true,"xn--node":true,"xn--qxam":true,"xn--j6w193g":true,"xn--h2brj9c":true,"xn--mgbbh1a71e":true,"xn--fpcrj9c3d":true,"xn--gecrj9c":true,"xn--s9brj9c":true,"xn--45brj9c":true,"xn--xkc2dl3a5ee0h":true,"xn--mgba3a4f16a":true,"xn--mgba3a4fra":true,"xn--mgbtx2b":true,"xn--mgbayh7gpa":true,"xn--3e0b707e":true,"xn--80ao21a":true,"xn--fzc2c9e2c":true,"xn--xkc2al3hye2a":true,"xn--mgbc0a9azcg":true,"xn--d1alf":true,"xn--l1acc":true,"xn--mix891f":true,"xn--mix082f":true,"xn--mgbx4cd0ab":true,"xn--mgb9awbf":true,"xn--mgbai9azgqp6j":true,"xn--mgbai9a5eva00b":true,"xn--ygbi2ammx":true,"xn--90a3ac":true,"xn--o1ac.xn--90a3ac":true,"xn--c1avg.xn--90a3ac":true,"xn--90azh.xn--90a3ac":true,"xn--d1at.xn--90a3ac":true,"xn--o1ach.xn--90a3ac":true,"xn--80au.xn--90a3ac":true,"xn--p1ai":true,"xn--wgbl6a":true,"xn--mgberp4a5d4ar":true,"xn--mgberp4a5d4a87g":true,"xn--mgbqly7c0a67fbc":true,"xn--mgbqly7cvafr":true,"xn--mgbpl2fh":true,"xn--yfro4i67o":true,"xn--clchc0ea0b2g2a9gcd":true,"xn--ogbpf8fl":true,"xn--mgbtf8fl":true,"xn--o3cw4h":true,"xn--pgbs0dh":true,"xn--kpry57d":true,"xn--kprw13d":true,"xn--nnx388a":true,"xn--j1amh":true,"xn--mgb2ddes":true,"xxx":true,"*.ye":true,"ac.za":true,"agrica.za":true,"alt.za":true,"co.za":true,"edu.za":true,"gov.za":true,"grondar.za":true,"law.za":true,"mil.za":true,"net.za":true,"ngo.za":true,"nis.za":true,"nom.za":true,"org.za":true,"school.za":true,"tm.za":true,"web.za":true,"*.zm":true,"*.zw":true,"aaa":true,"aarp":true,"abarth":true,"abb":true,"abbott":true,"abbvie":true,"abc":true,"able":true,"abogado":true,"abudhabi":true,"academy":true,"accenture":true,"accountant":true,"accountants":true,"aco":true,"active":true,"actor":true,"adac":true,"ads":true,"adult":true,"aeg":true,"aetna":true,"afamilycompany":true,"afl":true,"africa":true,"africamagic":true,"agakhan":true,"agency":true,"aig":true,"aigo":true,"airbus":true,"airforce":true,"airtel":true,"akdn":true,"alfaromeo":true,"alibaba":true,"alipay":true,"allfinanz":true,"allstate":true,"ally":true,"alsace":true,"alstom":true,"americanexpress":true,"americanfamily":true,"amex":true,"amfam":true,"amica":true,"amsterdam":true,"analytics":true,"android":true,"anquan":true,"anz":true,"aol":true,"apartments":true,"app":true,"apple":true,"aquarelle":true,"aramco":true,"archi":true,"army":true,"arte":true,"asda":true,"associates":true,"athleta":true,"attorney":true,"auction":true,"audi":true,"audible":true,"audio":true,"auspost":true,"author":true,"auto":true,"autos":true,"avianca":true,"aws":true,"axa":true,"azure":true,"baby":true,"baidu":true,"banamex":true,"bananarepublic":true,"band":true,"bank":true,"bar":true,"barcelona":true,"barclaycard":true,"barclays":true,"barefoot":true,"bargains":true,"basketball":true,"bauhaus":true,"bayern":true,"bbc":true,"bbt":true,"bbva":true,"bcg":true,"bcn":true,"beats":true,"beer":true,"bentley":true,"berlin":true,"best":true,"bestbuy":true,"bet":true,"bharti":true,"bible":true,"bid":true,"bike":true,"bing":true,"bingo":true,"bio":true,"black":true,"blackfriday":true,"blanco":true,"blockbuster":true,"blog":true,"bloomberg":true,"blue":true,"bms":true,"bmw":true,"bnl":true,"bnpparibas":true,"boats":true,"boehringer":true,"bofa":true,"bom":true,"bond":true,"boo":true,"book":true,"booking":true,"boots":true,"bosch":true,"bostik":true,"bot":true,"boutique":true,"bradesco":true,"bridgestone":true,"broadway":true,"broker":true,"brother":true,"brussels":true,"budapest":true,"bugatti":true,"build":true,"builders":true,"business":true,"buy":true,"buzz":true,"bzh":true,"cab":true,"cafe":true,"cal":true,"call":true,"calvinklein":true,"camera":true,"camp":true,"cancerresearch":true,"canon":true,"capetown":true,"capital":true,"capitalone":true,"car":true,"caravan":true,"cards":true,"care":true,"career":true,"careers":true,"cars":true,"cartier":true,"casa":true,"case":true,"caseih":true,"cash":true,"casino":true,"catering":true,"cba":true,"cbn":true,"cbre":true,"cbs":true,"ceb":true,"center":true,"ceo":true,"cern":true,"cfa":true,"cfd":true,"chanel":true,"channel":true,"chase":true,"chat":true,"cheap":true,"chintai":true,"chloe":true,"christmas":true,"chrome":true,"chrysler":true,"church":true,"cipriani":true,"circle":true,"cisco":true,"citadel":true,"citi":true,"citic":true,"city":true,"cityeats":true,"claims":true,"cleaning":true,"click":true,"clinic":true,"clothing":true,"cloud":true,"club":true,"clubmed":true,"coach":true,"codes":true,"coffee":true,"college":true,"cologne":true,"comcast":true,"commbank":true,"community":true,"company":true,"computer":true,"comsec":true,"condos":true,"construction":true,"consulting":true,"contact":true,"contractors":true,"cooking":true,"cookingchannel":true,"cool":true,"corsica":true,"country":true,"coupon":true,"coupons":true,"courses":true,"credit":true,"creditcard":true,"creditunion":true,"cricket":true,"crown":true,"crs":true,"cruises":true,"csc":true,"cuisinella":true,"cymru":true,"cyou":true,"dabur":true,"dad":true,"dance":true,"date":true,"dating":true,"datsun":true,"day":true,"dclk":true,"dds":true,"deal":true,"dealer":true,"deals":true,"degree":true,"delivery":true,"dell":true,"deloitte":true,"delta":true,"democrat":true,"dental":true,"dentist":true,"desi":true,"design":true,"dev":true,"dhl":true,"diamonds":true,"diet":true,"digital":true,"direct":true,"directory":true,"discount":true,"discover":true,"dish":true,"dnp":true,"docs":true,"dodge":true,"dog":true,"doha":true,"domains":true,"doosan":true,"dot":true,"download":true,"drive":true,"dstv":true,"dtv":true,"dubai":true,"duck":true,"dunlop":true,"duns":true,"dupont":true,"durban":true,"dvag":true,"dwg":true,"earth":true,"eat":true,"edeka":true,"education":true,"email":true,"emerck":true,"emerson":true,"energy":true,"engineer":true,"engineering":true,"enterprises":true,"epost":true,"epson":true,"equipment":true,"ericsson":true,"erni":true,"esq":true,"estate":true,"esurance":true,"etisalat":true,"eurovision":true,"eus":true,"events":true,"everbank":true,"exchange":true,"expert":true,"exposed":true,"express":true,"extraspace":true,"fage":true,"fail":true,"fairwinds":true,"faith":true,"family":true,"fan":true,"fans":true,"farm":true,"farmers":true,"fashion":true,"fast":true,"fedex":true,"feedback":true,"ferrari":true,"ferrero":true,"fiat":true,"fidelity":true,"fido":true,"film":true,"final":true,"finance":true,"financial":true,"fire":true,"firestone":true,"firmdale":true,"fish":true,"fishing":true,"fit":true,"fitness":true,"flickr":true,"flights":true,"flir":true,"florist":true,"flowers":true,"flsmidth":true,"fly":true,"foo":true,"foodnetwork":true,"football":true,"ford":true,"forex":true,"forsale":true,"forum":true,"foundation":true,"fox":true,"fresenius":true,"frl":true,"frogans":true,"frontdoor":true,"frontier":true,"ftr":true,"fujitsu":true,"fujixerox":true,"fund":true,"furniture":true,"futbol":true,"fyi":true,"gal":true,"gallery":true,"gallo":true,"gallup":true,"game":true,"games":true,"gap":true,"garden":true,"gbiz":true,"gdn":true,"gea":true,"gent":true,"genting":true,"george":true,"ggee":true,"gift":true,"gifts":true,"gives":true,"giving":true,"glade":true,"glass":true,"gle":true,"global":true,"globo":true,"gmail":true,"gmo":true,"gmx":true,"godaddy":true,"gold":true,"goldpoint":true,"golf":true,"goo":true,"goodhands":true,"goodyear":true,"goog":true,"google":true,"gop":true,"got":true,"gotv":true,"grainger":true,"graphics":true,"gratis":true,"green":true,"gripe":true,"group":true,"guardian":true,"gucci":true,"guge":true,"guide":true,"guitars":true,"guru":true,"hamburg":true,"hangout":true,"haus":true,"hbo":true,"hdfc":true,"hdfcbank":true,"health":true,"healthcare":true,"help":true,"helsinki":true,"here":true,"hermes":true,"hgtv":true,"hiphop":true,"hisamitsu":true,"hitachi":true,"hiv":true,"hkt":true,"hockey":true,"holdings":true,"holiday":true,"homedepot":true,"homegoods":true,"homes":true,"homesense":true,"honda":true,"honeywell":true,"horse":true,"host":true,"hosting":true,"hot":true,"hoteles":true,"hotmail":true,"house":true,"how":true,"hsbc":true,"htc":true,"hughes":true,"hyatt":true,"hyundai":true,"ibm":true,"icbc":true,"ice":true,"icu":true,"ieee":true,"ifm":true,"iinet":true,"ikano":true,"imamat":true,"imdb":true,"immo":true,"immobilien":true,"industries":true,"infiniti":true,"ing":true,"ink":true,"institute":true,"insurance":true,"insure":true,"intel":true,"international":true,"intuit":true,"investments":true,"ipiranga":true,"irish":true,"iselect":true,"ismaili":true,"ist":true,"istanbul":true,"itau":true,"itv":true,"iveco":true,"iwc":true,"jaguar":true,"java":true,"jcb":true,"jcp":true,"jeep":true,"jetzt":true,"jewelry":true,"jio":true,"jlc":true,"jll":true,"jmp":true,"jnj":true,"joburg":true,"jot":true,"joy":true,"jpmorgan":true,"jprs":true,"juegos":true,"juniper":true,"kaufen":true,"kddi":true,"kerryhotels":true,"kerrylogistics":true,"kerryproperties":true,"kfh":true,"kia":true,"kim":true,"kinder":true,"kindle":true,"kitchen":true,"kiwi":true,"koeln":true,"komatsu":true,"kosher":true,"kpmg":true,"kpn":true,"krd":true,"kred":true,"kuokgroup":true,"kyknet":true,"kyoto":true,"lacaixa":true,"ladbrokes":true,"lamborghini":true,"lancaster":true,"lancia":true,"lancome":true,"land":true,"landrover":true,"lanxess":true,"lasalle":true,"lat":true,"latino":true,"latrobe":true,"law":true,"lawyer":true,"lds":true,"lease":true,"leclerc":true,"lefrak":true,"legal":true,"lego":true,"lexus":true,"lgbt":true,"liaison":true,"lidl":true,"life":true,"lifeinsurance":true,"lifestyle":true,"lighting":true,"like":true,"lilly":true,"limited":true,"limo":true,"lincoln":true,"linde":true,"link":true,"lipsy":true,"live":true,"living":true,"lixil":true,"loan":true,"loans":true,"locker":true,"locus":true,"loft":true,"lol":true,"london":true,"lotte":true,"lotto":true,"love":true,"lpl":true,"lplfinancial":true,"ltd":true,"ltda":true,"lundbeck":true,"lupin":true,"luxe":true,"luxury":true,"macys":true,"madrid":true,"maif":true,"maison":true,"makeup":true,"man":true,"management":true,"mango":true,"market":true,"marketing":true,"markets":true,"marriott":true,"marshalls":true,"maserati":true,"mattel":true,"mba":true,"mcd":true,"mcdonalds":true,"mckinsey":true,"med":true,"media":true,"meet":true,"melbourne":true,"meme":true,"memorial":true,"men":true,"menu":true,"meo":true,"metlife":true,"miami":true,"microsoft":true,"mini":true,"mint":true,"mit":true,"mitsubishi":true,"mlb":true,"mls":true,"mma":true,"mnet":true,"mobily":true,"moda":true,"moe":true,"moi":true,"mom":true,"monash":true,"money":true,"monster":true,"montblanc":true,"mopar":true,"mormon":true,"mortgage":true,"moscow":true,"moto":true,"motorcycles":true,"mov":true,"movie":true,"movistar":true,"msd":true,"mtn":true,"mtpc":true,"mtr":true,"multichoice":true,"mutual":true,"mutuelle":true,"mzansimagic":true,"nab":true,"nadex":true,"nagoya":true,"naspers":true,"nationwide":true,"natura":true,"navy":true,"nba":true,"nec":true,"netbank":true,"netflix":true,"network":true,"neustar":true,"new":true,"newholland":true,"news":true,"next":true,"nextdirect":true,"nexus":true,"nfl":true,"ngo":true,"nhk":true,"nico":true,"nike":true,"nikon":true,"ninja":true,"nissan":true,"nokia":true,"northwesternmutual":true,"norton":true,"now":true,"nowruz":true,"nowtv":true,"nra":true,"nrw":true,"ntt":true,"nyc":true,"obi":true,"observer":true,"off":true,"office":true,"okinawa":true,"olayan":true,"olayangroup":true,"oldnavy":true,"ollo":true,"omega":true,"one":true,"ong":true,"onl":true,"online":true,"onyourside":true,"ooo":true,"open":true,"oracle":true,"orange":true,"organic":true,"orientexpress":true,"osaka":true,"otsuka":true,"ott":true,"ovh":true,"page":true,"pamperedchef":true,"panasonic":true,"panerai":true,"paris":true,"pars":true,"partners":true,"parts":true,"party":true,"passagens":true,"pay":true,"payu":true,"pccw":true,"pet":true,"pfizer":true,"pharmacy":true,"philips":true,"photo":true,"photography":true,"photos":true,"physio":true,"piaget":true,"pics":true,"pictet":true,"pictures":true,"pid":true,"pin":true,"ping":true,"pink":true,"pioneer":true,"pizza":true,"place":true,"play":true,"playstation":true,"plumbing":true,"plus":true,"pnc":true,"pohl":true,"poker":true,"politie":true,"porn":true,"pramerica":true,"praxi":true,"press":true,"prime":true,"prod":true,"productions":true,"prof":true,"progressive":true,"promo":true,"properties":true,"property":true,"protection":true,"pru":true,"prudential":true,"pub":true,"qpon":true,"quebec":true,"quest":true,"qvc":true,"racing":true,"raid":true,"read":true,"realestate":true,"realtor":true,"realty":true,"recipes":true,"red":true,"redstone":true,"redumbrella":true,"rehab":true,"reise":true,"reisen":true,"reit":true,"reliance":true,"ren":true,"rent":true,"rentals":true,"repair":true,"report":true,"republican":true,"rest":true,"restaurant":true,"review":true,"reviews":true,"rexroth":true,"rich":true,"richardli":true,"ricoh":true,"rightathome":true,"ril":true,"rio":true,"rip":true,"rocher":true,"rocks":true,"rodeo":true,"rogers":true,"room":true,"rsvp":true,"ruhr":true,"run":true,"rwe":true,"ryukyu":true,"saarland":true,"safe":true,"safety":true,"sakura":true,"sale":true,"salon":true,"samsclub":true,"samsung":true,"sandvik":true,"sandvikcoromant":true,"sanofi":true,"sap":true,"sapo":true,"sarl":true,"sas":true,"save":true,"saxo":true,"sbi":true,"sbs":true,"sca":true,"scb":true,"schaeffler":true,"schmidt":true,"scholarships":true,"school":true,"schule":true,"schwarz":true,"science":true,"scjohnson":true,"scor":true,"scot":true,"seat":true,"secure":true,"security":true,"seek":true,"sener":true,"services":true,"ses":true,"seven":true,"sew":true,"sex":true,"sexy":true,"sfr":true,"shangrila":true,"sharp":true,"shaw":true,"shell":true,"shia":true,"shiksha":true,"shoes":true,"shouji":true,"show":true,"showtime":true,"shriram":true,"silk":true,"sina":true,"singles":true,"site":true,"ski":true,"skin":true,"sky":true,"skype":true,"sling":true,"smart":true,"smile":true,"sncf":true,"soccer":true,"social":true,"softbank":true,"software":true,"sohu":true,"solar":true,"solutions":true,"song":true,"sony":true,"soy":true,"space":true,"spiegel":true,"spot":true,"spreadbetting":true,"srl":true,"srt":true,"stada":true,"staples":true,"star":true,"starhub":true,"statebank":true,"statefarm":true,"statoil":true,"stc":true,"stcgroup":true,"stockholm":true,"storage":true,"store":true,"studio":true,"study":true,"style":true,"sucks":true,"supersport":true,"supplies":true,"supply":true,"support":true,"surf":true,"surgery":true,"suzuki":true,"swatch":true,"swiftcover":true,"swiss":true,"sydney":true,"symantec":true,"systems":true,"tab":true,"taipei":true,"talk":true,"taobao":true,"target":true,"tatamotors":true,"tatar":true,"tattoo":true,"tax":true,"taxi":true,"tci":true,"tdk":true,"team":true,"tech":true,"technology":true,"telecity":true,"telefonica":true,"temasek":true,"tennis":true,"teva":true,"thd":true,"theater":true,"theatre":true,"theguardian":true,"tiaa":true,"tickets":true,"tienda":true,"tiffany":true,"tips":true,"tires":true,"tirol":true,"tjmaxx":true,"tjx":true,"tkmaxx":true,"tmall":true,"today":true,"tokyo":true,"tools":true,"top":true,"toray":true,"toshiba":true,"total":true,"tours":true,"town":true,"toyota":true,"toys":true,"trade":true,"trading":true,"training":true,"travelchannel":true,"travelers":true,"travelersinsurance":true,"trust":true,"trv":true,"tube":true,"tui":true,"tunes":true,"tushu":true,"tvs":true,"ubank":true,"ubs":true,"uconnect":true,"university":true,"uno":true,"uol":true,"ups":true,"vacations":true,"vana":true,"vanguard":true,"vegas":true,"ventures":true,"verisign":true,"versicherung":true,"vet":true,"viajes":true,"video":true,"vig":true,"viking":true,"villas":true,"vin":true,"vip":true,"virgin":true,"visa":true,"vision":true,"vista":true,"vistaprint":true,"viva":true,"vivo":true,"vlaanderen":true,"vodka":true,"volkswagen":true,"vote":true,"voting":true,"voto":true,"voyage":true,"vuelos":true,"wales":true,"walmart":true,"walter":true,"wang":true,"wanggou":true,"warman":true,"watch":true,"watches":true,"weather":true,"weatherchannel":true,"webcam":true,"weber":true,"website":true,"wed":true,"wedding":true,"weibo":true,"weir":true,"whoswho":true,"wien":true,"wiki":true,"williamhill":true,"win":true,"windows":true,"wine":true,"winners":true,"wme":true,"wolterskluwer":true,"woodside":true,"work":true,"works":true,"world":true,"wtc":true,"wtf":true,"xbox":true,"xerox":true,"xfinity":true,"xihuan":true,"xin":true,"xn--11b4c3d":true,"xn--1ck2e1b":true,"xn--1qqw23a":true,"xn--30rr7y":true,"xn--3bst00m":true,"xn--3ds443g":true,"xn--3oq18vl8pn36a":true,"xn--3pxu8k":true,"xn--42c2d9a":true,"xn--45q11c":true,"xn--4gbrim":true,"xn--4gq48lf9j":true,"xn--55qw42g":true,"xn--55qx5d":true,"xn--5su34j936bgsg":true,"xn--5tzm5g":true,"xn--6frz82g":true,"xn--6qq986b3xl":true,"xn--80adxhks":true,"xn--80asehdb":true,"xn--80aswg":true,"xn--8y0a063a":true,"xn--9dbq2a":true,"xn--9et52u":true,"xn--9krt00a":true,"xn--b4w605ferd":true,"xn--bck1b9a5dre4c":true,"xn--c1avg":true,"xn--c2br7g":true,"xn--cck2b3b":true,"xn--cg4bki":true,"xn--czr694b":true,"xn--czrs0t":true,"xn--czru2d":true,"xn--d1acj3b":true,"xn--eckvdtc9d":true,"xn--efvy88h":true,"xn--estv75g":true,"xn--fct429k":true,"xn--fhbei":true,"xn--fiq228c5hs":true,"xn--fiq64b":true,"xn--fjq720a":true,"xn--flw351e":true,"xn--fzys8d69uvgm":true,"xn--g2xx48c":true,"xn--gckr3f0f":true,"xn--hxt814e":true,"xn--i1b6b1a6a2e":true,"xn--imr513n":true,"xn--io0a7i":true,"xn--j1aef":true,"xn--jlq61u9w7b":true,"xn--jvr189m":true,"xn--kcrx77d1x4a":true,"xn--kpu716f":true,"xn--kput3i":true,"xn--mgba3a3ejt":true,"xn--mgba7c0bbn0a":true,"xn--mgbaakc7dvf":true,"xn--mgbab2bd":true,"xn--mgbb9fbpob":true,"xn--mgbca7dzdo":true,"xn--mgbt3dhd":true,"xn--mk1bu44c":true,"xn--mxtq1m":true,"xn--ngbc5azd":true,"xn--ngbe9e0a":true,"xn--nqv7f":true,"xn--nqv7fs00ema":true,"xn--nyqy26a":true,"xn--p1acf":true,"xn--pbt977c":true,"xn--pssy2u":true,"xn--q9jyb4c":true,"xn--qcka1pmc":true,"xn--rhqv96g":true,"xn--rovu88b":true,"xn--ses554g":true,"xn--t60b56a":true,"xn--tckwe":true,"xn--unup4y":true,"xn--vermgensberater-ctb":true,"xn--vermgensberatung-pwb":true,"xn--vhquv":true,"xn--vuq861b":true,"xn--w4r85el8fhu5dnra":true,"xn--w4rs40l":true,"xn--xhq521b":true,"xn--zfr164b":true,"xperia":true,"xyz":true,"yachts":true,"yahoo":true,"yamaxun":true,"yandex":true,"yodobashi":true,"yoga":true,"yokohama":true,"you":true,"youtube":true,"yun":true,"zappos":true,"zara":true,"zero":true,"zip":true,"zippo":true,"zone":true,"zuerich":true,"cloudfront.net":true,"ap-northeast-1.compute.amazonaws.com":true,"ap-southeast-1.compute.amazonaws.com":true,"ap-southeast-2.compute.amazonaws.com":true,"cn-north-1.compute.amazonaws.cn":true,"compute.amazonaws.cn":true,"compute.amazonaws.com":true,"compute-1.amazonaws.com":true,"eu-west-1.compute.amazonaws.com":true,"eu-central-1.compute.amazonaws.com":true,"sa-east-1.compute.amazonaws.com":true,"us-east-1.amazonaws.com":true,"us-gov-west-1.compute.amazonaws.com":true,"us-west-1.compute.amazonaws.com":true,"us-west-2.compute.amazonaws.com":true,"z-1.compute-1.amazonaws.com":true,"z-2.compute-1.amazonaws.com":true,"elasticbeanstalk.com":true,"elb.amazonaws.com":true,"s3.amazonaws.com":true,"s3-ap-northeast-1.amazonaws.com":true,"s3-ap-southeast-1.amazonaws.com":true,"s3-ap-southeast-2.amazonaws.com":true,"s3-external-1.amazonaws.com":true,"s3-external-2.amazonaws.com":true,"s3-fips-us-gov-west-1.amazonaws.com":true,"s3-eu-central-1.amazonaws.com":true,"s3-eu-west-1.amazonaws.com":true,"s3-sa-east-1.amazonaws.com":true,"s3-us-gov-west-1.amazonaws.com":true,"s3-us-west-1.amazonaws.com":true,"s3-us-west-2.amazonaws.com":true,"s3.cn-north-1.amazonaws.com.cn":true,"s3.eu-central-1.amazonaws.com":true,"betainabox.com":true,"ae.org":true,"ar.com":true,"br.com":true,"cn.com":true,"com.de":true,"com.se":true,"de.com":true,"eu.com":true,"gb.com":true,"gb.net":true,"hu.com":true,"hu.net":true,"jp.net":true,"jpn.com":true,"kr.com":true,"mex.com":true,"no.com":true,"qc.com":true,"ru.com":true,"sa.com":true,"se.com":true,"se.net":true,"uk.com":true,"uk.net":true,"us.com":true,"uy.com":true,"za.bz":true,"za.com":true,"africa.com":true,"gr.com":true,"in.net":true,"us.org":true,"co.com":true,"c.la":true,"cloudcontrolled.com":true,"cloudcontrolapp.com":true,"co.ca":true,"c.cdn77.org":true,"cdn77-ssl.net":true,"r.cdn77.net":true,"rsc.cdn77.org":true,"ssl.origin.cdn77-secure.org":true,"co.nl":true,"co.no":true,"*.platform.sh":true,"cupcake.is":true,"dreamhosters.com":true,"duckdns.org":true,"dyndns-at-home.com":true,"dyndns-at-work.com":true,"dyndns-blog.com":true,"dyndns-free.com":true,"dyndns-home.com":true,"dyndns-ip.com":true,"dyndns-mail.com":true,"dyndns-office.com":true,"dyndns-pics.com":true,"dyndns-remote.com":true,"dyndns-server.com":true,"dyndns-web.com":true,"dyndns-wiki.com":true,"dyndns-work.com":true,"dyndns.biz":true,"dyndns.info":true,"dyndns.org":true,"dyndns.tv":true,"at-band-camp.net":true,"ath.cx":true,"barrel-of-knowledge.info":true,"barrell-of-knowledge.info":true,"better-than.tv":true,"blogdns.com":true,"blogdns.net":true,"blogdns.org":true,"blogsite.org":true,"boldlygoingnowhere.org":true,"broke-it.net":true,"buyshouses.net":true,"cechire.com":true,"dnsalias.com":true,"dnsalias.net":true,"dnsalias.org":true,"dnsdojo.com":true,"dnsdojo.net":true,"dnsdojo.org":true,"does-it.net":true,"doesntexist.com":true,"doesntexist.org":true,"dontexist.com":true,"dontexist.net":true,"dontexist.org":true,"doomdns.com":true,"doomdns.org":true,"dvrdns.org":true,"dyn-o-saur.com":true,"dynalias.com":true,"dynalias.net":true,"dynalias.org":true,"dynathome.net":true,"dyndns.ws":true,"endofinternet.net":true,"endofinternet.org":true,"endoftheinternet.org":true,"est-a-la-maison.com":true,"est-a-la-masion.com":true,"est-le-patron.com":true,"est-mon-blogueur.com":true,"for-better.biz":true,"for-more.biz":true,"for-our.info":true,"for-some.biz":true,"for-the.biz":true,"forgot.her.name":true,"forgot.his.name":true,"from-ak.com":true,"from-al.com":true,"from-ar.com":true,"from-az.net":true,"from-ca.com":true,"from-co.net":true,"from-ct.com":true,"from-dc.com":true,"from-de.com":true,"from-fl.com":true,"from-ga.com":true,"from-hi.com":true,"from-ia.com":true,"from-id.com":true,"from-il.com":true,"from-in.com":true,"from-ks.com":true,"from-ky.com":true,"from-la.net":true,"from-ma.com":true,"from-md.com":true,"from-me.org":true,"from-mi.com":true,"from-mn.com":true,"from-mo.com":true,"from-ms.com":true,"from-mt.com":true,"from-nc.com":true,"from-nd.com":true,"from-ne.com":true,"from-nh.com":true,"from-nj.com":true,"from-nm.com":true,"from-nv.com":true,"from-ny.net":true,"from-oh.com":true,"from-ok.com":true,"from-or.com":true,"from-pa.com":true,"from-pr.com":true,"from-ri.com":true,"from-sc.com":true,"from-sd.com":true,"from-tn.com":true,"from-tx.com":true,"from-ut.com":true,"from-va.com":true,"from-vt.com":true,"from-wa.com":true,"from-wi.com":true,"from-wv.com":true,"from-wy.com":true,"ftpaccess.cc":true,"fuettertdasnetz.de":true,"game-host.org":true,"game-server.cc":true,"getmyip.com":true,"gets-it.net":true,"go.dyndns.org":true,"gotdns.com":true,"gotdns.org":true,"groks-the.info":true,"groks-this.info":true,"ham-radio-op.net":true,"here-for-more.info":true,"hobby-site.com":true,"hobby-site.org":true,"home.dyndns.org":true,"homedns.org":true,"homeftp.net":true,"homeftp.org":true,"homeip.net":true,"homelinux.com":true,"homelinux.net":true,"homelinux.org":true,"homeunix.com":true,"homeunix.net":true,"homeunix.org":true,"iamallama.com":true,"in-the-band.net":true,"is-a-anarchist.com":true,"is-a-blogger.com":true,"is-a-bookkeeper.com":true,"is-a-bruinsfan.org":true,"is-a-bulls-fan.com":true,"is-a-candidate.org":true,"is-a-caterer.com":true,"is-a-celticsfan.org":true,"is-a-chef.com":true,"is-a-chef.net":true,"is-a-chef.org":true,"is-a-conservative.com":true,"is-a-cpa.com":true,"is-a-cubicle-slave.com":true,"is-a-democrat.com":true,"is-a-designer.com":true,"is-a-doctor.com":true,"is-a-financialadvisor.com":true,"is-a-geek.com":true,"is-a-geek.net":true,"is-a-geek.org":true,"is-a-green.com":true,"is-a-guru.com":true,"is-a-hard-worker.com":true,"is-a-hunter.com":true,"is-a-knight.org":true,"is-a-landscaper.com":true,"is-a-lawyer.com":true,"is-a-liberal.com":true,"is-a-libertarian.com":true,"is-a-linux-user.org":true,"is-a-llama.com":true,"is-a-musician.com":true,"is-a-nascarfan.com":true,"is-a-nurse.com":true,"is-a-painter.com":true,"is-a-patsfan.org":true,"is-a-personaltrainer.com":true,"is-a-photographer.com":true,"is-a-player.com":true,"is-a-republican.com":true,"is-a-rockstar.com":true,"is-a-socialist.com":true,"is-a-soxfan.org":true,"is-a-student.com":true,"is-a-teacher.com":true,"is-a-techie.com":true,"is-a-therapist.com":true,"is-an-accountant.com":true,"is-an-actor.com":true,"is-an-actress.com":true,"is-an-anarchist.com":true,"is-an-artist.com":true,"is-an-engineer.com":true,"is-an-entertainer.com":true,"is-by.us":true,"is-certified.com":true,"is-found.org":true,"is-gone.com":true,"is-into-anime.com":true,"is-into-cars.com":true,"is-into-cartoons.com":true,"is-into-games.com":true,"is-leet.com":true,"is-lost.org":true,"is-not-certified.com":true,"is-saved.org":true,"is-slick.com":true,"is-uberleet.com":true,"is-very-bad.org":true,"is-very-evil.org":true,"is-very-good.org":true,"is-very-nice.org":true,"is-very-sweet.org":true,"is-with-theband.com":true,"isa-geek.com":true,"isa-geek.net":true,"isa-geek.org":true,"isa-hockeynut.com":true,"issmarterthanyou.com":true,"isteingeek.de":true,"istmein.de":true,"kicks-ass.net":true,"kicks-ass.org":true,"knowsitall.info":true,"land-4-sale.us":true,"lebtimnetz.de":true,"leitungsen.de":true,"likes-pie.com":true,"likescandy.com":true,"merseine.nu":true,"mine.nu":true,"misconfused.org":true,"mypets.ws":true,"myphotos.cc":true,"neat-url.com":true,"office-on-the.net":true,"on-the-web.tv":true,"podzone.net":true,"podzone.org":true,"readmyblog.org":true,"saves-the-whales.com":true,"scrapper-site.net":true,"scrapping.cc":true,"selfip.biz":true,"selfip.com":true,"selfip.info":true,"selfip.net":true,"selfip.org":true,"sells-for-less.com":true,"sells-for-u.com":true,"sells-it.net":true,"sellsyourhome.org":true,"servebbs.com":true,"servebbs.net":true,"servebbs.org":true,"serveftp.net":true,"serveftp.org":true,"servegame.org":true,"shacknet.nu":true,"simple-url.com":true,"space-to-rent.com":true,"stuff-4-sale.org":true,"stuff-4-sale.us":true,"teaches-yoga.com":true,"thruhere.net":true,"traeumtgerade.de":true,"webhop.biz":true,"webhop.info":true,"webhop.net":true,"webhop.org":true,"worse-than.tv":true,"writesthisblog.com":true,"eu.org":true,"al.eu.org":true,"asso.eu.org":true,"at.eu.org":true,"au.eu.org":true,"be.eu.org":true,"bg.eu.org":true,"ca.eu.org":true,"cd.eu.org":true,"ch.eu.org":true,"cn.eu.org":true,"cy.eu.org":true,"cz.eu.org":true,"de.eu.org":true,"dk.eu.org":true,"edu.eu.org":true,"ee.eu.org":true,"es.eu.org":true,"fi.eu.org":true,"fr.eu.org":true,"gr.eu.org":true,"hr.eu.org":true,"hu.eu.org":true,"ie.eu.org":true,"il.eu.org":true,"in.eu.org":true,"int.eu.org":true,"is.eu.org":true,"it.eu.org":true,"jp.eu.org":true,"kr.eu.org":true,"lt.eu.org":true,"lu.eu.org":true,"lv.eu.org":true,"mc.eu.org":true,"me.eu.org":true,"mk.eu.org":true,"mt.eu.org":true,"my.eu.org":true,"net.eu.org":true,"ng.eu.org":true,"nl.eu.org":true,"no.eu.org":true,"nz.eu.org":true,"paris.eu.org":true,"pl.eu.org":true,"pt.eu.org":true,"q-a.eu.org":true,"ro.eu.org":true,"ru.eu.org":true,"se.eu.org":true,"si.eu.org":true,"sk.eu.org":true,"tr.eu.org":true,"uk.eu.org":true,"us.eu.org":true,"a.ssl.fastly.net":true,"b.ssl.fastly.net":true,"global.ssl.fastly.net":true,"a.prod.fastly.net":true,"global.prod.fastly.net":true,"firebaseapp.com":true,"flynnhub.com":true,"service.gov.uk":true,"github.io":true,"githubusercontent.com":true,"ro.com":true,"appspot.com":true,"blogspot.ae":true,"blogspot.al":true,"blogspot.am":true,"blogspot.ba":true,"blogspot.be":true,"blogspot.bg":true,"blogspot.bj":true,"blogspot.ca":true,"blogspot.cf":true,"blogspot.ch":true,"blogspot.cl":true,"blogspot.co.at":true,"blogspot.co.id":true,"blogspot.co.il":true,"blogspot.co.ke":true,"blogspot.co.nz":true,"blogspot.co.uk":true,"blogspot.co.za":true,"blogspot.com":true,"blogspot.com.ar":true,"blogspot.com.au":true,"blogspot.com.br":true,"blogspot.com.by":true,"blogspot.com.co":true,"blogspot.com.cy":true,"blogspot.com.ee":true,"blogspot.com.eg":true,"blogspot.com.es":true,"blogspot.com.mt":true,"blogspot.com.ng":true,"blogspot.com.tr":true,"blogspot.com.uy":true,"blogspot.cv":true,"blogspot.cz":true,"blogspot.de":true,"blogspot.dk":true,"blogspot.fi":true,"blogspot.fr":true,"blogspot.gr":true,"blogspot.hk":true,"blogspot.hr":true,"blogspot.hu":true,"blogspot.ie":true,"blogspot.in":true,"blogspot.is":true,"blogspot.it":true,"blogspot.jp":true,"blogspot.kr":true,"blogspot.li":true,"blogspot.lt":true,"blogspot.lu":true,"blogspot.md":true,"blogspot.mk":true,"blogspot.mr":true,"blogspot.mx":true,"blogspot.my":true,"blogspot.nl":true,"blogspot.no":true,"blogspot.pe":true,"blogspot.pt":true,"blogspot.qa":true,"blogspot.re":true,"blogspot.ro":true,"blogspot.rs":true,"blogspot.ru":true,"blogspot.se":true,"blogspot.sg":true,"blogspot.si":true,"blogspot.sk":true,"blogspot.sn":true,"blogspot.td":true,"blogspot.tw":true,"blogspot.ug":true,"blogspot.vn":true,"codespot.com":true,"googleapis.com":true,"googlecode.com":true,"pagespeedmobilizer.com":true,"withgoogle.com":true,"withyoutube.com":true,"herokuapp.com":true,"herokussl.com":true,"iki.fi":true,"biz.at":true,"info.at":true,"co.pl":true,"azurewebsites.net":true,"azure-mobile.net":true,"cloudapp.net":true,"bmoattachments.org":true,"4u.com":true,"nfshost.com":true,"nyc.mn":true,"nid.io":true,"operaunite.com":true,"outsystemscloud.com":true,"art.pl":true,"gliwice.pl":true,"krakow.pl":true,"poznan.pl":true,"wroc.pl":true,"zakopane.pl":true,"pantheon.io":true,"gotpantheon.com":true,"priv.at":true,"qa2.com":true,"rhcloud.com":true,"sandcats.io":true,"biz.ua":true,"co.ua":true,"pp.ua":true,"sinaapp.com":true,"vipsinaapp.com":true,"1kapp.com":true,"gda.pl":true,"gdansk.pl":true,"gdynia.pl":true,"med.pl":true,"sopot.pl":true,"hk.com":true,"hk.org":true,"ltd.hk":true,"inc.hk":true,"yolasite.com":true,"za.net":true,"za.org":true});
	
	// END of automatically generated file


/***/ },
/* 592 */
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ function(module, exports) {

	module.exports = require("punycode");

/***/ },
/* 593 */
/*!*************************************!*\
  !*** ./~/tough-cookie/lib/store.js ***!
  \*************************************/
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	'use strict';
	/*jshint unused:false */
	
	function Store() {
	}
	exports.Store = Store;
	
	// Stores may be synchronous, but are still required to use a
	// Continuation-Passing Style API.  The CookieJar itself will expose a "*Sync"
	// API that converts from synchronous-callbacks to imperative style.
	Store.prototype.synchronous = false;
	
	Store.prototype.findCookie = function(domain, path, key, cb) {
	  throw new Error('findCookie is not implemented');
	};
	
	Store.prototype.findCookies = function(domain, path, cb) {
	  throw new Error('findCookies is not implemented');
	};
	
	Store.prototype.putCookie = function(cookie, cb) {
	  throw new Error('putCookie is not implemented');
	};
	
	Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
	  // recommended default implementation:
	  // return this.putCookie(newCookie, cb);
	  throw new Error('updateCookie is not implemented');
	};
	
	Store.prototype.removeCookie = function(domain, path, key, cb) {
	  throw new Error('removeCookie is not implemented');
	};
	
	Store.prototype.removeCookies = function(domain, path, cb) {
	  throw new Error('removeCookies is not implemented');
	};
	
	Store.prototype.getAllCookies = function(cb) {
	  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
	};


/***/ },
/* 594 */
/*!****************************************!*\
  !*** ./~/tough-cookie/lib/memstore.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	'use strict';
	var Store = __webpack_require__(/*! ./store */ 593).Store;
	var permuteDomain = __webpack_require__(/*! ./permuteDomain */ 595).permuteDomain;
	var pathMatch = __webpack_require__(/*! ./pathMatch */ 596).pathMatch;
	var util = __webpack_require__(/*! util */ 597);
	
	function MemoryCookieStore() {
	  Store.call(this);
	  this.idx = {};
	}
	util.inherits(MemoryCookieStore, Store);
	exports.MemoryCookieStore = MemoryCookieStore;
	MemoryCookieStore.prototype.idx = null;
	
	// Since it's just a struct in RAM, this Store is synchronous
	MemoryCookieStore.prototype.synchronous = true;
	
	// force a default depth:
	MemoryCookieStore.prototype.inspect = function() {
	  return "{ idx: "+util.inspect(this.idx, false, 2)+' }';
	};
	
	MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
	  if (!this.idx[domain]) {
	    return cb(null,undefined);
	  }
	  if (!this.idx[domain][path]) {
	    return cb(null,undefined);
	  }
	  return cb(null,this.idx[domain][path][key]||null);
	};
	
	MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
	  var results = [];
	  if (!domain) {
	    return cb(null,[]);
	  }
	
	  var pathMatcher;
	  if (!path) {
	    // null means "all paths"
	    pathMatcher = function matchAll(domainIndex) {
	      for (var curPath in domainIndex) {
	        var pathIndex = domainIndex[curPath];
	        for (var key in pathIndex) {
	          results.push(pathIndex[key]);
	        }
	      }
	    };
	
	  } else {
	    pathMatcher = function matchRFC(domainIndex) {
	       //NOTE: we should use path-match algorithm from S5.1.4 here
	       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
	       Object.keys(domainIndex).forEach(function (cookiePath) {
	         if (pathMatch(path, cookiePath)) {
	           var pathIndex = domainIndex[cookiePath];
	
	           for (var key in pathIndex) {
	             results.push(pathIndex[key]);
	           }
	         }
	       });
	     };
	  }
	
	  var domains = permuteDomain(domain) || [domain];
	  var idx = this.idx;
	  domains.forEach(function(curDomain) {
	    var domainIndex = idx[curDomain];
	    if (!domainIndex) {
	      return;
	    }
	    pathMatcher(domainIndex);
	  });
	
	  cb(null,results);
	};
	
	MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
	  if (!this.idx[cookie.domain]) {
	    this.idx[cookie.domain] = {};
	  }
	  if (!this.idx[cookie.domain][cookie.path]) {
	    this.idx[cookie.domain][cookie.path] = {};
	  }
	  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
	  cb(null);
	};
	
	MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
	  // updateCookie() may avoid updating cookies that are identical.  For example,
	  // lastAccessed may not be important to some stores and an equality
	  // comparison could exclude that field.
	  this.putCookie(newCookie,cb);
	};
	
	MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
	  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
	    delete this.idx[domain][path][key];
	  }
	  cb(null);
	};
	
	MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
	  if (this.idx[domain]) {
	    if (path) {
	      delete this.idx[domain][path];
	    } else {
	      delete this.idx[domain];
	    }
	  }
	  return cb(null);
	};
	
	MemoryCookieStore.prototype.getAllCookies = function(cb) {
	  var cookies = [];
	  var idx = this.idx;
	
	  var domains = Object.keys(idx);
	  domains.forEach(function(domain) {
	    var paths = Object.keys(idx[domain]);
	    paths.forEach(function(path) {
	      var keys = Object.keys(idx[domain][path]);
	      keys.forEach(function(key) {
	        if (key !== null) {
	          cookies.push(idx[domain][path][key]);
	        }
	      });
	    });
	  });
	
	  // Sort by creationIndex so deserializing retains the creation order.
	  // When implementing your own store, this SHOULD retain the order too
	  cookies.sort(function(a,b) {
	    return (a.creationIndex||0) - (b.creationIndex||0);
	  });
	
	  cb(null, cookies);
	};


/***/ },
/* 595 */
/*!*********************************************!*\
  !*** ./~/tough-cookie/lib/permuteDomain.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	"use strict";
	var pubsuffix = __webpack_require__(/*! ./pubsuffix */ 591);
	
	// Gives the permutation of all possible domainMatch()es of a given domain. The
	// array is in shortest-to-longest order.  Handy for indexing.
	function permuteDomain (domain) {
	  var pubSuf = pubsuffix.getPublicSuffix(domain);
	  if (!pubSuf) {
	    return null;
	  }
	  if (pubSuf == domain) {
	    return [domain];
	  }
	
	  var prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
	  var parts = prefix.split('.').reverse();
	  var cur = pubSuf;
	  var permutations = [cur];
	  while (parts.length) {
	    cur = parts.shift() + '.' + cur;
	    permutations.push(cur);
	  }
	  return permutations;
	}
	
	exports.permuteDomain = permuteDomain;


/***/ },
/* 596 */
/*!*****************************************!*\
  !*** ./~/tough-cookie/lib/pathMatch.js ***!
  \*****************************************/
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	"use strict";
	/*
	 * "A request-path path-matches a given cookie-path if at least one of the
	 * following conditions holds:"
	 */
	function pathMatch (reqPath, cookiePath) {
	  // "o  The cookie-path and the request-path are identical."
	  if (cookiePath === reqPath) {
	    return true;
	  }
	
	  var idx = reqPath.indexOf(cookiePath);
	  if (idx === 0) {
	    // "o  The cookie-path is a prefix of the request-path, and the last
	    // character of the cookie-path is %x2F ("/")."
	    if (cookiePath.substr(-1) === "/") {
	      return true;
	    }
	
	    // " o  The cookie-path is a prefix of the request-path, and the first
	    // character of the request-path that is not included in the cookie- path
	    // is a %x2F ("/") character."
	    if (reqPath.substr(cookiePath.length, 1) === "/") {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	exports.pathMatch = pathMatch;


/***/ },
/* 597 */
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("util");

/***/ },
/* 598 */
/*!*************************************!*\
  !*** ./~/tough-cookie/package.json ***!
  \*************************************/
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"name": "tough-cookie",
					"raw": "tough-cookie@~2.2.0",
					"rawSpec": "~2.2.0",
					"scope": null,
					"spec": ">=2.2.0 <2.3.0",
					"type": "range"
				},
				"/Users/John/Documents/Lavora/Sia-UI/Sia-UI/node_modules/request"
			]
		],
		"_from": "tough-cookie@>=2.2.0 <2.3.0",
		"_id": "tough-cookie@2.2.2",
		"_inCache": true,
		"_installable": true,
		"_location": "/tough-cookie",
		"_nodeVersion": "5.1.1",
		"_npmOperationalInternal": {
			"host": "packages-13-west.internal.npmjs.com",
			"tmp": "tmp/tough-cookie-2.2.2.tgz_1457564639182_0.5129188685677946"
		},
		"_npmUser": {
			"email": "jstash@gmail.com",
			"name": "jstash"
		},
		"_npmVersion": "3.3.12",
		"_phantomChildren": {},
		"_requested": {
			"name": "tough-cookie",
			"raw": "tough-cookie@~2.2.0",
			"rawSpec": "~2.2.0",
			"scope": null,
			"spec": ">=2.2.0 <2.3.0",
			"type": "range"
		},
		"_requiredBy": [
			"/mksnapshot/request",
			"/request"
		],
		"_resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.2.2.tgz",
		"_shasum": "c83a1830f4e5ef0b93ef2a3488e724f8de016ac7",
		"_shrinkwrap": null,
		"_spec": "tough-cookie@~2.2.0",
		"_where": "/Users/John/Documents/Lavora/Sia-UI/Sia-UI/node_modules/request",
		"author": {
			"email": "jstashewsky@salesforce.com",
			"name": "Jeremy Stashewsky"
		},
		"bugs": {
			"url": "https://github.com/SalesforceEng/tough-cookie/issues"
		},
		"contributors": [
			{
				"name": "Alexander Savin"
			},
			{
				"name": "Ian Livingstone"
			},
			{
				"name": "Ivan Nikulin"
			},
			{
				"name": "Lalit Kapoor"
			},
			{
				"name": "Sam Thompson"
			},
			{
				"name": "Sebastian Mayr"
			}
		],
		"dependencies": {},
		"description": "RFC6265 Cookies and Cookie Jar for node.js",
		"devDependencies": {
			"async": "^1.4.2",
			"vows": "^0.8.1"
		},
		"directories": {},
		"dist": {
			"shasum": "c83a1830f4e5ef0b93ef2a3488e724f8de016ac7",
			"tarball": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.2.2.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"files": [
			"lib"
		],
		"gitHead": "cc46628c4d7d2e8c372ecba29293ca8a207ec192",
		"homepage": "https://github.com/SalesforceEng/tough-cookie",
		"keywords": [
			"HTTP",
			"cookie",
			"cookies",
			"set-cookie",
			"cookiejar",
			"jar",
			"RFC6265",
			"RFC2965"
		],
		"license": "BSD-3-Clause",
		"main": "./lib/cookie",
		"maintainers": [
			{
				"email": "jeremy@goinstant.com",
				"name": "jstash"
			},
			{
				"email": "services@goinstant.com",
				"name": "goinstant"
			}
		],
		"name": "tough-cookie",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git://github.com/SalesforceEng/tough-cookie.git"
		},
		"scripts": {
			"suffixup": "curl -o public_suffix_list.dat https://publicsuffix.org/list/public_suffix_list.dat && ./generate-pubsuffix.js",
			"test": "vows test/*_test.js"
		},
		"version": "2.2.2"
	};

/***/ },
/* 599 */
/*!**********************************!*\
  !*** ./~/request/lib/helpers.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var jsonSafeStringify = __webpack_require__(/*! json-stringify-safe */ 600)
	  , crypto = __webpack_require__(/*! crypto */ 601)
	
	function deferMethod() {
	  if (typeof setImmediate === 'undefined') {
	    return process.nextTick
	  }
	
	  return setImmediate
	}
	
	function isFunction(value) {
	  return typeof value === 'function'
	}
	
	function paramsHaveRequestBody(params) {
	  return (
	    params.body ||
	    params.requestBodyStream ||
	    (params.json && typeof params.json !== 'boolean') ||
	    params.multipart
	  )
	}
	
	function safeStringify (obj, replacer) {
	  var ret
	  try {
	    ret = JSON.stringify(obj, replacer)
	  } catch (e) {
	    ret = jsonSafeStringify(obj, replacer)
	  }
	  return ret
	}
	
	function md5 (str) {
	  return crypto.createHash('md5').update(str).digest('hex')
	}
	
	function isReadStream (rs) {
	  return rs.readable && rs.path && rs.mode
	}
	
	function toBase64 (str) {
	  return (new Buffer(str || '', 'utf8')).toString('base64')
	}
	
	function copy (obj) {
	  var o = {}
	  Object.keys(obj).forEach(function (i) {
	    o[i] = obj[i]
	  })
	  return o
	}
	
	function version () {
	  var numbers = process.version.replace('v', '').split('.')
	  return {
	    major: parseInt(numbers[0], 10),
	    minor: parseInt(numbers[1], 10),
	    patch: parseInt(numbers[2], 10)
	  }
	}
	
	exports.isFunction            = isFunction
	exports.paramsHaveRequestBody = paramsHaveRequestBody
	exports.safeStringify         = safeStringify
	exports.md5                   = md5
	exports.isReadStream          = isReadStream
	exports.toBase64              = toBase64
	exports.copy                  = copy
	exports.version               = version
	exports.defer                 = deferMethod()


/***/ },
/* 600 */
/*!********************************************!*\
  !*** ./~/json-stringify-safe/stringify.js ***!
  \********************************************/
/***/ function(module, exports) {

	exports = module.exports = stringify
	exports.getSerialize = serializer
	
	function stringify(obj, replacer, spaces, cycleReplacer) {
	  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
	}
	
	function serializer(replacer, cycleReplacer) {
	  var stack = [], keys = []
	
	  if (cycleReplacer == null) cycleReplacer = function(key, value) {
	    if (stack[0] === value) return "[Circular ~]"
	    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
	  }
	
	  return function(key, value) {
	    if (stack.length > 0) {
	      var thisPos = stack.indexOf(this)
	      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
	      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
	      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
	    }
	    else stack.push(value)
	
	    return replacer == null ? value : replacer.call(this, key, value)
	  }
	}


/***/ },
/* 601 */
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("crypto");

/***/ },
/* 602 */
/*!******************************!*\
  !*** ./~/request/request.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var http = __webpack_require__(/*! http */ 533)
	  , https = __webpack_require__(/*! https */ 603)
	  , url = __webpack_require__(/*! url */ 534)
	  , util = __webpack_require__(/*! util */ 597)
	  , stream = __webpack_require__(/*! stream */ 604)
	  , zlib = __webpack_require__(/*! zlib */ 605)
	  , bl = __webpack_require__(/*! bl */ 606)
	  , hawk = __webpack_require__(/*! hawk */ 617)
	  , aws2 = __webpack_require__(/*! aws-sign2 */ 631)
	  , httpSignature = __webpack_require__(/*! http-signature */ 632)
	  , mime = __webpack_require__(/*! mime-types */ 678)
	  , stringstream = __webpack_require__(/*! stringstream */ 681)
	  , caseless = __webpack_require__(/*! caseless */ 683)
	  , ForeverAgent = __webpack_require__(/*! forever-agent */ 684)
	  , FormData = __webpack_require__(/*! form-data */ 686)
	  , extend = __webpack_require__(/*! extend */ 587)
	  , isstream = __webpack_require__(/*! isstream */ 691)
	  , isTypedArray = __webpack_require__(/*! is-typedarray */ 692).strict
	  , helpers = __webpack_require__(/*! ./lib/helpers */ 599)
	  , cookies = __webpack_require__(/*! ./lib/cookies */ 588)
	  , getProxyFromURI = __webpack_require__(/*! ./lib/getProxyFromURI */ 693)
	  , Querystring = __webpack_require__(/*! ./lib/querystring */ 694).Querystring
	  , Har = __webpack_require__(/*! ./lib/har */ 699).Har
	  , Auth = __webpack_require__(/*! ./lib/auth */ 733).Auth
	  , OAuth = __webpack_require__(/*! ./lib/oauth */ 735).OAuth
	  , Multipart = __webpack_require__(/*! ./lib/multipart */ 737).Multipart
	  , Redirect = __webpack_require__(/*! ./lib/redirect */ 738).Redirect
	  , Tunnel = __webpack_require__(/*! ./lib/tunnel */ 739).Tunnel
	
	var safeStringify = helpers.safeStringify
	  , isReadStream = helpers.isReadStream
	  , toBase64 = helpers.toBase64
	  , defer = helpers.defer
	  , copy = helpers.copy
	  , version = helpers.version
	  , globalCookieJar = cookies.jar()
	
	
	var globalPool = {}
	
	function filterForNonReserved(reserved, options) {
	  // Filter out properties that are not reserved.
	  // Reserved values are passed in at call site.
	
	  var object = {}
	  for (var i in options) {
	    var notReserved = (reserved.indexOf(i) === -1)
	    if (notReserved) {
	      object[i] = options[i]
	    }
	  }
	  return object
	}
	
	function filterOutReservedFunctions(reserved, options) {
	  // Filter out properties that are functions and are reserved.
	  // Reserved values are passed in at call site.
	
	  var object = {}
	  for (var i in options) {
	    var isReserved = !(reserved.indexOf(i) === -1)
	    var isFunction = (typeof options[i] === 'function')
	    if (!(isReserved && isFunction)) {
	      object[i] = options[i]
	    }
	  }
	  return object
	
	}
	
	// Function for properly handling a connection error
	function connectionErrorHandler(error) {
	  var socket = this
	  if (socket.res) {
	    if (socket.res.request) {
	      socket.res.request.emit('error', error)
	    } else {
	      socket.res.emit('error', error)
	    }
	  } else {
	    socket._httpMessage.emit('error', error)
	  }
	}
	
	// Return a simpler request object to allow serialization
	function requestToJSON() {
	  var self = this
	  return {
	    uri: self.uri,
	    method: self.method,
	    headers: self.headers
	  }
	}
	
	// Return a simpler response object to allow serialization
	function responseToJSON() {
	  var self = this
	  return {
	    statusCode: self.statusCode,
	    body: self.body,
	    headers: self.headers,
	    request: requestToJSON.call(self.request)
	  }
	}
	
	function Request (options) {
	  // if given the method property in options, set property explicitMethod to true
	
	  // extend the Request instance with any non-reserved properties
	  // remove any reserved functions from the options object
	  // set Request instance to be readable and writable
	  // call init
	
	  var self = this
	
	  // start with HAR, then override with additional options
	  if (options.har) {
	    self._har = new Har(self)
	    options = self._har.options(options)
	  }
	
	  stream.Stream.call(self)
	  var reserved = Object.keys(Request.prototype)
	  var nonReserved = filterForNonReserved(reserved, options)
	
	  extend(self, nonReserved)
	  options = filterOutReservedFunctions(reserved, options)
	
	  self.readable = true
	  self.writable = true
	  if (options.method) {
	    self.explicitMethod = true
	  }
	  self._qs = new Querystring(self)
	  self._auth = new Auth(self)
	  self._oauth = new OAuth(self)
	  self._multipart = new Multipart(self)
	  self._redirect = new Redirect(self)
	  self._tunnel = new Tunnel(self)
	  self.init(options)
	}
	
	util.inherits(Request, stream.Stream)
	
	// Debugging
	Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG)
	function debug() {
	  if (Request.debug) {
	    console.error('REQUEST %s', util.format.apply(util, arguments))
	  }
	}
	Request.prototype.debug = debug
	
	Request.prototype.init = function (options) {
	  // init() contains all the code to setup the request object.
	  // the actual outgoing request is not started until start() is called
	  // this function is called from both the constructor and on redirect.
	  var self = this
	  if (!options) {
	    options = {}
	  }
	  self.headers = self.headers ? copy(self.headers) : {}
	
	  // Delete headers with value undefined since they break
	  // ClientRequest.OutgoingMessage.setHeader in node 0.12
	  for (var headerName in self.headers) {
	    if (typeof self.headers[headerName] === 'undefined') {
	      delete self.headers[headerName]
	    }
	  }
	
	  caseless.httpify(self, self.headers)
	
	  if (!self.method) {
	    self.method = options.method || 'GET'
	  }
	  if (!self.localAddress) {
	    self.localAddress = options.localAddress
	  }
	
	  self._qs.init(options)
	
	  debug(options)
	  if (!self.pool && self.pool !== false) {
	    self.pool = globalPool
	  }
	  self.dests = self.dests || []
	  self.__isRequestRequest = true
	
	  // Protect against double callback
	  if (!self._callback && self.callback) {
	    self._callback = self.callback
	    self.callback = function () {
	      if (self._callbackCalled) {
	        return // Print a warning maybe?
	      }
	      self._callbackCalled = true
	      self._callback.apply(self, arguments)
	    }
	    self.on('error', self.callback.bind())
	    self.on('complete', self.callback.bind(self, null))
	  }
	
	  // People use this property instead all the time, so support it
	  if (!self.uri && self.url) {
	    self.uri = self.url
	    delete self.url
	  }
	
	  // If there's a baseUrl, then use it as the base URL (i.e. uri must be
	  // specified as a relative path and is appended to baseUrl).
	  if (self.baseUrl) {
	    if (typeof self.baseUrl !== 'string') {
	      return self.emit('error', new Error('options.baseUrl must be a string'))
	    }
	
	    if (typeof self.uri !== 'string') {
	      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))
	    }
	
	    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {
	      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))
	    }
	
	    // Handle all cases to make sure that there's only one slash between
	    // baseUrl and uri.
	    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1
	    var uriStartsWithSlash = self.uri.indexOf('/') === 0
	
	    if (baseUrlEndsWithSlash && uriStartsWithSlash) {
	      self.uri = self.baseUrl + self.uri.slice(1)
	    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
	      self.uri = self.baseUrl + self.uri
	    } else if (self.uri === '') {
	      self.uri = self.baseUrl
	    } else {
	      self.uri = self.baseUrl + '/' + self.uri
	    }
	    delete self.baseUrl
	  }
	
	  // A URI is needed by this point, emit error if we haven't been able to get one
	  if (!self.uri) {
	    return self.emit('error', new Error('options.uri is a required argument'))
	  }
	
	  // If a string URI/URL was given, parse it into a URL object
	  if (typeof self.uri === 'string') {
	    self.uri = url.parse(self.uri)
	  }
	
	  // Some URL objects are not from a URL parsed string and need href added
	  if (!self.uri.href) {
	    self.uri.href = url.format(self.uri)
	  }
	
	  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
	  if (self.uri.protocol === 'unix:') {
	    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))
	  }
	
	  // Support Unix Sockets
	  if (self.uri.host === 'unix') {
	    self.enableUnixSocket()
	  }
	
	  if (self.strictSSL === false) {
	    self.rejectUnauthorized = false
	  }
	
	  if (!self.uri.pathname) {self.uri.pathname = '/'}
	
	  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {
	    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar
	    // Detect and reject it as soon as possible
	    var faultyUri = url.format(self.uri)
	    var message = 'Invalid URI "' + faultyUri + '"'
	    if (Object.keys(options).length === 0) {
	      // No option ? This can be the sign of a redirect
	      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)
	      // they should be warned that it can be caused by a redirection (can save some hair)
	      message += '. This can be caused by a crappy redirection.'
	    }
	    // This error was fatal
	    self.abort()
	    return self.emit('error', new Error(message))
	  }
	
	  if (!self.hasOwnProperty('proxy')) {
	    self.proxy = getProxyFromURI(self.uri)
	  }
	
	  self.tunnel = self._tunnel.isEnabled()
	  if (self.proxy) {
	    self._tunnel.setup(options)
	  }
	
	  self._redirect.onRequest(options)
	
	  self.setHost = false
	  if (!self.hasHeader('host')) {
	    var hostHeaderName = self.originalHostHeaderName || 'host'
	    self.setHeader(hostHeaderName, self.uri.hostname)
	    if (self.uri.port) {
	      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&
	           !(self.uri.port === 443 && self.uri.protocol === 'https:') ) {
	        self.setHeader(hostHeaderName, self.getHeader('host') + (':' + self.uri.port) )
	      }
	    }
	    self.setHost = true
	  }
	
	  self.jar(self._jar || options.jar)
	
	  if (!self.uri.port) {
	    if (self.uri.protocol === 'http:') {self.uri.port = 80}
	    else if (self.uri.protocol === 'https:') {self.uri.port = 443}
	  }
	
	  if (self.proxy && !self.tunnel) {
	    self.port = self.proxy.port
	    self.host = self.proxy.hostname
	  } else {
	    self.port = self.uri.port
	    self.host = self.uri.hostname
	  }
	
	  if (options.form) {
	    self.form(options.form)
	  }
	
	  if (options.formData) {
	    var formData = options.formData
	    var requestForm = self.form()
	    var appendFormValue = function (key, value) {
	      if (value.hasOwnProperty('value') && value.hasOwnProperty('options')) {
	        requestForm.append(key, value.value, value.options)
	      } else {
	        requestForm.append(key, value)
	      }
	    }
	    for (var formKey in formData) {
	      if (formData.hasOwnProperty(formKey)) {
	        var formValue = formData[formKey]
	        if (formValue instanceof Array) {
	          for (var j = 0; j < formValue.length; j++) {
	            appendFormValue(formKey, formValue[j])
	          }
	        } else {
	          appendFormValue(formKey, formValue)
	        }
	      }
	    }
	  }
	
	  if (options.qs) {
	    self.qs(options.qs)
	  }
	
	  if (self.uri.path) {
	    self.path = self.uri.path
	  } else {
	    self.path = self.uri.pathname + (self.uri.search || '')
	  }
	
	  if (self.path.length === 0) {
	    self.path = '/'
	  }
	
	  // Auth must happen last in case signing is dependent on other headers
	  if (options.aws) {
	    self.aws(options.aws)
	  }
	
	  if (options.hawk) {
	    self.hawk(options.hawk)
	  }
	
	  if (options.httpSignature) {
	    self.httpSignature(options.httpSignature)
	  }
	
	  if (options.auth) {
	    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {
	      options.auth.user = options.auth.username
	    }
	    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {
	      options.auth.pass = options.auth.password
	    }
	
	    self.auth(
	      options.auth.user,
	      options.auth.pass,
	      options.auth.sendImmediately,
	      options.auth.bearer
	    )
	  }
	
	  if (self.gzip && !self.hasHeader('accept-encoding')) {
	    self.setHeader('accept-encoding', 'gzip, deflate')
	  }
	
	  if (self.uri.auth && !self.hasHeader('authorization')) {
	    var uriAuthPieces = self.uri.auth.split(':').map(function(item) {return self._qs.unescape(item)})
	    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)
	  }
	
	  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {
	    var proxyAuthPieces = self.proxy.auth.split(':').map(function(item) {return self._qs.unescape(item)})
	    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))
	    self.setHeader('proxy-authorization', authHeader)
	  }
	
	  if (self.proxy && !self.tunnel) {
	    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)
	  }
	
	  if (options.json) {
	    self.json(options.json)
	  }
	  if (options.multipart) {
	    self.multipart(options.multipart)
	  }
	
	  if (options.time) {
	    self.timing = true
	    self.elapsedTime = self.elapsedTime || 0
	  }
	
	  function setContentLength () {
	    if (isTypedArray(self.body)) {
	      self.body = new Buffer(self.body)
	    }
	
	    if (!self.hasHeader('content-length')) {
	      var length
	      if (typeof self.body === 'string') {
	        length = Buffer.byteLength(self.body)
	      }
	      else if (Array.isArray(self.body)) {
	        length = self.body.reduce(function (a, b) {return a + b.length}, 0)
	      }
	      else {
	        length = self.body.length
	      }
	
	      if (length) {
	        self.setHeader('content-length', length)
	      } else {
	        self.emit('error', new Error('Argument error, options.body.'))
	      }
	    }
	  }
	  if (self.body && !isstream(self.body)) {
	    setContentLength()
	  }
	
	  if (options.oauth) {
	    self.oauth(options.oauth)
	  } else if (self._oauth.params && self.hasHeader('authorization')) {
	    self.oauth(self._oauth.params)
	  }
	
	  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
	    , defaultModules = {'http:':http, 'https:':https}
	    , httpModules = self.httpModules || {}
	
	  self.httpModule = httpModules[protocol] || defaultModules[protocol]
	
	  if (!self.httpModule) {
	    return self.emit('error', new Error('Invalid protocol: ' + protocol))
	  }
	
	  if (options.ca) {
	    self.ca = options.ca
	  }
	
	  if (!self.agent) {
	    if (options.agentOptions) {
	      self.agentOptions = options.agentOptions
	    }
	
	    if (options.agentClass) {
	      self.agentClass = options.agentClass
	    } else if (options.forever) {
	      var v = version()
	      // use ForeverAgent in node 0.10- only
	      if (v.major === 0 && v.minor <= 10) {
	        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
	      } else {
	        self.agentClass = self.httpModule.Agent
	        self.agentOptions = self.agentOptions || {}
	        self.agentOptions.keepAlive = true
	      }
	    } else {
	      self.agentClass = self.httpModule.Agent
	    }
	  }
	
	  if (self.pool === false) {
	    self.agent = false
	  } else {
	    self.agent = self.agent || self.getNewAgent()
	  }
	
	  self.on('pipe', function (src) {
	    if (self.ntick && self._started) {
	      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))
	    }
	    self.src = src
	    if (isReadStream(src)) {
	      if (!self.hasHeader('content-type')) {
	        self.setHeader('content-type', mime.lookup(src.path))
	      }
	    } else {
	      if (src.headers) {
	        for (var i in src.headers) {
	          if (!self.hasHeader(i)) {
	            self.setHeader(i, src.headers[i])
	          }
	        }
	      }
	      if (self._json && !self.hasHeader('content-type')) {
	        self.setHeader('content-type', 'application/json')
	      }
	      if (src.method && !self.explicitMethod) {
	        self.method = src.method
	      }
	    }
	
	    // self.on('pipe', function () {
	    //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')
	    // })
	  })
	
	  defer(function () {
	    if (self._aborted) {
	      return
	    }
	
	    var end = function () {
	      if (self._form) {
	        if (!self._auth.hasAuth) {
	          self._form.pipe(self)
	        }
	        else if (self._auth.hasAuth && self._auth.sentAuth) {
	          self._form.pipe(self)
	        }
	      }
	      if (self._multipart && self._multipart.chunked) {
	        self._multipart.body.pipe(self)
	      }
	      if (self.body) {
	        if (isstream(self.body)) {
	          self.body.pipe(self)
	        } else {
	          setContentLength()
	          if (Array.isArray(self.body)) {
	            self.body.forEach(function (part) {
	              self.write(part)
	            })
	          } else {
	            self.write(self.body)
	          }
	          self.end()
	        }
	      } else if (self.requestBodyStream) {
	        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')
	        self.requestBodyStream.pipe(self)
	      } else if (!self.src) {
	        if (self._auth.hasAuth && !self._auth.sentAuth) {
	          self.end()
	          return
	        }
	        if (self.method !== 'GET' && typeof self.method !== 'undefined') {
	          self.setHeader('content-length', 0)
	        }
	        self.end()
	      }
	    }
	
	    if (self._form && !self.hasHeader('content-length')) {
	      // Before ending the request, we had to compute the length of the whole form, asyncly
	      self.setHeader(self._form.getHeaders(), true)
	      self._form.getLength(function (err, length) {
	        if (!err && !isNaN(length)) {
	          self.setHeader('content-length', length)
	        }
	        end()
	      })
	    } else {
	      end()
	    }
	
	    self.ntick = true
	  })
	
	}
	
	Request.prototype.getNewAgent = function () {
	  var self = this
	  var Agent = self.agentClass
	  var options = {}
	  if (self.agentOptions) {
	    for (var i in self.agentOptions) {
	      options[i] = self.agentOptions[i]
	    }
	  }
	  if (self.ca) {
	    options.ca = self.ca
	  }
	  if (self.ciphers) {
	    options.ciphers = self.ciphers
	  }
	  if (self.secureProtocol) {
	    options.secureProtocol = self.secureProtocol
	  }
	  if (self.secureOptions) {
	    options.secureOptions = self.secureOptions
	  }
	  if (typeof self.rejectUnauthorized !== 'undefined') {
	    options.rejectUnauthorized = self.rejectUnauthorized
	  }
	
	  if (self.cert && self.key) {
	    options.key = self.key
	    options.cert = self.cert
	  }
	
	  if (self.pfx) {
	    options.pfx = self.pfx
	  }
	
	  if (self.passphrase) {
	    options.passphrase = self.passphrase
	  }
	
	  var poolKey = ''
	
	  // different types of agents are in different pools
	  if (Agent !== self.httpModule.Agent) {
	    poolKey += Agent.name
	  }
	
	  // ca option is only relevant if proxy or destination are https
	  var proxy = self.proxy
	  if (typeof proxy === 'string') {
	    proxy = url.parse(proxy)
	  }
	  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'
	
	  if (isHttps) {
	    if (options.ca) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.ca
	    }
	
	    if (typeof options.rejectUnauthorized !== 'undefined') {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.rejectUnauthorized
	    }
	
	    if (options.cert) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')
	    }
	
	    if (options.pfx) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.pfx.toString('ascii')
	    }
	
	    if (options.ciphers) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.ciphers
	    }
	
	    if (options.secureProtocol) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.secureProtocol
	    }
	
	    if (options.secureOptions) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.secureOptions
	    }
	  }
	
	  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {
	    // not doing anything special.  Use the globalAgent
	    return self.httpModule.globalAgent
	  }
	
	  // we're using a stored agent.  Make sure it's protocol-specific
	  poolKey = self.uri.protocol + poolKey
	
	  // generate a new agent for this setting if none yet exists
	  if (!self.pool[poolKey]) {
	    self.pool[poolKey] = new Agent(options)
	    // properly set maxSockets on new agents
	    if (self.pool.maxSockets) {
	      self.pool[poolKey].maxSockets = self.pool.maxSockets
	    }
	  }
	
	  return self.pool[poolKey]
	}
	
	Request.prototype.start = function () {
	  // start() is called once we are ready to send the outgoing HTTP request.
	  // this is usually called on the first write(), end() or on nextTick()
	  var self = this
	
	  if (self._aborted) {
	    return
	  }
	
	  self._started = true
	  self.method = self.method || 'GET'
	  self.href = self.uri.href
	
	  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {
	    self.setHeader('content-length', self.src.stat.size)
	  }
	  if (self._aws) {
	    self.aws(self._aws, true)
	  }
	
	  // We have a method named auth, which is completely different from the http.request
	  // auth option.  If we don't remove it, we're gonna have a bad time.
	  var reqOptions = copy(self)
	  delete reqOptions.auth
	
	  debug('make request', self.uri.href)
	
	  try {
	    self.req = self.httpModule.request(reqOptions)
	  } catch (err) {
	    self.emit('error', err)
	    return
	  }
	
	  if (self.timing) {
	    self.startTime = new Date().getTime()
	  }
	
	  if (self.timeout && !self.timeoutTimer) {
	    var timeout = self.timeout < 0 ? 0 : self.timeout
	    // Set a timeout in memory - this block will throw if the server takes more
	    // than `timeout` to write the HTTP status and headers (corresponding to
	    // the on('response') event on the client). NB: this measures wall-clock
	    // time, not the time between bytes sent by the server.
	    self.timeoutTimer = setTimeout(function () {
	      var connectTimeout = self.req.socket && self.req.socket.readable === false
	      self.abort()
	      var e = new Error('ETIMEDOUT')
	      e.code = 'ETIMEDOUT'
	      e.connect = connectTimeout
	      self.emit('error', e)
	    }, timeout)
	
	    if (self.req.setTimeout) { // only works on node 0.6+
	      // Set an additional timeout on the socket, via the `setsockopt` syscall.
	      // This timeout sets the amount of time to wait *between* bytes sent
	      // from the server, and may or may not correspond to the wall-clock time
	      // elapsed from the start of the request.
	      //
	      // In particular, it's useful for erroring if the server fails to send
	      // data halfway through streaming a response.
	      self.req.setTimeout(timeout, function () {
	        if (self.req) {
	          self.req.abort()
	          var e = new Error('ESOCKETTIMEDOUT')
	          e.code = 'ESOCKETTIMEDOUT'
	          e.connect = false
	          self.emit('error', e)
	        }
	      })
	    }
	  }
	
	  self.req.on('response', self.onRequestResponse.bind(self))
	  self.req.on('error', self.onRequestError.bind(self))
	  self.req.on('drain', function() {
	    self.emit('drain')
	  })
	  self.req.on('socket', function(socket) {
	    self.emit('socket', socket)
	  })
	
	  self.on('end', function() {
	    if ( self.req.connection ) {
	      self.req.connection.removeListener('error', connectionErrorHandler)
	    }
	  })
	  self.emit('request', self.req)
	}
	
	Request.prototype.onRequestError = function (error) {
	  var self = this
	  if (self._aborted) {
	    return
	  }
	  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'
	      && self.agent.addRequestNoreuse) {
	    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
	    self.start()
	    self.req.end()
	    return
	  }
	  if (self.timeout && self.timeoutTimer) {
	    clearTimeout(self.timeoutTimer)
	    self.timeoutTimer = null
	  }
	  self.emit('error', error)
	}
	
	Request.prototype.onRequestResponse = function (response) {
	  var self = this
	  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)
	  response.on('end', function() {
	    if (self.timing) {
	      self.elapsedTime += (new Date().getTime() - self.startTime)
	      debug('elapsed time', self.elapsedTime)
	      response.elapsedTime = self.elapsedTime
	    }
	    debug('response end', self.uri.href, response.statusCode, response.headers)
	  })
	
	  // The check on response.connection is a workaround for browserify.
	  if (response.connection && response.connection.listeners('error').indexOf(connectionErrorHandler) === -1) {
	    response.connection.setMaxListeners(0)
	    response.connection.once('error', connectionErrorHandler)
	  }
	  if (self._aborted) {
	    debug('aborted', self.uri.href)
	    response.resume()
	    return
	  }
	
	  self.response = response
	  response.request = self
	  response.toJSON = responseToJSON
	
	  // XXX This is different on 0.10, because SSL is strict by default
	  if (self.httpModule === https &&
	      self.strictSSL && (!response.hasOwnProperty('socket') ||
	      !response.socket.authorized)) {
	    debug('strict ssl error', self.uri.href)
	    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'
	    self.emit('error', new Error('SSL Error: ' + sslErr))
	    return
	  }
	
	  // Save the original host before any redirect (if it changes, we need to
	  // remove any authorization headers).  Also remember the case of the header
	  // name because lots of broken servers expect Host instead of host and we
	  // want the caller to be able to specify this.
	  self.originalHost = self.getHeader('host')
	  if (!self.originalHostHeaderName) {
	    self.originalHostHeaderName = self.hasHeader('host')
	  }
	  if (self.setHost) {
	    self.removeHeader('host')
	  }
	  if (self.timeout && self.timeoutTimer) {
	    clearTimeout(self.timeoutTimer)
	    self.timeoutTimer = null
	  }
	
	  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar
	  var addCookie = function (cookie) {
	    //set the cookie if it's domain in the href's domain.
	    try {
	      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})
	    } catch (e) {
	      self.emit('error', e)
	    }
	  }
	
	  response.caseless = caseless(response.headers)
	
	  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {
	    var headerName = response.caseless.has('set-cookie')
	    if (Array.isArray(response.headers[headerName])) {
	      response.headers[headerName].forEach(addCookie)
	    } else {
	      addCookie(response.headers[headerName])
	    }
	  }
	
	  if (self._redirect.onResponse(response)) {
	    return // Ignore the rest of the response
	  } else {
	    // Be a good stream and emit end when the response is finished.
	    // Hack to emit end on close because of a core bug that never fires end
	    response.on('close', function () {
	      if (!self._ended) {
	        self.response.emit('end')
	      }
	    })
	
	    response.on('end', function () {
	      self._ended = true
	    })
	
	    var noBody = function (code) {
	      return (
	        self.method === 'HEAD'
	        // Informational
	        || (code >= 100 && code < 200)
	        // No Content
	        || code === 204
	        // Not Modified
	        || code === 304
	      )
	    }
	
	    var responseContent
	    if (self.gzip && !noBody(response.statusCode)) {
	      var contentEncoding = response.headers['content-encoding'] || 'identity'
	      contentEncoding = contentEncoding.trim().toLowerCase()
	
	      if (contentEncoding === 'gzip') {
	        responseContent = zlib.createGunzip()
	        response.pipe(responseContent)
	      } else if (contentEncoding === 'deflate') {
	        responseContent = zlib.createInflate()
	        response.pipe(responseContent)
	      } else {
	        // Since previous versions didn't check for Content-Encoding header,
	        // ignore any invalid values to preserve backwards-compatibility
	        if (contentEncoding !== 'identity') {
	          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)
	        }
	        responseContent = response
	      }
	    } else {
	      responseContent = response
	    }
	
	    if (self.encoding) {
	      if (self.dests.length !== 0) {
	        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')
	      } else if (responseContent.setEncoding) {
	        responseContent.setEncoding(self.encoding)
	      } else {
	        // Should only occur on node pre-v0.9.4 (joyent/node@9b5abe5) with
	        // zlib streams.
	        // If/When support for 0.9.4 is dropped, this should be unnecessary.
	        responseContent = responseContent.pipe(stringstream(self.encoding))
	      }
	    }
	
	    if (self._paused) {
	      responseContent.pause()
	    }
	
	    self.responseContent = responseContent
	
	    self.emit('response', response)
	
	    self.dests.forEach(function (dest) {
	      self.pipeDest(dest)
	    })
	
	    responseContent.on('data', function (chunk) {
	      self._destdata = true
	      self.emit('data', chunk)
	    })
	    responseContent.on('end', function (chunk) {
	      self.emit('end', chunk)
	    })
	    responseContent.on('error', function (error) {
	      self.emit('error', error)
	    })
	    responseContent.on('close', function () {self.emit('close')})
	
	    if (self.callback) {
	      self.readResponseBody(response)
	    }
	    //if no callback
	    else {
	      self.on('end', function () {
	        if (self._aborted) {
	          debug('aborted', self.uri.href)
	          return
	        }
	        self.emit('complete', response)
	      })
	    }
	  }
	  debug('finish init function', self.uri.href)
	}
	
	Request.prototype.readResponseBody = function (response) {
	  var self = this
	  debug('reading response\'s body')
	  var buffer = bl()
	    , strings = []
	
	  self.on('data', function (chunk) {
	    if (Buffer.isBuffer(chunk)) {
	      buffer.append(chunk)
	    } else {
	      strings.push(chunk)
	    }
	  })
	  self.on('end', function () {
	    debug('end event', self.uri.href)
	    if (self._aborted) {
	      debug('aborted', self.uri.href)
	      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.
	      // This can lead to leaky behavior if the user retains a reference to the request object.
	      buffer.destroy()
	      return
	    }
	
	    if (buffer.length) {
	      debug('has body', self.uri.href, buffer.length)
	      if (self.encoding === null) {
	        // response.body = buffer
	        // can't move to this until https://github.com/rvagg/bl/issues/13
	        response.body = buffer.slice()
	      } else {
	        response.body = buffer.toString(self.encoding)
	      }
	      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.
	      // This can lead to leaky behavior if the user retains a reference to the request object.
	      buffer.destroy()
	    } else if (strings.length) {
	      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
	      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
	      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\uFEFF') {
	        strings[0] = strings[0].substring(1)
	      }
	      response.body = strings.join('')
	    }
	
	    if (self._json) {
	      try {
	        response.body = JSON.parse(response.body, self._jsonReviver)
	      } catch (e) {
	        debug('invalid JSON received', self.uri.href)
	      }
	    }
	    debug('emitting complete', self.uri.href)
	    if (typeof response.body === 'undefined' && !self._json) {
	      response.body = self.encoding === null ? new Buffer(0) : ''
	    }
	    self.emit('complete', response, response.body)
	  })
	}
	
	Request.prototype.abort = function () {
	  var self = this
	  self._aborted = true
	
	  if (self.req) {
	    self.req.abort()
	  }
	  else if (self.response) {
	    self.response.destroy()
	  }
	
	  self.emit('abort')
	}
	
	Request.prototype.pipeDest = function (dest) {
	  var self = this
	  var response = self.response
	  // Called after the response is received
	  if (dest.headers && !dest.headersSent) {
	    if (response.caseless.has('content-type')) {
	      var ctname = response.caseless.has('content-type')
	      if (dest.setHeader) {
	        dest.setHeader(ctname, response.headers[ctname])
	      }
	      else {
	        dest.headers[ctname] = response.headers[ctname]
	      }
	    }
	
	    if (response.caseless.has('content-length')) {
	      var clname = response.caseless.has('content-length')
	      if (dest.setHeader) {
	        dest.setHeader(clname, response.headers[clname])
	      } else {
	        dest.headers[clname] = response.headers[clname]
	      }
	    }
	  }
	  if (dest.setHeader && !dest.headersSent) {
	    for (var i in response.headers) {
	      // If the response content is being decoded, the Content-Encoding header
	      // of the response doesn't represent the piped content, so don't pass it.
	      if (!self.gzip || i !== 'content-encoding') {
	        dest.setHeader(i, response.headers[i])
	      }
	    }
	    dest.statusCode = response.statusCode
	  }
	  if (self.pipefilter) {
	    self.pipefilter(response, dest)
	  }
	}
	
	Request.prototype.qs = function (q, clobber) {
	  var self = this
	  var base
	  if (!clobber && self.uri.query) {
	    base = self._qs.parse(self.uri.query)
	  } else {
	    base = {}
	  }
	
	  for (var i in q) {
	    base[i] = q[i]
	  }
	
	  var qs = self._qs.stringify(base)
	
	  if (qs === '') {
	    return self
	  }
	
	  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)
	  self.url = self.uri
	  self.path = self.uri.path
	
	  if (self.uri.host === 'unix') {
	    self.enableUnixSocket()
	  }
	
	  return self
	}
	Request.prototype.form = function (form) {
	  var self = this
	  if (form) {
	    if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
	      self.setHeader('content-type', 'application/x-www-form-urlencoded')
	    }
	    self.body = (typeof form === 'string')
	      ? self._qs.rfc3986(form.toString('utf8'))
	      : self._qs.stringify(form).toString('utf8')
	    return self
	  }
	  // create form-data object
	  self._form = new FormData()
	  self._form.on('error', function(err) {
	    err.message = 'form-data: ' + err.message
	    self.emit('error', err)
	    self.abort()
	  })
	  return self._form
	}
	Request.prototype.multipart = function (multipart) {
	  var self = this
	
	  self._multipart.onRequest(multipart)
	
	  if (!self._multipart.chunked) {
	    self.body = self._multipart.body
	  }
	
	  return self
	}
	Request.prototype.json = function (val) {
	  var self = this
	
	  if (!self.hasHeader('accept')) {
	    self.setHeader('accept', 'application/json')
	  }
	
	  if (typeof self.jsonReplacer === 'function') {
	    self._jsonReplacer = self.jsonReplacer
	  }
	
	  self._json = true
	  if (typeof val === 'boolean') {
	    if (self.body !== undefined) {
	      if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
	        self.body = safeStringify(self.body, self._jsonReplacer)
	      } else {
	        self.body = self._qs.rfc3986(self.body)
	      }
	      if (!self.hasHeader('content-type')) {
	        self.setHeader('content-type', 'application/json')
	      }
	    }
	  } else {
	    self.body = safeStringify(val, self._jsonReplacer)
	    if (!self.hasHeader('content-type')) {
	      self.setHeader('content-type', 'application/json')
	    }
	  }
	
	  if (typeof self.jsonReviver === 'function') {
	    self._jsonReviver = self.jsonReviver
	  }
	
	  return self
	}
	Request.prototype.getHeader = function (name, headers) {
	  var self = this
	  var result, re, match
	  if (!headers) {
	    headers = self.headers
	  }
	  Object.keys(headers).forEach(function (key) {
	    if (key.length !== name.length) {
	      return
	    }
	    re = new RegExp(name, 'i')
	    match = key.match(re)
	    if (match) {
	      result = headers[key]
	    }
	  })
	  return result
	}
	Request.prototype.enableUnixSocket = function () {
	  // Get the socket & request paths from the URL
	  var unixParts = this.uri.path.split(':')
	    , host = unixParts[0]
	    , path = unixParts[1]
	  // Apply unix properties to request
	  this.socketPath = host
	  this.uri.pathname = path
	  this.uri.path = path
	  this.uri.host = host
	  this.uri.hostname = host
	  this.uri.isUnix = true
	}
	
	
	Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
	  var self = this
	
	  self._auth.onRequest(user, pass, sendImmediately, bearer)
	
	  return self
	}
	Request.prototype.aws = function (opts, now) {
	  var self = this
	
	  if (!now) {
	    self._aws = opts
	    return self
	  }
	  
	  if (opts.sign_version == 4 || opts.sign_version == '4') {
	    var aws4 = __webpack_require__(/*! aws4 */ 741)
	    // use aws4  
	    var options = {
	      host: self.uri.host,
	      path: self.uri.path,
	      method: self.method,
	      headers: {
	        'content-type': self.getHeader('content-type') || ''
	      },
	      body: self.body
	    }
	    var signRes = aws4.sign(options, {
	      accessKeyId: opts.key,
	      secretAccessKey: opts.secret
	    })
	    self.setHeader('authorization', signRes.headers.Authorization)
	    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])
	  }
	  else {
	    // default: use aws-sign2
	    var date = new Date()
	    self.setHeader('date', date.toUTCString())
	    var auth =
	      { key: opts.key
	      , secret: opts.secret
	      , verb: self.method.toUpperCase()
	      , date: date
	      , contentType: self.getHeader('content-type') || ''
	      , md5: self.getHeader('content-md5') || ''
	      , amazonHeaders: aws2.canonicalizeHeaders(self.headers)
	      }
	    var path = self.uri.path
	    if (opts.bucket && path) {
	      auth.resource = '/' + opts.bucket + path
	    } else if (opts.bucket && !path) {
	      auth.resource = '/' + opts.bucket
	    } else if (!opts.bucket && path) {
	      auth.resource = path
	    } else if (!opts.bucket && !path) {
	      auth.resource = '/'
	    }
	    auth.resource = aws2.canonicalizeResource(auth.resource)
	    self.setHeader('authorization', aws2.authorization(auth))
	  }
	
	  return self
	}
	Request.prototype.httpSignature = function (opts) {
	  var self = this
	  httpSignature.signRequest({
	    getHeader: function(header) {
	      return self.getHeader(header, self.headers)
	    },
	    setHeader: function(header, value) {
	      self.setHeader(header, value)
	    },
	    method: self.method,
	    path: self.path
	  }, opts)
	  debug('httpSignature authorization', self.getHeader('authorization'))
	
	  return self
	}
	Request.prototype.hawk = function (opts) {
	  var self = this
	  self.setHeader('Authorization', hawk.client.header(self.uri, self.method, opts).field)
	}
	Request.prototype.oauth = function (_oauth) {
	  var self = this
	
	  self._oauth.onRequest(_oauth)
	
	  return self
	}
	
	Request.prototype.jar = function (jar) {
	  var self = this
	  var cookies
	
	  if (self._redirect.redirectsFollowed === 0) {
	    self.originalCookieHeader = self.getHeader('cookie')
	  }
	
	  if (!jar) {
	    // disable cookies
	    cookies = false
	    self._disableCookies = true
	  } else {
	    var targetCookieJar = (jar && jar.getCookieString) ? jar : globalCookieJar
	    var urihref = self.uri.href
	    //fetch cookie in the Specified host
	    if (targetCookieJar) {
	      cookies = targetCookieJar.getCookieString(urihref)
	    }
	  }
	
	  //if need cookie and cookie is not empty
	  if (cookies && cookies.length) {
	    if (self.originalCookieHeader) {
	      // Don't overwrite existing Cookie header
	      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)
	    } else {
	      self.setHeader('cookie', cookies)
	    }
	  }
	  self._jar = jar
	  return self
	}
	
	
	// Stream API
	Request.prototype.pipe = function (dest, opts) {
	  var self = this
	
	  if (self.response) {
	    if (self._destdata) {
	      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))
	    } else if (self._ended) {
	      self.emit('error', new Error('You cannot pipe after the response has been ended.'))
	    } else {
	      stream.Stream.prototype.pipe.call(self, dest, opts)
	      self.pipeDest(dest)
	      return dest
	    }
	  } else {
	    self.dests.push(dest)
	    stream.Stream.prototype.pipe.call(self, dest, opts)
	    return dest
	  }
	}
	Request.prototype.write = function () {
	  var self = this
	  if (self._aborted) {return}
	
	  if (!self._started) {
	    self.start()
	  }
	  if (self.req) {
	    return self.req.write.apply(self.req, arguments)
	  }
	}
	Request.prototype.end = function (chunk) {
	  var self = this
	  if (self._aborted) {return}
	
	  if (chunk) {
	    self.write(chunk)
	  }
	  if (!self._started) {
	    self.start()
	  }
	  if (self.req) {
	    self.req.end()
	  }
	}
	Request.prototype.pause = function () {
	  var self = this
	  if (!self.responseContent) {
	    self._paused = true
	  } else {
	    self.responseContent.pause.apply(self.responseContent, arguments)
	  }
	}
	Request.prototype.resume = function () {
	  var self = this
	  if (!self.responseContent) {
	    self._paused = false
	  } else {
	    self.responseContent.resume.apply(self.responseContent, arguments)
	  }
	}
	Request.prototype.destroy = function () {
	  var self = this
	  if (!self._ended) {
	    self.end()
	  } else if (self.response) {
	    self.response.destroy()
	  }
	}
	
	Request.defaultProxyHeaderWhiteList =
	  Tunnel.defaultProxyHeaderWhiteList.slice()
	
	Request.defaultProxyHeaderExclusiveList =
	  Tunnel.defaultProxyHeaderExclusiveList.slice()
	
	// Exports
	
	Request.prototype.toJSON = requestToJSON
	module.exports = Request


/***/ },
/* 603 */
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ function(module, exports) {

	module.exports = require("https");

/***/ },
/* 604 */
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("stream");

/***/ },
/* 605 */
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = require("zlib");

/***/ },
/* 606 */
/*!********************!*\
  !*** ./~/bl/bl.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	var DuplexStream = __webpack_require__(/*! readable-stream/duplex */ 607)
	  , util         = __webpack_require__(/*! util */ 597)
	
	
	function BufferList (callback) {
	  if (!(this instanceof BufferList))
	    return new BufferList(callback)
	
	  this._bufs  = []
	  this.length = 0
	
	  if (typeof callback == 'function') {
	    this._callback = callback
	
	    var piper = function piper (err) {
	      if (this._callback) {
	        this._callback(err)
	        this._callback = null
	      }
	    }.bind(this)
	
	    this.on('pipe', function onPipe (src) {
	      src.on('error', piper)
	    })
	    this.on('unpipe', function onUnpipe (src) {
	      src.removeListener('error', piper)
	    })
	  } else {
	    this.append(callback)
	  }
	
	  DuplexStream.call(this)
	}
	
	
	util.inherits(BufferList, DuplexStream)
	
	
	BufferList.prototype._offset = function _offset (offset) {
	  var tot = 0, i = 0, _t
	  for (; i < this._bufs.length; i++) {
	    _t = tot + this._bufs[i].length
	    if (offset < _t)
	      return [ i, offset - tot ]
	    tot = _t
	  }
	}
	
	
	BufferList.prototype.append = function append (buf) {
	  var i = 0
	    , newBuf
	
	  if (Array.isArray(buf)) {
	    for (; i < buf.length; i++)
	      this.append(buf[i])
	  } else if (buf instanceof BufferList) {
	    // unwrap argument into individual BufferLists
	    for (; i < buf._bufs.length; i++)
	      this.append(buf._bufs[i])
	  } else if (buf != null) {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf == 'number')
	      buf = buf.toString()
	
	    newBuf = Buffer.isBuffer(buf) ? buf : new Buffer(buf)
	    this._bufs.push(newBuf)
	    this.length += newBuf.length
	  }
	
	  return this
	}
	
	
	BufferList.prototype._write = function _write (buf, encoding, callback) {
	  this.append(buf)
	
	  if (typeof callback == 'function')
	    callback()
	}
	
	
	BufferList.prototype._read = function _read (size) {
	  if (!this.length)
	    return this.push(null)
	
	  size = Math.min(size, this.length)
	  this.push(this.slice(0, size))
	  this.consume(size)
	}
	
	
	BufferList.prototype.end = function end (chunk) {
	  DuplexStream.prototype.end.call(this, chunk)
	
	  if (this._callback) {
	    this._callback(null, this.slice())
	    this._callback = null
	  }
	}
	
	
	BufferList.prototype.get = function get (index) {
	  return this.slice(index, index + 1)[0]
	}
	
	
	BufferList.prototype.slice = function slice (start, end) {
	  return this.copy(null, 0, start, end)
	}
	
	
	BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart != 'number' || srcStart < 0)
	    srcStart = 0
	  if (typeof srcEnd != 'number' || srcEnd > this.length)
	    srcEnd = this.length
	  if (srcStart >= this.length)
	    return dst || new Buffer(0)
	  if (srcEnd <= 0)
	    return dst || new Buffer(0)
	
	  var copy   = !!dst
	    , off    = this._offset(srcStart)
	    , len    = srcEnd - srcStart
	    , bytes  = len
	    , bufoff = (copy && dstStart) || 0
	    , start  = off[1]
	    , l
	    , i
	
	  // copy/slice everything
	  if (srcStart === 0 && srcEnd == this.length) {
	    if (!copy) // slice, just return a full concat
	      return Buffer.concat(this._bufs)
	
	    // copy, need to copy individual buffers
	    for (i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff)
	      bufoff += this._bufs[i].length
	    }
	
	    return dst
	  }
	
	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }
	
	  if (!copy) // a slice, we need something to copy in to
	    dst = new Buffer(len)
	
	  for (i = off[0]; i < this._bufs.length; i++) {
	    l = this._bufs[i].length - start
	
	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start)
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes)
	      break
	    }
	
	    bufoff += l
	    bytes -= l
	
	    if (start)
	      start = 0
	  }
	
	  return dst
	}
	
	BufferList.prototype.toString = function toString (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	}
	
	BufferList.prototype.consume = function consume (bytes) {
	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length
	      this.length -= this._bufs[0].length
	      this._bufs.shift()
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes)
	      this.length -= bytes
	      break
	    }
	  }
	  return this
	}
	
	
	BufferList.prototype.duplicate = function duplicate () {
	  var i = 0
	    , copy = new BufferList()
	
	  for (; i < this._bufs.length; i++)
	    copy.append(this._bufs[i])
	
	  return copy
	}
	
	
	BufferList.prototype.destroy = function destroy () {
	  this._bufs.length = 0
	  this.length = 0
	  this.push(null)
	}
	
	
	;(function () {
	  var methods = {
	      'readDoubleBE' : 8
	    , 'readDoubleLE' : 8
	    , 'readFloatBE'  : 4
	    , 'readFloatLE'  : 4
	    , 'readInt32BE'  : 4
	    , 'readInt32LE'  : 4
	    , 'readUInt32BE' : 4
	    , 'readUInt32LE' : 4
	    , 'readInt16BE'  : 2
	    , 'readInt16LE'  : 2
	    , 'readUInt16BE' : 2
	    , 'readUInt16LE' : 2
	    , 'readInt8'     : 1
	    , 'readUInt8'    : 1
	  }
	
	  for (var m in methods) {
	    (function (m) {
	      BufferList.prototype[m] = function (offset) {
	        return this.slice(offset, offset + methods[m])[m](0)
	      }
	    }(m))
	  }
	}())
	
	
	module.exports = BufferList


/***/ },
/* 607 */
/*!*************************************!*\
  !*** ./~/readable-stream/duplex.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ 608)


/***/ },
/* 608 */
/*!*************************************************!*\
  !*** ./~/readable-stream/lib/_stream_duplex.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/
	
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 609);
	util.inherits = __webpack_require__(/*! inherits */ 610);
	/*</replacement>*/
	
	var Readable = __webpack_require__(/*! ./_stream_readable */ 611);
	var Writable = __webpack_require__(/*! ./_stream_writable */ 616);
	
	util.inherits(Duplex, Readable);
	
	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});
	
	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false)
	    this.readable = false;
	
	  if (options && options.writable === false)
	    this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}


/***/ },
/* 609 */
/*!************************************!*\
  !*** ./~/core-util-is/lib/util.js ***!
  \************************************/
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


/***/ },
/* 610 */
/*!********************************!*\
  !*** ./~/inherits/inherits.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! util */ 597).inherits


/***/ },
/* 611 */
/*!***************************************************!*\
  !*** ./~/readable-stream/lib/_stream_readable.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(/*! isarray */ 612);
	/*</replacement>*/
	
	
	/*<replacement>*/
	var Buffer = __webpack_require__(/*! buffer */ 613).Buffer;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	var EE = __webpack_require__(/*! events */ 614).EventEmitter;
	
	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	var Stream = __webpack_require__(/*! stream */ 604);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 609);
	util.inherits = __webpack_require__(/*! inherits */ 610);
	/*</replacement>*/
	
	var StringDecoder;
	
	
	/*<replacement>*/
	var debug = __webpack_require__(/*! util */ 597);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	
	util.inherits(Readable, Stream);
	
	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 608);
	
	  options = options || {};
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(/*! string_decoder/ */ 615).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 608);
	
	  if (!(this instanceof Readable))
	    return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;
	
	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);
	
	      if (!addToFront)
	        state.reading = false;
	
	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);
	
	        if (state.needReadable)
	          emitReadable(stream);
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(/*! string_decoder/ */ 615).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}
	
	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;
	
	  if (state.objectMode)
	    return n === 0 ? 0 : 1;
	
	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }
	
	  if (n <= 0)
	    return 0;
	
	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);
	
	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }
	
	  return n;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }
	
	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }
	
	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);
	
	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;
	
	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }
	
	  state.length -= n;
	
	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;
	
	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);
	
	  if (!util.isNull(ret))
	    this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	
	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};
	
	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }
	
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];
	
	
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	
	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;
	
	    if (!dest)
	      dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }
	
	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;
	
	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }
	
	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}
	
	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}
	
	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;
	
	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;
	
	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);
	
	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);
	
	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);
	
	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();
	
	        c += cpy;
	      }
	    }
	  }
	
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}
	
	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}


/***/ },
/* 612 */
/*!****************************!*\
  !*** ./~/isarray/index.js ***!
  \****************************/
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 613 */
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 614 */
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("events");

/***/ },
/* 615 */
/*!***********************************!*\
  !*** ./~/string_decoder/index.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(/*! buffer */ 613).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 616 */
/*!***************************************************!*\
  !*** ./~/readable-stream/lib/_stream_writable.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.
	
	module.exports = Writable;
	
	/*<replacement>*/
	var Buffer = __webpack_require__(/*! buffer */ 613).Buffer;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 609);
	util.inherits = __webpack_require__(/*! inherits */ 610);
	/*</replacement>*/
	
	var Stream = __webpack_require__(/*! stream */ 604);
	
	util.inherits(Writable, Stream);
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}
	
	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 608);
	
	  options = options || {};
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;
	
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.buffer = [];
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}
	
	function Writable(options) {
	  var Duplex = __webpack_require__(/*! ./_stream_duplex */ 608);
	
	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};
	
	
	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;
	
	  if (!util.isFunction(cb))
	    cb = function() {};
	
	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function() {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function() {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;
	
	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);
	
	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	
	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);
	
	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });
	
	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }
	
	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }
	
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};
	
	
	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}


/***/ },
/* 617 */
/*!*****************************!*\
  !*** ./~/hawk/lib/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// Export sub-modules
	
	exports.error = exports.Error = __webpack_require__(/*! boom */ 618);
	exports.sntp = __webpack_require__(/*! sntp */ 621);
	
	exports.server = __webpack_require__(/*! ./server */ 625);
	exports.client = __webpack_require__(/*! ./client */ 630);
	exports.crypto = __webpack_require__(/*! ./crypto */ 627);
	exports.utils = __webpack_require__(/*! ./utils */ 628);
	
	exports.uri = {
	    authenticate: exports.server.authenticateBewit,
	    getBewit: exports.client.getBewit
	};
	


/***/ },
/* 618 */
/*!*****************************!*\
  !*** ./~/boom/lib/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Http = __webpack_require__(/*! http */ 533);
	var Hoek = __webpack_require__(/*! hoek */ 619);
	
	
	// Declare internals
	
	var internals = {};
	
	exports.wrap = function (error, statusCode, message) {
	
	    Hoek.assert(error instanceof Error, 'Cannot wrap non-Error object');
	    return (error.isBoom ? error : internals.initialize(error, statusCode || 500, message));
	};
	
	
	exports.create = function (statusCode, message, data) {
	
	    return internals.create(statusCode, message, data, exports.create);
	};
	
	internals.create = function (statusCode, message, data, ctor) {
	
	    var error = new Error(message ? message : undefined);       // Avoids settings null message
	    Error.captureStackTrace(error, ctor);                       // Filter the stack to our external API
	    error.data = data || null;
	    internals.initialize(error, statusCode);
	    return error;
	};
	
	internals.initialize = function (error, statusCode, message) {
	
	    var numberCode = parseInt(statusCode, 10);
	    Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);
	
	    error.isBoom = true;
	    error.isServer = numberCode >= 500;
	
	    if (!error.hasOwnProperty('data')) {
	        error.data = null;
	    }
	
	    error.output = {
	        statusCode: numberCode,
	        payload: {},
	        headers: {}
	    };
	
	    error.reformat = internals.reformat;
	    error.reformat();
	
	    if (!message &&
	        !error.message) {
	
	        message = error.output.payload.error;
	    }
	
	    if (message) {
	        error.message = (message + (error.message ? ': ' + error.message : ''));
	    }
	
	    return error;
	};
	
	
	internals.reformat = function () {
	
	    this.output.payload.statusCode = this.output.statusCode;
	    this.output.payload.error = Http.STATUS_CODES[this.output.statusCode] || 'Unknown';
	
	    if (this.output.statusCode === 500) {
	        this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user
	    }
	    else if (this.message) {
	        this.output.payload.message = this.message;
	    }
	};
	
	
	// 4xx Client Errors
	
	exports.badRequest = function (message, data) {
	
	    return internals.create(400, message, data, exports.badRequest);
	};
	
	
	exports.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])
	
	    var err = internals.create(401, message, undefined, exports.unauthorized);
	
	    if (!scheme) {
	        return err;
	    }
	
	    var wwwAuthenticate = '';
	    var i = 0;
	    var il = 0;
	
	    if (typeof scheme === 'string') {
	
	        // function (message, scheme, attributes)
	
	        wwwAuthenticate = scheme;
	
	        if (attributes || message) {
	            err.output.payload.attributes = {};
	        }
	
	        if (attributes) {
	            var names = Object.keys(attributes);
	            for (i = 0, il = names.length; i < il; ++i) {
	                var name = names[i];
	                if (i) {
	                    wwwAuthenticate += ',';
	                }
	
	                var value = attributes[name];
	                if (value === null ||
	                    value === undefined) {              // Value can be zero
	
	                    value = '';
	                }
	                wwwAuthenticate += ' ' + name + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
	                err.output.payload.attributes[name] = value;
	            }
	        }
	
	        if (message) {
	            if (attributes) {
	                wwwAuthenticate += ',';
	            }
	            wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
	            err.output.payload.attributes.error = message;
	        }
	        else {
	            err.isMissing = true;
	        }
	    }
	    else {
	
	        // function (message, wwwAuthenticate[])
	
	        var wwwArray = scheme;
	        for (i = 0, il = wwwArray.length; i < il; ++i) {
	            if (i) {
	                wwwAuthenticate += ', ';
	            }
	
	            wwwAuthenticate += wwwArray[i];
	        }
	    }
	
	    err.output.headers['WWW-Authenticate'] = wwwAuthenticate;
	
	    return err;
	};
	
	
	exports.forbidden = function (message, data) {
	
	    return internals.create(403, message, data, exports.forbidden);
	};
	
	
	exports.notFound = function (message, data) {
	
	    return internals.create(404, message, data, exports.notFound);
	};
	
	
	exports.methodNotAllowed = function (message, data) {
	
	    return internals.create(405, message, data, exports.methodNotAllowed);
	};
	
	
	exports.notAcceptable = function (message, data) {
	
	    return internals.create(406, message, data, exports.notAcceptable);
	};
	
	
	exports.proxyAuthRequired = function (message, data) {
	
	    return internals.create(407, message, data, exports.proxyAuthRequired);
	};
	
	
	exports.clientTimeout = function (message, data) {
	
	    return internals.create(408, message, data, exports.clientTimeout);
	};
	
	
	exports.conflict = function (message, data) {
	
	    return internals.create(409, message, data, exports.conflict);
	};
	
	
	exports.resourceGone = function (message, data) {
	
	    return internals.create(410, message, data, exports.resourceGone);
	};
	
	
	exports.lengthRequired = function (message, data) {
	
	    return internals.create(411, message, data, exports.lengthRequired);
	};
	
	
	exports.preconditionFailed = function (message, data) {
	
	    return internals.create(412, message, data, exports.preconditionFailed);
	};
	
	
	exports.entityTooLarge = function (message, data) {
	
	    return internals.create(413, message, data, exports.entityTooLarge);
	};
	
	
	exports.uriTooLong = function (message, data) {
	
	    return internals.create(414, message, data, exports.uriTooLong);
	};
	
	
	exports.unsupportedMediaType = function (message, data) {
	
	    return internals.create(415, message, data, exports.unsupportedMediaType);
	};
	
	
	exports.rangeNotSatisfiable = function (message, data) {
	
	    return internals.create(416, message, data, exports.rangeNotSatisfiable);
	};
	
	
	exports.expectationFailed = function (message, data) {
	
	    return internals.create(417, message, data, exports.expectationFailed);
	};
	
	exports.badData = function (message, data) {
	
	    return internals.create(422, message, data, exports.badData);
	};
	
	
	exports.preconditionRequired = function (message, data) {
	
	    return internals.create(428, message, data, exports.preconditionRequired);
	};
	
	
	exports.tooManyRequests = function (message, data) {
	
	    return internals.create(429, message, data, exports.tooManyRequests);
	};
	
	
	// 5xx Server Errors
	
	exports.internal = function (message, data, statusCode) {
	
	    return internals.serverError(message, data, statusCode, exports.internal);
	};
	
	internals.serverError = function (message, data, statusCode, ctor) {
	
	    var error;
	    if (data instanceof Error) {
	        error = exports.wrap(data, statusCode, message);
	    } else {
	        error = internals.create(statusCode || 500, message, undefined, ctor);
	        error.data = data;
	    }
	
	    return error;
	};
	
	
	exports.notImplemented = function (message, data) {
	
	    return internals.serverError(message, data, 501, exports.notImplemented);
	};
	
	
	exports.badGateway = function (message, data) {
	
	    return internals.serverError(message, data, 502, exports.badGateway);
	};
	
	
	exports.serverTimeout = function (message, data) {
	
	    return internals.serverError(message, data, 503, exports.serverTimeout);
	};
	
	
	exports.gatewayTimeout = function (message, data) {
	
	    return internals.serverError(message, data, 504, exports.gatewayTimeout);
	};
	
	
	exports.badImplementation = function (message, data) {
	
	    var err = internals.serverError(message, data, 500, exports.badImplementation);
	    err.isDeveloperError = true;
	    return err;
	};


/***/ },
/* 619 */
/*!*****************************!*\
  !*** ./~/hoek/lib/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Crypto = __webpack_require__(/*! crypto */ 601);
	var Path = __webpack_require__(/*! path */ 521);
	var Util = __webpack_require__(/*! util */ 597);
	var Escape = __webpack_require__(/*! ./escape */ 620);
	
	
	// Declare internals
	
	var internals = {};
	
	
	// Clone object or array
	
	exports.clone = function (obj, seen) {
	
	    if (typeof obj !== 'object' ||
	        obj === null) {
	
	        return obj;
	    }
	
	    seen = seen || { orig: [], copy: [] };
	
	    var lookup = seen.orig.indexOf(obj);
	    if (lookup !== -1) {
	        return seen.copy[lookup];
	    }
	
	    var newObj;
	    var cloneDeep = false;
	
	    if (!Array.isArray(obj)) {
	        if (Buffer.isBuffer(obj)) {
	            newObj = new Buffer(obj);
	        }
	        else if (obj instanceof Date) {
	            newObj = new Date(obj.getTime());
	        }
	        else if (obj instanceof RegExp) {
	            newObj = new RegExp(obj);
	        }
	        else {
	            var proto = Object.getPrototypeOf(obj);
	            if (proto &&
	                proto.isImmutable) {
	
	                newObj = obj;
	            }
	            else {
	                newObj = Object.create(proto);
	                cloneDeep = true;
	            }
	        }
	    }
	    else {
	        newObj = [];
	        cloneDeep = true;
	    }
	
	    seen.orig.push(obj);
	    seen.copy.push(newObj);
	
	    if (cloneDeep) {
	        var keys = Object.getOwnPropertyNames(obj);
	        for (var i = 0, il = keys.length; i < il; ++i) {
	            var key = keys[i];
	            var descriptor = Object.getOwnPropertyDescriptor(obj, key);
	            if (descriptor &&
	                (descriptor.get ||
	                 descriptor.set)) {
	
	                Object.defineProperty(newObj, key, descriptor);
	            }
	            else {
	                newObj[key] = exports.clone(obj[key], seen);
	            }
	        }
	    }
	
	    return newObj;
	};
	
	
	// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied
	/*eslint-disable */
	exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {
	/*eslint-enable */
	    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
	    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');
	
	    if (!source) {
	        return target;
	    }
	
	    if (Array.isArray(source)) {
	        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
	        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
	            target.length = 0;                                                          // Must not change target assignment
	        }
	
	        for (var i = 0, il = source.length; i < il; ++i) {
	            target.push(exports.clone(source[i]));
	        }
	
	        return target;
	    }
	
	    var keys = Object.keys(source);
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var value = source[key];
	        if (value &&
	            typeof value === 'object') {
	
	            if (!target[key] ||
	                typeof target[key] !== 'object' ||
	                (Array.isArray(target[key]) ^ Array.isArray(value)) ||
	                value instanceof Date ||
	                Buffer.isBuffer(value) ||
	                value instanceof RegExp) {
	
	                target[key] = exports.clone(value);
	            }
	            else {
	                exports.merge(target[key], value, isNullOverride, isMergeArrays);
	            }
	        }
	        else {
	            if (value !== null &&
	                value !== undefined) {                              // Explicit to preserve empty strings
	
	                target[key] = value;
	            }
	            else if (isNullOverride !== false) {                    // Defaults to true
	                target[key] = value;
	            }
	        }
	    }
	
	    return target;
	};
	
	
	// Apply options to a copy of the defaults
	
	exports.applyToDefaults = function (defaults, options, isNullOverride) {
	
	    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
	    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
	
	    if (!options) {                                                 // If no options, return null
	        return null;
	    }
	
	    var copy = exports.clone(defaults);
	
	    if (options === true) {                                         // If options is set to true, use defaults
	        return copy;
	    }
	
	    return exports.merge(copy, options, isNullOverride === true, false);
	};
	
	
	// Clone an object except for the listed keys which are shallow copied
	
	exports.cloneWithShallow = function (source, keys) {
	
	    if (!source ||
	        typeof source !== 'object') {
	
	        return source;
	    }
	
	    var storage = internals.store(source, keys);    // Move shallow copy items to storage
	    var copy = exports.clone(source);               // Deep copy the rest
	    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore
	    return copy;
	};
	
	
	internals.store = function (source, keys) {
	
	    var storage = {};
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        var value = exports.reach(source, key);
	        if (value !== undefined) {
	            storage[key] = value;
	            internals.reachSet(source, key, undefined);
	        }
	    }
	
	    return storage;
	};
	
	
	internals.restore = function (copy, source, storage) {
	
	    var keys = Object.keys(storage);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        internals.reachSet(copy, key, storage[key]);
	        internals.reachSet(source, key, storage[key]);
	    }
	};
	
	
	internals.reachSet = function (obj, key, value) {
	
	    var path = key.split('.');
	    var ref = obj;
	    for (var i = 0, il = path.length; i < il; ++i) {
	        var segment = path[i];
	        if (i + 1 === il) {
	            ref[segment] = value;
	        }
	
	        ref = ref[segment];
	    }
	};
	
	
	// Apply options to defaults except for the listed keys which are shallow copied from option without merging
	
	exports.applyToDefaultsWithShallow = function (defaults, options, keys) {
	
	    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
	    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
	    exports.assert(keys && Array.isArray(keys), 'Invalid keys');
	
	    if (!options) {                                                 // If no options, return null
	        return null;
	    }
	
	    var copy = exports.cloneWithShallow(defaults, keys);
	
	    if (options === true) {                                         // If options is set to true, use defaults
	        return copy;
	    }
	
	    var storage = internals.store(options, keys);   // Move shallow copy items to storage
	    exports.merge(copy, options, false, false);     // Deep copy the rest
	    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore
	    return copy;
	};
	
	
	// Deep object or array comparison
	
	exports.deepEqual = function (obj, ref, options, seen) {
	
	    options = options || { prototype: true };
	
	    var type = typeof obj;
	
	    if (type !== typeof ref) {
	        return false;
	    }
	
	    if (type !== 'object' ||
	        obj === null ||
	        ref === null) {
	
	        if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
	            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0
	        }
	
	        return obj !== obj && ref !== ref;                  // NaN
	    }
	
	    seen = seen || [];
	    if (seen.indexOf(obj) !== -1) {
	        return true;                            // If previous comparison failed, it would have stopped execution
	    }
	
	    seen.push(obj);
	
	    if (Array.isArray(obj)) {
	        if (!Array.isArray(ref)) {
	            return false;
	        }
	
	        if (!options.part && obj.length !== ref.length) {
	            return false;
	        }
	
	        for (var i = 0, il = obj.length; i < il; ++i) {
	            if (options.part) {
	                var found = false;
	                for (var r = 0, rl = ref.length; r < rl; ++r) {
	                    if (exports.deepEqual(obj[i], ref[r], options, seen)) {
	                        found = true;
	                        break;
	                    }
	                }
	
	                return found;
	            }
	
	            if (!exports.deepEqual(obj[i], ref[i], options, seen)) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	    if (Buffer.isBuffer(obj)) {
	        if (!Buffer.isBuffer(ref)) {
	            return false;
	        }
	
	        if (obj.length !== ref.length) {
	            return false;
	        }
	
	        for (var j = 0, jl = obj.length; j < jl; ++j) {
	            if (obj[j] !== ref[j]) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	
	    if (obj instanceof Date) {
	        return (ref instanceof Date && obj.getTime() === ref.getTime());
	    }
	
	    if (obj instanceof RegExp) {
	        return (ref instanceof RegExp && obj.toString() === ref.toString());
	    }
	
	    if (options.prototype) {
	        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
	            return false;
	        }
	    }
	
	    var keys = Object.getOwnPropertyNames(obj);
	
	    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
	        return false;
	    }
	
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var descriptor = Object.getOwnPropertyDescriptor(obj, key);
	        if (descriptor.get) {
	            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
	                return false;
	            }
	        }
	        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {
	            return false;
	        }
	    }
	
	    return true;
	};
	
	
	// Remove duplicate items from array
	
	exports.unique = function (array, key) {
	
	    var index = {};
	    var result = [];
	
	    for (var i = 0, il = array.length; i < il; ++i) {
	        var id = (key ? array[i][key] : array[i]);
	        if (index[id] !== true) {
	
	            result.push(array[i]);
	            index[id] = true;
	        }
	    }
	
	    return result;
	};
	
	
	// Convert array into object
	
	exports.mapToObject = function (array, key) {
	
	    if (!array) {
	        return null;
	    }
	
	    var obj = {};
	    for (var i = 0, il = array.length; i < il; ++i) {
	        if (key) {
	            if (array[i][key]) {
	                obj[array[i][key]] = true;
	            }
	        }
	        else {
	            obj[array[i]] = true;
	        }
	    }
	
	    return obj;
	};
	
	
	// Find the common unique items in two arrays
	
	exports.intersect = function (array1, array2, justFirst) {
	
	    if (!array1 || !array2) {
	        return [];
	    }
	
	    var common = [];
	    var hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);
	    var found = {};
	    for (var i = 0, il = array2.length; i < il; ++i) {
	        if (hash[array2[i]] && !found[array2[i]]) {
	            if (justFirst) {
	                return array2[i];
	            }
	
	            common.push(array2[i]);
	            found[array2[i]] = true;
	        }
	    }
	
	    return (justFirst ? null : common);
	};
	
	
	// Test if the reference contains the values
	
	exports.contain = function (ref, values, options) {
	
	    /*
	        string -> string(s)
	        array -> item(s)
	        object -> key(s)
	        object -> object (key:value)
	    */
	
	    var valuePairs = null;
	    if (typeof ref === 'object' &&
	        typeof values === 'object' &&
	        !Array.isArray(ref) &&
	        !Array.isArray(values)) {
	
	        valuePairs = values;
	        values = Object.keys(values);
	    }
	    else {
	        values = [].concat(values);
	    }
	
	    options = options || {};            // deep, once, only, part
	
	    exports.assert(arguments.length >= 2, 'Insufficient arguments');
	    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
	    exports.assert(values.length, 'Values array cannot be empty');
	
	    var compare, compareFlags;
	    if (options.deep) {
	        compare = exports.deepEqual;
	
	        var hasOnly = options.hasOwnProperty('only'), hasPart = options.hasOwnProperty('part');
	
	        compareFlags = {
	            prototype: hasOnly ? options.only : hasPart ? !options.part : false,
	            part: hasOnly ? !options.only : hasPart ? options.part : true
	        };
	    }
	    else {
	        compare = function (a, b) {
	
	            return a === b;
	        };
	    }
	
	    var misses = false;
	    var matches = new Array(values.length);
	    for (var i = 0, il = matches.length; i < il; ++i) {
	        matches[i] = 0;
	    }
	
	    if (typeof ref === 'string') {
	        var pattern = '(';
	        for (i = 0, il = values.length; i < il; ++i) {
	            var value = values[i];
	            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
	            pattern += (i ? '|' : '') + exports.escapeRegex(value);
	        }
	
	        var regex = new RegExp(pattern + ')', 'g');
	        var leftovers = ref.replace(regex, function ($0, $1) {
	
	            var index = values.indexOf($1);
	            ++matches[index];
	            return '';          // Remove from string
	        });
	
	        misses = !!leftovers;
	    }
	    else if (Array.isArray(ref)) {
	        for (i = 0, il = ref.length; i < il; ++i) {
	            for (var j = 0, jl = values.length, matched = false; j < jl && matched === false; ++j) {
	                matched = compare(values[j], ref[i], compareFlags) && j;
	            }
	
	            if (matched !== false) {
	                ++matches[matched];
	            }
	            else {
	                misses = true;
	            }
	        }
	    }
	    else {
	        var keys = Object.keys(ref);
	        for (i = 0, il = keys.length; i < il; ++i) {
	            var key = keys[i];
	            var pos = values.indexOf(key);
	            if (pos !== -1) {
	                if (valuePairs &&
	                    !compare(valuePairs[key], ref[key], compareFlags)) {
	
	                    return false;
	                }
	
	                ++matches[pos];
	            }
	            else {
	                misses = true;
	            }
	        }
	    }
	
	    var result = false;
	    for (i = 0, il = matches.length; i < il; ++i) {
	        result = result || !!matches[i];
	        if ((options.once && matches[i] > 1) ||
	            (!options.part && !matches[i])) {
	
	            return false;
	        }
	    }
	
	    if (options.only &&
	        misses) {
	
	        return false;
	    }
	
	    return result;
	};
	
	
	// Flatten array
	
	exports.flatten = function (array, target) {
	
	    var result = target || [];
	
	    for (var i = 0, il = array.length; i < il; ++i) {
	        if (Array.isArray(array[i])) {
	            exports.flatten(array[i], result);
	        }
	        else {
	            result.push(array[i]);
	        }
	    }
	
	    return result;
	};
	
	
	// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])
	
	exports.reach = function (obj, chain, options) {
	
	    if (chain === false ||
	        chain === null ||
	        typeof chain === 'undefined') {
	
	        return obj;
	    }
	
	    options = options || {};
	    if (typeof options === 'string') {
	        options = { separator: options };
	    }
	
	    var path = chain.split(options.separator || '.');
	    var ref = obj;
	    for (var i = 0, il = path.length; i < il; ++i) {
	        var key = path[i];
	        if (key[0] === '-' && Array.isArray(ref)) {
	            key = key.slice(1, key.length);
	            key = ref.length - key;
	        }
	
	        if (!ref ||
	            !ref.hasOwnProperty(key) ||
	            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties
	
	            exports.assert(!options.strict || i + 1 === il, 'Missing segment', key, 'in reach path ', chain);
	            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
	            ref = options.default;
	            break;
	        }
	
	        ref = ref[key];
	    }
	
	    return ref;
	};
	
	
	exports.reachTemplate = function (obj, template, options) {
	
	    return template.replace(/{([^}]+)}/g, function ($0, chain) {
	
	        var value = exports.reach(obj, chain, options);
	        return (value === undefined || value === null ? '' : value);
	    });
	};
	
	
	exports.formatStack = function (stack) {
	
	    var trace = [];
	    for (var i = 0, il = stack.length; i < il; ++i) {
	        var item = stack[i];
	        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
	    }
	
	    return trace;
	};
	
	
	exports.formatTrace = function (trace) {
	
	    var display = [];
	
	    for (var i = 0, il = trace.length; i < il; ++i) {
	        var row = trace[i];
	        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
	    }
	
	    return display;
	};
	
	
	exports.callStack = function (slice) {
	
	    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
	
	    var v8 = Error.prepareStackTrace;
	    Error.prepareStackTrace = function (err, stack) {
	
	        return stack;
	    };
	
	    var capture = {};
	    Error.captureStackTrace(capture, arguments.callee);     /*eslint no-caller:0 */
	    var stack = capture.stack;
	
	    Error.prepareStackTrace = v8;
	
	    var trace = exports.formatStack(stack);
	
	    if (slice) {
	        return trace.slice(slice);
	    }
	
	    return trace;
	};
	
	
	exports.displayStack = function (slice) {
	
	    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);
	
	    return exports.formatTrace(trace);
	};
	
	
	exports.abortThrow = false;
	
	
	exports.abort = function (message, hideStack) {
	
	    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
	        throw new Error(message || 'Unknown error');
	    }
	
	    var stack = '';
	    if (!hideStack) {
	        stack = exports.displayStack(1).join('\n\t');
	    }
	    console.log('ABORT: ' + message + '\n\t' + stack);
	    process.exit(1);
	};
	
	
	exports.assert = function (condition /*, msg1, msg2, msg3 */) {
	
	    if (condition) {
	        return;
	    }
	
	    if (arguments.length === 2 && arguments[1] instanceof Error) {
	        throw arguments[1];
	    }
	
	    var msgs = [];
	    for (var i = 1, il = arguments.length; i < il; ++i) {
	        if (arguments[i] !== '') {
	            msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations
	        }
	    }
	
	    msgs = msgs.map(function (msg) {
	
	        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);
	    });
	    throw new Error(msgs.join(' ') || 'Unknown error');
	};
	
	
	exports.Timer = function () {
	
	    this.ts = 0;
	    this.reset();
	};
	
	
	exports.Timer.prototype.reset = function () {
	
	    this.ts = Date.now();
	};
	
	
	exports.Timer.prototype.elapsed = function () {
	
	    return Date.now() - this.ts;
	};
	
	
	exports.Bench = function () {
	
	    this.ts = 0;
	    this.reset();
	};
	
	
	exports.Bench.prototype.reset = function () {
	
	    this.ts = exports.Bench.now();
	};
	
	
	exports.Bench.prototype.elapsed = function () {
	
	    return exports.Bench.now() - this.ts;
	};
	
	
	exports.Bench.now = function () {
	
	    var ts = process.hrtime();
	    return (ts[0] * 1e3) + (ts[1] / 1e6);
	};
	
	
	// Escape string for Regex construction
	
	exports.escapeRegex = function (string) {
	
	    // Escape ^$.*+-?=!:|\/()[]{},
	    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
	};
	
	
	// Base64url (RFC 4648) encode
	
	exports.base64urlEncode = function (value, encoding) {
	
	    var buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));
	    return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
	};
	
	
	// Base64url (RFC 4648) decode
	
	exports.base64urlDecode = function (value, encoding) {
	
	    if (value &&
	        !/^[\w\-]*$/.test(value)) {
	
	        return new Error('Invalid character');
	    }
	
	    try {
	        var buf = new Buffer(value, 'base64');
	        return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
	    }
	    catch (err) {
	        return err;
	    }
	};
	
	
	// Escape attribute value for use in HTTP header
	
	exports.escapeHeaderAttribute = function (attribute) {
	
	    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "
	
	    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');
	
	    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
	};
	
	
	exports.escapeHtml = function (string) {
	
	    return Escape.escapeHtml(string);
	};
	
	
	exports.escapeJavaScript = function (string) {
	
	    return Escape.escapeJavaScript(string);
	};
	
	
	exports.nextTick = function (callback) {
	
	    return function () {
	
	        var args = arguments;
	        process.nextTick(function () {
	
	            callback.apply(null, args);
	        });
	    };
	};
	
	
	exports.once = function (method) {
	
	    if (method._hoekOnce) {
	        return method;
	    }
	
	    var once = false;
	    var wrapped = function () {
	
	        if (!once) {
	            once = true;
	            method.apply(null, arguments);
	        }
	    };
	
	    wrapped._hoekOnce = true;
	
	    return wrapped;
	};
	
	
	exports.isAbsolutePath = function (path, platform) {
	
	    if (!path) {
	        return false;
	    }
	
	    if (Path.isAbsolute) {                      // node >= 0.11
	        return Path.isAbsolute(path);
	    }
	
	    platform = platform || process.platform;
	
	    // Unix
	
	    if (platform !== 'win32') {
	        return path[0] === '/';
	    }
	
	    // Windows
	
	    return !!/^(?:[a-zA-Z]:[\\\/])|(?:[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/])/.test(path);        // C:\ or \\something\something
	};
	
	
	exports.isInteger = function (value) {
	
	    return (typeof value === 'number' &&
	            parseFloat(value) === parseInt(value, 10) &&
	            !isNaN(value));
	};
	
	
	exports.ignore = function () { };
	
	
	exports.inherits = Util.inherits;
	
	
	exports.format = Util.format;
	
	
	exports.transform = function (source, transform, options) {
	
	    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');
	
	    if (Array.isArray(source)) {
	        var results = [];
	        for (var i = 0, il = source.length; i < il; ++i) {
	            results.push(exports.transform(source[i], transform, options));
	        }
	        return results;
	    }
	
	    var result = {};
	    var keys = Object.keys(transform);
	
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var path = key.split('.');
	        var sourcePath = transform[key];
	
	        exports.assert(typeof sourcePath === 'string', 'All mappings must be "." delineated strings');
	
	        var segment;
	        var res = result;
	
	        while (path.length > 1) {
	            segment = path.shift();
	            if (!res[segment]) {
	                res[segment] = {};
	            }
	            res = res[segment];
	        }
	        segment = path.shift();
	        res[segment] = exports.reach(source, sourcePath, options);
	    }
	
	    return result;
	};
	
	
	exports.uniqueFilename = function (path, extension) {
	
	    if (extension) {
	        extension = extension[0] !== '.' ? '.' + extension : extension;
	    }
	    else {
	        extension = '';
	    }
	
	    path = Path.resolve(path);
	    var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
	    return Path.join(path, name);
	};
	
	
	exports.stringify = function () {
	
	    try {
	        return JSON.stringify.apply(null, arguments);
	    }
	    catch (err) {
	        return '[Cannot display object: ' + err.message + ']';
	    }
	};
	
	
	exports.shallow = function (source) {
	
	    var target = {};
	    var keys = Object.keys(source);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        target[key] = source[key];
	    }
	
	    return target;
	};


/***/ },
/* 620 */
/*!******************************!*\
  !*** ./~/hoek/lib/escape.js ***!
  \******************************/
/***/ function(module, exports) {

	// Declare internals
	
	var internals = {};
	
	
	exports.escapeJavaScript = function (input) {
	
	    if (!input) {
	        return '';
	    }
	
	    var escaped = '';
	
	    for (var i = 0, il = input.length; i < il; ++i) {
	
	        var charCode = input.charCodeAt(i);
	
	        if (internals.isSafe(charCode)) {
	            escaped += input[i];
	        }
	        else {
	            escaped += internals.escapeJavaScriptChar(charCode);
	        }
	    }
	
	    return escaped;
	};
	
	
	exports.escapeHtml = function (input) {
	
	    if (!input) {
	        return '';
	    }
	
	    var escaped = '';
	
	    for (var i = 0, il = input.length; i < il; ++i) {
	
	        var charCode = input.charCodeAt(i);
	
	        if (internals.isSafe(charCode)) {
	            escaped += input[i];
	        }
	        else {
	            escaped += internals.escapeHtmlChar(charCode);
	        }
	    }
	
	    return escaped;
	};
	
	
	internals.escapeJavaScriptChar = function (charCode) {
	
	    if (charCode >= 256) {
	        return '\\u' + internals.padLeft('' + charCode, 4);
	    }
	
	    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
	    return '\\x' + internals.padLeft(hexValue, 2);
	};
	
	
	internals.escapeHtmlChar = function (charCode) {
	
	    var namedEscape = internals.namedHtml[charCode];
	    if (typeof namedEscape !== 'undefined') {
	        return namedEscape;
	    }
	
	    if (charCode >= 256) {
	        return '&#' + charCode + ';';
	    }
	
	    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
	    return '&#x' + internals.padLeft(hexValue, 2) + ';';
	};
	
	
	internals.padLeft = function (str, len) {
	
	    while (str.length < len) {
	        str = '0' + str;
	    }
	
	    return str;
	};
	
	
	internals.isSafe = function (charCode) {
	
	    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
	};
	
	
	internals.namedHtml = {
	    '38': '&amp;',
	    '60': '&lt;',
	    '62': '&gt;',
	    '34': '&quot;',
	    '160': '&nbsp;',
	    '162': '&cent;',
	    '163': '&pound;',
	    '164': '&curren;',
	    '169': '&copy;',
	    '174': '&reg;'
	};
	
	
	internals.safeCharCodes = (function () {
	
	    var safe = {};
	
	    for (var i = 32; i < 123; ++i) {
	
	        if ((i >= 97) ||                    // a-z
	            (i >= 65 && i <= 90) ||         // A-Z
	            (i >= 48 && i <= 57) ||         // 0-9
	            i === 32 ||                     // space
	            i === 46 ||                     // .
	            i === 44 ||                     // ,
	            i === 45 ||                     // -
	            i === 58 ||                     // :
	            i === 95) {                     // _
	
	            safe[i] = null;
	        }
	    }
	
	    return safe;
	}());


/***/ },
/* 621 */
/*!*************************!*\
  !*** ./~/sntp/index.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib */ 622);

/***/ },
/* 622 */
/*!*****************************!*\
  !*** ./~/sntp/lib/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Dgram = __webpack_require__(/*! dgram */ 623);
	var Dns = __webpack_require__(/*! dns */ 624);
	var Hoek = __webpack_require__(/*! hoek */ 619);
	
	
	// Declare internals
	
	var internals = {};
	
	
	exports.time = function (options, callback) {
	
	    if (arguments.length !== 2) {
	        callback = arguments[0];
	        options = {};
	    }
	
	    var settings = Hoek.clone(options);
	    settings.host = settings.host || 'pool.ntp.org';
	    settings.port = settings.port || 123;
	    settings.resolveReference = settings.resolveReference || false;
	
	    // Declare variables used by callback
	
	    var timeoutId = 0;
	    var sent = 0;
	
	    // Ensure callback is only called once
	
	    var finish = function (err, result) {
	
	        if (timeoutId) {
	            clearTimeout(timeoutId);
	            timeoutId = 0;
	        }
	
	        socket.removeAllListeners();
	        socket.once('error', internals.ignore);
	        socket.close();
	        return callback(err, result);
	    };
	
	    finish = Hoek.once(finish);
	
	    // Create UDP socket
	
	    var socket = Dgram.createSocket('udp4');
	
	    socket.once('error', function (err) {
	
	        return finish(err);
	    });
	
	    // Listen to incoming messages
	
	    socket.on('message', function (buffer, rinfo) {
	
	        var received = Date.now();
	
	        var message = new internals.NtpMessage(buffer);
	        if (!message.isValid) {
	            return finish(new Error('Invalid server response'), message);
	        }
	
	        if (message.originateTimestamp !== sent) {
	            return finish(new Error('Wrong originate timestamp'), message);
	        }
	
	        // Timestamp Name          ID   When Generated
	        // ------------------------------------------------------------
	        // Originate Timestamp     T1   time request sent by client
	        // Receive Timestamp       T2   time request received by server
	        // Transmit Timestamp      T3   time reply sent by server
	        // Destination Timestamp   T4   time reply received by client
	        //
	        // The roundtrip delay d and system clock offset t are defined as:
	        //
	        // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2
	
	        var T1 = message.originateTimestamp;
	        var T2 = message.receiveTimestamp;
	        var T3 = message.transmitTimestamp;
	        var T4 = received;
	
	        message.d = (T4 - T1) - (T3 - T2);
	        message.t = ((T2 - T1) + (T3 - T4)) / 2;
	        message.receivedLocally = received;
	
	        if (!settings.resolveReference ||
	            message.stratum !== 'secondary') {
	
	            return finish(null, message);
	        }
	
	        // Resolve reference IP address
	
	        Dns.reverse(message.referenceId, function (err, domains) {
	
	            if (/* $lab:coverage:off$ */ !err /* $lab:coverage:on$ */) {
	                message.referenceHost = domains[0];
	            }
	
	            return finish(null, message);
	        });
	    });
	
	    // Set timeout
	
	    if (settings.timeout) {
	        timeoutId = setTimeout(function () {
	
	            timeoutId = 0;
	            return finish(new Error('Timeout'));
	        }, settings.timeout);
	    }
	
	    // Construct NTP message
	
	    var message = new Buffer(48);
	    for (var i = 0; i < 48; i++) {                      // Zero message
	        message[i] = 0;
	    }
	
	    message[0] = (0 << 6) + (4 << 3) + (3 << 0)         // Set version number to 4 and Mode to 3 (client)
	    sent = Date.now();
	    internals.fromMsecs(sent, message, 40);               // Set transmit timestamp (returns as originate)
	
	    // Send NTP request
	
	    socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {
	
	        if (err ||
	            bytes !== 48) {
	
	            return finish(err || new Error('Could not send entire message'));
	        }
	    });
	};
	
	
	internals.NtpMessage = function (buffer) {
	
	    this.isValid = false;
	
	    // Validate
	
	    if (buffer.length !== 48) {
	        return;
	    }
	
	    // Leap indicator
	
	    var li = (buffer[0] >> 6);
	    switch (li) {
	        case 0: this.leapIndicator = 'no-warning'; break;
	        case 1: this.leapIndicator = 'last-minute-61'; break;
	        case 2: this.leapIndicator = 'last-minute-59'; break;
	        case 3: this.leapIndicator = 'alarm'; break;
	    }
	
	    // Version
	
	    var vn = ((buffer[0] & 0x38) >> 3);
	    this.version = vn;
	
	    // Mode
	
	    var mode = (buffer[0] & 0x7);
	    switch (mode) {
	        case 1: this.mode = 'symmetric-active'; break;
	        case 2: this.mode = 'symmetric-passive'; break;
	        case 3: this.mode = 'client'; break;
	        case 4: this.mode = 'server'; break;
	        case 5: this.mode = 'broadcast'; break;
	        case 0:
	        case 6:
	        case 7: this.mode = 'reserved'; break;
	    }
	
	    // Stratum
	
	    var stratum = buffer[1];
	    if (stratum === 0) {
	        this.stratum = 'death';
	    }
	    else if (stratum === 1) {
	        this.stratum = 'primary';
	    }
	    else if (stratum <= 15) {
	        this.stratum = 'secondary';
	    }
	    else {
	        this.stratum = 'reserved';
	    }
	
	    // Poll interval (msec)
	
	    this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;
	
	    // Precision (msecs)
	
	    this.precision = Math.pow(2, buffer[3]) * 1000;
	
	    // Root delay (msecs)
	
	    var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
	    this.rootDelay = 1000 * (rootDelay / 0x10000);
	
	    // Root dispersion (msecs)
	
	    this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;
	
	    // Reference identifier
	
	    this.referenceId = '';
	    switch (this.stratum) {
	        case 'death':
	        case 'primary':
	            this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
	            break;
	        case 'secondary':
	            this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
	            break;
	    }
	
	    // Reference timestamp
	
	    this.referenceTimestamp = internals.toMsecs(buffer, 16);
	
	    // Originate timestamp
	
	    this.originateTimestamp = internals.toMsecs(buffer, 24);
	
	    // Receive timestamp
	
	    this.receiveTimestamp = internals.toMsecs(buffer, 32);
	
	    // Transmit timestamp
	
	    this.transmitTimestamp = internals.toMsecs(buffer, 40);
	
	    // Validate
	
	    if (this.version === 4 &&
	        this.stratum !== 'reserved' &&
	        this.mode === 'server' &&
	        this.originateTimestamp &&
	        this.receiveTimestamp &&
	        this.transmitTimestamp) {
	
	        this.isValid = true;
	    }
	
	    return this;
	};
	
	
	internals.toMsecs = function (buffer, offset) {
	
	    var seconds = 0;
	    var fraction = 0;
	
	    for (var i = 0; i < 4; ++i) {
	        seconds = (seconds * 256) + buffer[offset + i];
	    }
	
	    for (i = 4; i < 8; ++i) {
	        fraction = (fraction * 256) + buffer[offset + i];
	    }
	
	    return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
	};
	
	
	internals.fromMsecs = function (ts, buffer, offset) {
	
	    var seconds = Math.floor(ts / 1000) + 2208988800;
	    var fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));
	
	    buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
	    buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
	    buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
	    buffer[offset + 3] = (seconds & 0x000000FF);
	
	    buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
	    buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
	    buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
	    buffer[offset + 7] = (fraction & 0x000000FF);
	};
	
	
	// Offset singleton
	
	internals.last = {
	    offset: 0,
	    expires: 0,
	    host: '',
	    port: 0
	};
	
	
	exports.offset = function (options, callback) {
	
	    if (arguments.length !== 2) {
	        callback = arguments[0];
	        options = {};
	    }
	
	    var now = Date.now();
	    var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily
	
	    if (internals.last.offset &&
	        internals.last.host === options.host &&
	        internals.last.port === options.port &&
	        now < internals.last.expires) {
	
	        process.nextTick(function () {
	
	            callback(null, internals.last.offset);
	        });
	
	        return;
	    }
	
	    exports.time(options, function (err, time) {
	
	        if (err) {
	            return callback(err, 0);
	        }
	
	        internals.last = {
	            offset: Math.round(time.t),
	            expires: now + clockSyncRefresh,
	            host: options.host,
	            port: options.port
	        };
	
	        return callback(null, internals.last.offset);
	    });
	};
	
	
	// Now singleton
	
	internals.now = {
	    intervalId: 0
	};
	
	
	exports.start = function (options, callback) {
	
	    if (arguments.length !== 2) {
	        callback = arguments[0];
	        options = {};
	    }
	
	    if (internals.now.intervalId) {
	        process.nextTick(function () {
	
	            callback();
	        });
	
	        return;
	    }
	
	    exports.offset(options, function (err, offset) {
	
	        internals.now.intervalId = setInterval(function () {
	
	            exports.offset(options, function () { });
	        }, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily
	
	        return callback();
	    });
	};
	
	
	exports.stop = function () {
	
	    if (!internals.now.intervalId) {
	        return;
	    }
	
	    clearInterval(internals.now.intervalId);
	    internals.now.intervalId = 0;
	};
	
	
	exports.isLive = function () {
	
	    return !!internals.now.intervalId;
	};
	
	
	exports.now = function () {
	
	    var now = Date.now();
	    if (!exports.isLive() ||
	        now >= internals.last.expires) {
	
	        return now;
	    }
	
	    return now + internals.last.offset;
	};
	
	
	internals.ignore = function () {
	
	};


/***/ },
/* 623 */
/*!************************!*\
  !*** external "dgram" ***!
  \************************/
/***/ function(module, exports) {

	module.exports = require("dgram");

/***/ },
/* 624 */
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("dns");

/***/ },
/* 625 */
/*!******************************!*\
  !*** ./~/hawk/lib/server.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Boom = __webpack_require__(/*! boom */ 618);
	var Hoek = __webpack_require__(/*! hoek */ 619);
	var Cryptiles = __webpack_require__(/*! cryptiles */ 626);
	var Crypto = __webpack_require__(/*! ./crypto */ 627);
	var Utils = __webpack_require__(/*! ./utils */ 628);
	
	
	// Declare internals
	
	var internals = {};
	
	
	// Hawk authentication
	
	/*
	   req:                 node's HTTP request object or an object as follows:
	
	                        var request = {
	                            method: 'GET',
	                            url: '/resource/4?a=1&b=2',
	                            host: 'example.com',
	                            port: 8080,
	                            authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
	                        };
	
	   credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
	                        The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
	                        needed by the application. This function is the equivalent of verifying the username and
	                        password in Basic authentication.
	
	                        var credentialsFunc = function (id, callback) {
	
	                            // Lookup credentials in database
	                            db.lookup(id, function (err, item) {
	
	                                if (err || !item) {
	                                    return callback(err);
	                                }
	
	                                var credentials = {
	                                    // Required
	                                    key: item.key,
	                                    algorithm: item.algorithm,
	                                    // Application specific
	                                    user: item.user
	                                };
	
	                                return callback(null, credentials);
	                            });
	                        };
	
	   options: {
	
	        hostHeaderName:        optional header field name, used to override the default 'Host' header when used
	                               behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
	                               the original (which is what the module must verify) in the 'x-forwarded-host' header field.
	                               Only used when passed a node Http.ServerRequest object.
	
	        nonceFunc:             optional nonce validation function. The function signature is function(key, nonce, ts, callback)
	                               where 'callback' must be called using the signature function(err).
	
	        timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
	                               Provides a +/- skew which means actual allowed window is double the number of seconds.
	
	        localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
	                               Defaults to 0.
	
	        payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
	                               header attribute. The server always ensures the value provided has been included in the request
	                               MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
	                               a hash value over the entire payload (assuming it has already be normalized to the same format and
	                               encoding used by the client to calculate the hash on request). If the payload is not available at the time
	                               of authentication, the authenticatePayload() method can be used by passing it the credentials and
	                               attributes.hash returned in the authenticate callback.
	
	        host:                  optional host name override. Only used when passed a node request object.
	        port:                  optional port override. Only used when passed a node request object.
	    }
	
	    callback: function (err, credentials, artifacts) { }
	 */
	
	exports.authenticate = function (req, credentialsFunc, options, callback) {
	
	    callback = Hoek.nextTick(callback);
	
	    // Default options
	
	    options.nonceFunc = options.nonceFunc || internals.nonceFunc;
	    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds
	
	    // Application time
	
	    var now = Utils.now(options.localtimeOffsetMsec);                           // Measure now before any other processing
	
	    // Convert node Http request object to a request configuration object
	
	    var request = Utils.parseRequest(req, options);
	    if (request instanceof Error) {
	        return callback(Boom.badRequest(request.message));
	    }
	
	    // Parse HTTP Authorization header
	
	    var attributes = Utils.parseAuthorizationHeader(request.authorization);
	    if (attributes instanceof Error) {
	        return callback(attributes);
	    }
	
	    // Construct artifacts container
	
	    var artifacts = {
	        method: request.method,
	        host: request.host,
	        port: request.port,
	        resource: request.url,
	        ts: attributes.ts,
	        nonce: attributes.nonce,
	        hash: attributes.hash,
	        ext: attributes.ext,
	        app: attributes.app,
	        dlg: attributes.dlg,
	        mac: attributes.mac,
	        id: attributes.id
	    };
	
	    // Verify required header attributes
	
	    if (!attributes.id ||
	        !attributes.ts ||
	        !attributes.nonce ||
	        !attributes.mac) {
	
	        return callback(Boom.badRequest('Missing attributes'), null, artifacts);
	    }
	
	    // Fetch Hawk credentials
	
	    credentialsFunc(attributes.id, function (err, credentials) {
	
	        if (err) {
	            return callback(err, credentials || null, artifacts);
	        }
	
	        if (!credentials) {
	            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, artifacts);
	        }
	
	        if (!credentials.key ||
	            !credentials.algorithm) {
	
	            return callback(Boom.internal('Invalid credentials'), credentials, artifacts);
	        }
	
	        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	            return callback(Boom.internal('Unknown algorithm'), credentials, artifacts);
	        }
	
	        // Calculate MAC
	
	        var mac = Crypto.calculateMac('header', credentials, artifacts);
	        if (!Cryptiles.fixedTimeComparison(mac, attributes.mac)) {
	            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, artifacts);
	        }
	
	        // Check payload hash
	
	        if (options.payload ||
	            options.payload === '') {
	
	            if (!attributes.hash) {
	                return callback(Boom.unauthorized('Missing required payload hash', 'Hawk'), credentials, artifacts);
	            }
	
	            var hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType);
	            if (!Cryptiles.fixedTimeComparison(hash, attributes.hash)) {
	                return callback(Boom.unauthorized('Bad payload hash', 'Hawk'), credentials, artifacts);
	            }
	        }
	
	        // Check nonce
	
	        options.nonceFunc(credentials.key, attributes.nonce, attributes.ts, function (err) {
	
	            if (err) {
	                return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials, artifacts);
	            }
	
	            // Check timestamp staleness
	
	            if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
	                var tsm = Crypto.timestampMessage(credentials, options.localtimeOffsetMsec);
	                return callback(Boom.unauthorized('Stale timestamp', 'Hawk', tsm), credentials, artifacts);
	            }
	
	            // Successful authentication
	
	            return callback(null, credentials, artifacts);
	        });
	    });
	};
	
	
	// Authenticate payload hash - used when payload cannot be provided during authenticate()
	
	/*
	    payload:        raw request payload
	    credentials:    from authenticate callback
	    artifacts:      from authenticate callback
	    contentType:    req.headers['content-type']
	*/
	
	exports.authenticatePayload = function (payload, credentials, artifacts, contentType) {
	
	    var calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType);
	    return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
	};
	
	
	// Authenticate payload hash - used when payload cannot be provided during authenticate()
	
	/*
	    calculatedHash: the payload hash calculated using Crypto.calculatePayloadHash()
	    artifacts:      from authenticate callback
	*/
	
	exports.authenticatePayloadHash = function (calculatedHash, artifacts) {
	
	    return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
	};
	
	
	// Generate a Server-Authorization header for a given response
	
	/*
	    credentials: {},                                        // Object received from authenticate()
	    artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
	    options: {
	        ext: 'application-specific',                        // Application specific data sent via the ext attribute
	        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
	        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
	        hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
	    }
	*/
	
	exports.header = function (credentials, artifacts, options) {
	
	    // Prepare inputs
	
	    options = options || {};
	
	    if (!artifacts ||
	        typeof artifacts !== 'object' ||
	        typeof options !== 'object') {
	
	        return '';
	    }
	
	    artifacts = Hoek.clone(artifacts);
	    delete artifacts.mac;
	    artifacts.hash = options.hash;
	    artifacts.ext = options.ext;
	
	    // Validate credentials
	
	    if (!credentials ||
	        !credentials.key ||
	        !credentials.algorithm) {
	
	        // Invalid credential object
	        return '';
	    }
	
	    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	        return '';
	    }
	
	    // Calculate payload hash
	
	    if (!artifacts.hash &&
	        (options.payload || options.payload === '')) {
	
	        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
	    }
	
	    var mac = Crypto.calculateMac('response', credentials, artifacts);
	
	    // Construct header
	
	    var header = 'Hawk mac="' + mac + '"' +
	                 (artifacts.hash ? ', hash="' + artifacts.hash + '"' : '');
	
	    if (artifacts.ext !== null &&
	        artifacts.ext !== undefined &&
	        artifacts.ext !== '') {                       // Other falsey values allowed
	
	        header += ', ext="' + Hoek.escapeHeaderAttribute(artifacts.ext) + '"';
	    }
	
	    return header;
	};
	
	
	/*
	 * Arguments and options are the same as authenticate() with the exception that the only supported options are:
	 * 'hostHeaderName', 'localtimeOffsetMsec', 'host', 'port'
	 */
	
	
	//                       1     2             3           4
	internals.bewitRegex = /^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/;
	
	
	exports.authenticateBewit = function (req, credentialsFunc, options, callback) {
	
	    callback = Hoek.nextTick(callback);
	
	    // Application time
	
	    var now = Utils.now(options.localtimeOffsetMsec);
	
	    // Convert node Http request object to a request configuration object
	
	    var request = Utils.parseRequest(req, options);
	    if (request instanceof Error) {
	        return callback(Boom.badRequest(request.message));
	    }
	
	    // Extract bewit
	
	    if (request.url.length > Utils.limits.maxMatchLength) {
	        return callback(Boom.badRequest('Resource path exceeds max length'));
	    }
	
	    var resource = request.url.match(internals.bewitRegex);
	    if (!resource) {
	        return callback(Boom.unauthorized(null, 'Hawk'));
	    }
	
	    // Bewit not empty
	
	    if (!resource[3]) {
	        return callback(Boom.unauthorized('Empty bewit', 'Hawk'));
	    }
	
	    // Verify method is GET
	
	    if (request.method !== 'GET' &&
	        request.method !== 'HEAD') {
	
	        return callback(Boom.unauthorized('Invalid method', 'Hawk'));
	    }
	
	    // No other authentication
	
	    if (request.authorization) {
	        return callback(Boom.badRequest('Multiple authentications'));
	    }
	
	    // Parse bewit
	
	    var bewitString = Hoek.base64urlDecode(resource[3]);
	    if (bewitString instanceof Error) {
	        return callback(Boom.badRequest('Invalid bewit encoding'));
	    }
	
	    // Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)
	
	    var bewitParts = bewitString.split('\\');
	    if (bewitParts.length !== 4) {
	        return callback(Boom.badRequest('Invalid bewit structure'));
	    }
	
	    var bewit = {
	        id: bewitParts[0],
	        exp: parseInt(bewitParts[1], 10),
	        mac: bewitParts[2],
	        ext: bewitParts[3] || ''
	    };
	
	    if (!bewit.id ||
	        !bewit.exp ||
	        !bewit.mac) {
	
	        return callback(Boom.badRequest('Missing bewit attributes'));
	    }
	
	    // Construct URL without bewit
	
	    var url = resource[1];
	    if (resource[4]) {
	        url += resource[2] + resource[4];
	    }
	
	    // Check expiration
	
	    if (bewit.exp * 1000 <= now) {
	        return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);
	    }
	
	    // Fetch Hawk credentials
	
	    credentialsFunc(bewit.id, function (err, credentials) {
	
	        if (err) {
	            return callback(err, credentials || null, bewit.ext);
	        }
	
	        if (!credentials) {
	            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);
	        }
	
	        if (!credentials.key ||
	            !credentials.algorithm) {
	
	            return callback(Boom.internal('Invalid credentials'), credentials, bewit);
	        }
	
	        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	            return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
	        }
	
	        // Calculate MAC
	
	        var mac = Crypto.calculateMac('bewit', credentials, {
	            ts: bewit.exp,
	            nonce: '',
	            method: 'GET',
	            resource: url,
	            host: request.host,
	            port: request.port,
	            ext: bewit.ext
	        });
	
	        if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
	            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);
	        }
	
	        // Successful authentication
	
	        return callback(null, credentials, bewit);
	    });
	};
	
	
	/*
	 *  options are the same as authenticate() with the exception that the only supported options are:
	 * 'nonceFunc', 'timestampSkewSec', 'localtimeOffsetMsec'
	 */
	
	exports.authenticateMessage = function (host, port, message, authorization, credentialsFunc, options, callback) {
	
	    callback = Hoek.nextTick(callback);
	
	    // Default options
	
	    options.nonceFunc = options.nonceFunc || internals.nonceFunc;
	    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds
	
	    // Application time
	
	    var now = Utils.now(options.localtimeOffsetMsec);                       // Measure now before any other processing
	
	    // Validate authorization
	
	    if (!authorization.id ||
	        !authorization.ts ||
	        !authorization.nonce ||
	        !authorization.hash ||
	        !authorization.mac) {
	
	        return callback(Boom.badRequest('Invalid authorization'));
	    }
	
	    // Fetch Hawk credentials
	
	    credentialsFunc(authorization.id, function (err, credentials) {
	
	        if (err) {
	            return callback(err, credentials || null);
	        }
	
	        if (!credentials) {
	            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'));
	        }
	
	        if (!credentials.key ||
	            !credentials.algorithm) {
	
	            return callback(Boom.internal('Invalid credentials'), credentials);
	        }
	
	        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	            return callback(Boom.internal('Unknown algorithm'), credentials);
	        }
	
	        // Construct artifacts container
	
	        var artifacts = {
	            ts: authorization.ts,
	            nonce: authorization.nonce,
	            host: host,
	            port: port,
	            hash: authorization.hash
	        };
	
	        // Calculate MAC
	
	        var mac = Crypto.calculateMac('message', credentials, artifacts);
	        if (!Cryptiles.fixedTimeComparison(mac, authorization.mac)) {
	            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials);
	        }
	
	        // Check payload hash
	
	        var hash = Crypto.calculatePayloadHash(message, credentials.algorithm);
	        if (!Cryptiles.fixedTimeComparison(hash, authorization.hash)) {
	            return callback(Boom.unauthorized('Bad message hash', 'Hawk'), credentials);
	        }
	
	        // Check nonce
	
	        options.nonceFunc(credentials.key, authorization.nonce, authorization.ts, function (err) {
	
	            if (err) {
	                return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials);
	            }
	
	            // Check timestamp staleness
	
	            if (Math.abs((authorization.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
	                return callback(Boom.unauthorized('Stale timestamp'), credentials);
	            }
	
	            // Successful authentication
	
	            return callback(null, credentials);
	        });
	    });
	};
	
	
	internals.nonceFunc = function (key, nonce, ts, nonceCallback) {
	
	    return nonceCallback();         // No validation
	};


/***/ },
/* 626 */
/*!**********************************!*\
  !*** ./~/cryptiles/lib/index.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Crypto = __webpack_require__(/*! crypto */ 601);
	var Boom = __webpack_require__(/*! boom */ 618);
	
	
	// Declare internals
	
	var internals = {};
	
	
	// Generate a cryptographically strong pseudo-random data
	
	exports.randomString = function (size) {
	
	    var buffer = exports.randomBits((size + 1) * 6);
	    if (buffer instanceof Error) {
	        return buffer;
	    }
	
	    var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
	    return string.slice(0, size);
	};
	
	
	exports.randomBits = function (bits) {
	
	    if (!bits ||
	        bits < 0) {
	
	        return Boom.internal('Invalid random bits count');
	    }
	
	    var bytes = Math.ceil(bits / 8);
	    try {
	        return Crypto.randomBytes(bytes);
	    }
	    catch (err) {
	        return Boom.internal('Failed generating random bits: ' + err.message);
	    }
	};
	
	
	// Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)
	
	exports.fixedTimeComparison = function (a, b) {
	
	    if (typeof a !== 'string' ||
	        typeof b !== 'string') {
	
	        return false;
	    }
	
	    var mismatch = (a.length === b.length ? 0 : 1);
	    if (mismatch) {
	        b = a;
	    }
	
	    for (var i = 0, il = a.length; i < il; ++i) {
	        var ac = a.charCodeAt(i);
	        var bc = b.charCodeAt(i);
	        mismatch |= (ac ^ bc);
	    }
	
	    return (mismatch === 0);
	};
	
	


/***/ },
/* 627 */
/*!******************************!*\
  !*** ./~/hawk/lib/crypto.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Crypto = __webpack_require__(/*! crypto */ 601);
	var Url = __webpack_require__(/*! url */ 534);
	var Utils = __webpack_require__(/*! ./utils */ 628);
	
	
	// Declare internals
	
	var internals = {};
	
	
	// MAC normalization format version
	
	exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats
	
	
	// Supported HMAC algorithms
	
	exports.algorithms = ['sha1', 'sha256'];
	
	
	// Calculate the request MAC
	
	/*
	    type: 'header',                                 // 'header', 'bewit', 'response'
	    credentials: {
	        key: 'aoijedoaijsdlaksjdl',
	        algorithm: 'sha256'                         // 'sha1', 'sha256'
	    },
	    options: {
	        method: 'GET',
	        resource: '/resource?a=1&b=2',
	        host: 'example.com',
	        port: 8080,
	        ts: 1357718381034,
	        nonce: 'd3d345f',
	        hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
	        ext: 'app-specific-data',
	        app: 'hf48hd83qwkj',                        // Application id (Oz)
	        dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
	    }
	*/
	
	exports.calculateMac = function (type, credentials, options) {
	
	    var normalized = exports.generateNormalizedString(type, options);
	
	    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
	    var digest = hmac.digest('base64');
	    return digest;
	};
	
	
	exports.generateNormalizedString = function (type, options) {
	
	    var resource = options.resource || '';
	    if (resource &&
	        resource[0] !== '/') {
	
	        var url = Url.parse(resource, false);
	        resource = url.path;                        // Includes query
	    }
	
	    var normalized = 'hawk.' + exports.headerVersion + '.' + type + '\n' +
	                     options.ts + '\n' +
	                     options.nonce + '\n' +
	                     (options.method || '').toUpperCase() + '\n' +
	                     resource + '\n' +
	                     options.host.toLowerCase() + '\n' +
	                     options.port + '\n' +
	                     (options.hash || '') + '\n';
	
	    if (options.ext) {
	        normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
	    }
	
	    normalized += '\n';
	
	    if (options.app) {
	        normalized += options.app + '\n' +
	                      (options.dlg || '') + '\n';
	    }
	
	    return normalized;
	};
	
	
	exports.calculatePayloadHash = function (payload, algorithm, contentType) {
	
	    var hash = exports.initializePayloadHash(algorithm, contentType);
	    hash.update(payload || '');
	    return exports.finalizePayloadHash(hash);
	};
	
	
	exports.initializePayloadHash = function (algorithm, contentType) {
	
	    var hash = Crypto.createHash(algorithm);
	    hash.update('hawk.' + exports.headerVersion + '.payload\n');
	    hash.update(Utils.parseContentType(contentType) + '\n');
	    return hash;
	};
	
	
	exports.finalizePayloadHash = function (hash) {
	
	    hash.update('\n');
	    return hash.digest('base64');
	};
	
	
	exports.calculateTsMac = function (ts, credentials) {
	
	    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key);
	    hmac.update('hawk.' + exports.headerVersion + '.ts\n' + ts + '\n');
	    return hmac.digest('base64');
	};
	
	
	exports.timestampMessage = function (credentials, localtimeOffsetMsec) {
	
	    var now = Utils.nowSecs(localtimeOffsetMsec);
	    var tsm = exports.calculateTsMac(now, credentials);
	    return { ts: now, tsm: tsm };
	};


/***/ },
/* 628 */
/*!*****************************!*\
  !*** ./~/hawk/lib/utils.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Sntp = __webpack_require__(/*! sntp */ 621);
	var Boom = __webpack_require__(/*! boom */ 618);
	
	
	// Declare internals
	
	var internals = {};
	
	
	exports.version = function () {
	
	    return __webpack_require__(/*! ../package.json */ 629).version;
	};
	
	
	exports.limits = {
	    maxMatchLength: 4096            // Limit the length of uris and headers to avoid a DoS attack on string matching
	};
	
	
	// Extract host and port from request
	
	//                                            $1                            $2
	internals.hostHeaderRegex = /^(?:(?:\r\n)?\s)*((?:[^:]+)|(?:\[[^\]]+\]))(?::(\d+))?(?:(?:\r\n)?\s)*$/;              // (IPv4, hostname)|(IPv6)
	
	
	exports.parseHost = function (req, hostHeaderName) {
	
	    hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
	    var hostHeader = req.headers[hostHeaderName];
	    if (!hostHeader) {
	        return null;
	    }
	
	    if (hostHeader.length > exports.limits.maxMatchLength) {
	        return null;
	    }
	
	    var hostParts = hostHeader.match(internals.hostHeaderRegex);
	    if (!hostParts) {
	        return null;
	    }
	
	    return {
	        name: hostParts[1],
	        port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
	    };
	};
	
	
	// Parse Content-Type header content
	
	exports.parseContentType = function (header) {
	
	    if (!header) {
	        return '';
	    }
	
	    return header.split(';')[0].trim().toLowerCase();
	};
	
	
	// Convert node's  to request configuration object
	
	exports.parseRequest = function (req, options) {
	
	    if (!req.headers) {
	        return req;
	    }
	
	    // Obtain host and port information
	
	    var host;
	    if (!options.host ||
	        !options.port) {
	
	        host = exports.parseHost(req, options.hostHeaderName);
	        if (!host) {
	            return new Error('Invalid Host header');
	        }
	    }
	
	    var request = {
	        method: req.method,
	        url: req.url,
	        host: options.host || host.name,
	        port: options.port || host.port,
	        authorization: req.headers.authorization,
	        contentType: req.headers['content-type'] || ''
	    };
	
	    return request;
	};
	
	
	exports.now = function (localtimeOffsetMsec) {
	
	    return Sntp.now() + (localtimeOffsetMsec || 0);
	};
	
	
	exports.nowSecs = function (localtimeOffsetMsec) {
	
	    return Math.floor(exports.now(localtimeOffsetMsec) / 1000);
	};
	
	
	internals.authHeaderRegex = /^(\w+)(?:\s+(.*))?$/;                                      // Header: scheme[ something]
	internals.attributeRegex = /^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/;   // !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9
	
	
	// Parse Hawk HTTP Authorization header
	
	exports.parseAuthorizationHeader = function (header, keys) {
	
	    keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];
	
	    if (!header) {
	        return Boom.unauthorized(null, 'Hawk');
	    }
	
	    if (header.length > exports.limits.maxMatchLength) {
	        return Boom.badRequest('Header length too long');
	    }
	
	    var headerParts = header.match(internals.authHeaderRegex);
	    if (!headerParts) {
	        return Boom.badRequest('Invalid header syntax');
	    }
	
	    var scheme = headerParts[1];
	    if (scheme.toLowerCase() !== 'hawk') {
	        return Boom.unauthorized(null, 'Hawk');
	    }
	
	    var attributesString = headerParts[2];
	    if (!attributesString) {
	        return Boom.badRequest('Invalid header syntax');
	    }
	
	    var attributes = {};
	    var errorMessage = '';
	    var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {
	
	        // Check valid attribute names
	
	        if (keys.indexOf($1) === -1) {
	            errorMessage = 'Unknown attribute: ' + $1;
	            return;
	        }
	
	        // Allowed attribute value characters
	
	        if ($2.match(internals.attributeRegex) === null) {
	            errorMessage = 'Bad attribute value: ' + $1;
	            return;
	        }
	
	        // Check for duplicates
	
	        if (attributes.hasOwnProperty($1)) {
	            errorMessage = 'Duplicate attribute: ' + $1;
	            return;
	        }
	
	        attributes[$1] = $2;
	        return '';
	    });
	
	    if (verify !== '') {
	        return Boom.badRequest(errorMessage || 'Bad header format');
	    }
	
	    return attributes;
	};
	
	
	exports.unauthorized = function (message, attributes) {
	
	    return Boom.unauthorized(message, 'Hawk', attributes);
	};
	


/***/ },
/* 629 */
/*!*****************************!*\
  !*** ./~/hawk/package.json ***!
  \*****************************/
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"name": "hawk",
					"raw": "hawk@~3.1.3",
					"rawSpec": "~3.1.3",
					"scope": null,
					"spec": ">=3.1.3 <3.2.0",
					"type": "range"
				},
				"/Users/John/Documents/Lavora/Sia-UI/Sia-UI/node_modules/request"
			]
		],
		"_from": "hawk@>=3.1.3 <3.2.0",
		"_id": "hawk@3.1.3",
		"_inCache": true,
		"_installable": true,
		"_location": "/hawk",
		"_nodeVersion": "5.4.1",
		"_npmUser": {
			"email": "eran@hammer.io",
			"name": "hueniverse"
		},
		"_npmVersion": "3.3.12",
		"_phantomChildren": {},
		"_requested": {
			"name": "hawk",
			"raw": "hawk@~3.1.3",
			"rawSpec": "~3.1.3",
			"scope": null,
			"spec": ">=3.1.3 <3.2.0",
			"type": "range"
		},
		"_requiredBy": [
			"/request"
		],
		"_resolved": "https://registry.npmjs.org/hawk/-/hawk-3.1.3.tgz",
		"_shasum": "078444bd7c1640b0fe540d2c9b73d59678e8e1c4",
		"_shrinkwrap": null,
		"_spec": "hawk@~3.1.3",
		"_where": "/Users/John/Documents/Lavora/Sia-UI/Sia-UI/node_modules/request",
		"author": {
			"email": "eran@hammer.io",
			"name": "Eran Hammer",
			"url": "http://hueniverse.com"
		},
		"browser": "./lib/browser.js",
		"bugs": {
			"url": "https://github.com/hueniverse/hawk/issues"
		},
		"contributors": [],
		"dependencies": {
			"boom": "2.x.x",
			"cryptiles": "2.x.x",
			"hoek": "2.x.x",
			"sntp": "1.x.x"
		},
		"description": "HTTP Hawk Authentication Scheme",
		"devDependencies": {
			"code": "1.x.x",
			"lab": "5.x.x"
		},
		"directories": {},
		"dist": {
			"shasum": "078444bd7c1640b0fe540d2c9b73d59678e8e1c4",
			"tarball": "https://registry.npmjs.org/hawk/-/hawk-3.1.3.tgz"
		},
		"engines": {
			"node": ">=0.10.32"
		},
		"gitHead": "2f0b93b34ed9b0ebc865838ef70c6a4035591430",
		"homepage": "https://github.com/hueniverse/hawk#readme",
		"keywords": [
			"http",
			"authentication",
			"scheme",
			"hawk"
		],
		"license": "BSD-3-Clause",
		"main": "lib/index.js",
		"maintainers": [
			{
				"email": "eran@hueniverse.com",
				"name": "hueniverse"
			}
		],
		"name": "hawk",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git://github.com/hueniverse/hawk.git"
		},
		"scripts": {
			"test": "lab -a code -t 100 -L",
			"test-cov-html": "lab -a code -r html -o coverage.html"
		},
		"version": "3.1.3"
	};

/***/ },
/* 630 */
/*!******************************!*\
  !*** ./~/hawk/lib/client.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// Load modules
	
	var Url = __webpack_require__(/*! url */ 534);
	var Hoek = __webpack_require__(/*! hoek */ 619);
	var Cryptiles = __webpack_require__(/*! cryptiles */ 626);
	var Crypto = __webpack_require__(/*! ./crypto */ 627);
	var Utils = __webpack_require__(/*! ./utils */ 628);
	
	
	// Declare internals
	
	var internals = {};
	
	
	// Generate an Authorization header for a given request
	
	/*
	    uri: 'http://example.com/resource?a=b' or object from Url.parse()
	    method: HTTP verb (e.g. 'GET', 'POST')
	    options: {
	
	        // Required
	
	        credentials: {
	            id: 'dh37fgj492je',
	            key: 'aoijedoaijsdlaksjdl',
	            algorithm: 'sha256'                                 // 'sha1', 'sha256'
	        },
	
	        // Optional
	
	        ext: 'application-specific',                        // Application specific data sent via the ext attribute
	        timestamp: Date.now(),                              // A pre-calculated timestamp
	        nonce: '2334f34f',                                  // A pre-generated nonce
	        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
	        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
	        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
	        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
	        app: '24s23423f34dx',                               // Oz application id
	        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
	    }
	*/
	
	exports.header = function (uri, method, options) {
	
	    var result = {
	        field: '',
	        artifacts: {}
	    };
	
	    // Validate inputs
	
	    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
	        !method || typeof method !== 'string' ||
	        !options || typeof options !== 'object') {
	
	        result.err = 'Invalid argument type';
	        return result;
	    }
	
	    // Application time
	
	    var timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);
	
	    // Validate credentials
	
	    var credentials = options.credentials;
	    if (!credentials ||
	        !credentials.id ||
	        !credentials.key ||
	        !credentials.algorithm) {
	
	        result.err = 'Invalid credential object';
	        return result;
	    }
	
	    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	        result.err = 'Unknown algorithm';
	        return result;
	    }
	
	    // Parse URI
	
	    if (typeof uri === 'string') {
	        uri = Url.parse(uri);
	    }
	
	    // Calculate signature
	
	    var artifacts = {
	        ts: timestamp,
	        nonce: options.nonce || Cryptiles.randomString(6),
	        method: method,
	        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
	        host: uri.hostname,
	        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
	        hash: options.hash,
	        ext: options.ext,
	        app: options.app,
	        dlg: options.dlg
	    };
	
	    result.artifacts = artifacts;
	
	    // Calculate payload hash
	
	    if (!artifacts.hash &&
	        (options.payload || options.payload === '')) {
	
	        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
	    }
	
	    var mac = Crypto.calculateMac('header', credentials, artifacts);
	
	    // Construct header
	
	    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
	    var header = 'Hawk id="' + credentials.id +
	                 '", ts="' + artifacts.ts +
	                 '", nonce="' + artifacts.nonce +
	                 (artifacts.hash ? '", hash="' + artifacts.hash : '') +
	                 (hasExt ? '", ext="' + Hoek.escapeHeaderAttribute(artifacts.ext) : '') +
	                 '", mac="' + mac + '"';
	
	    if (artifacts.app) {
	        header += ', app="' + artifacts.app +
	                  (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
	    }
	
	    result.field = header;
	
	    return result;
	};
	
	
	// Validate server response
	
	/*
	    res:        node's response object
	    artifacts:  object received from header().artifacts
	    options: {
	        payload:    optional payload received
	        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
	    }
	*/
	
	exports.authenticate = function (res, credentials, artifacts, options) {
	
	    artifacts = Hoek.clone(artifacts);
	    options = options || {};
	
	    if (res.headers['www-authenticate']) {
	
	        // Parse HTTP WWW-Authenticate header
	
	        var wwwAttributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
	        if (wwwAttributes instanceof Error) {
	            return false;
	        }
	
	        // Validate server timestamp (not used to update clock since it is done via the SNPT client)
	
	        if (wwwAttributes.ts) {
	            var tsm = Crypto.calculateTsMac(wwwAttributes.ts, credentials);
	            if (tsm !== wwwAttributes.tsm) {
	                return false;
	            }
	        }
	    }
	
	    // Parse HTTP Server-Authorization header
	
	    if (!res.headers['server-authorization'] &&
	        !options.required) {
	
	        return true;
	    }
	
	    var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
	    if (attributes instanceof Error) {
	        return false;
	    }
	
	    artifacts.ext = attributes.ext;
	    artifacts.hash = attributes.hash;
	
	    var mac = Crypto.calculateMac('response', credentials, artifacts);
	    if (mac !== attributes.mac) {
	        return false;
	    }
	
	    if (!options.payload &&
	        options.payload !== '') {
	
	        return true;
	    }
	
	    if (!attributes.hash) {
	        return false;
	    }
	
	    var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
	    return (calculatedHash === attributes.hash);
	};
	
	
	// Generate a bewit value for a given URI
	
	/*
	    uri: 'http://example.com/resource?a=b' or object from Url.parse()
	    options: {
	
	        // Required
	
	        credentials: {
	            id: 'dh37fgj492je',
	            key: 'aoijedoaijsdlaksjdl',
	            algorithm: 'sha256'                             // 'sha1', 'sha256'
	        },
	        ttlSec: 60 * 60,                                    // TTL in seconds
	
	        // Optional
	
	        ext: 'application-specific',                        // Application specific data sent via the ext attribute
	        localtimeOffsetMsec: 400                            // Time offset to sync with server time
	    };
	*/
	
	exports.getBewit = function (uri, options) {
	
	    // Validate inputs
	
	    if (!uri ||
	        (typeof uri !== 'string' && typeof uri !== 'object') ||
	        !options ||
	        typeof options !== 'object' ||
	        !options.ttlSec) {
	
	        return '';
	    }
	
	    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value
	
	    // Application time
	
	    var now = Utils.now(options.localtimeOffsetMsec);
	
	    // Validate credentials
	
	    var credentials = options.credentials;
	    if (!credentials ||
	        !credentials.id ||
	        !credentials.key ||
	        !credentials.algorithm) {
	
	        return '';
	    }
	
	    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	        return '';
	    }
	
	    // Parse URI
	
	    if (typeof uri === 'string') {
	        uri = Url.parse(uri);
	    }
	
	    // Calculate signature
	
	    var exp = Math.floor(now / 1000) + options.ttlSec;
	    var mac = Crypto.calculateMac('bewit', credentials, {
	        ts: exp,
	        nonce: '',
	        method: 'GET',
	        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
	        host: uri.hostname,
	        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
	        ext: options.ext
	    });
	
	    // Construct bewit: id\exp\mac\ext
	
	    var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
	    return Hoek.base64urlEncode(bewit);
	};
	
	
	// Generate an authorization string for a message
	
	/*
	    host: 'example.com',
	    port: 8000,
	    message: '{"some":"payload"}',                          // UTF-8 encoded string for body hash generation
	    options: {
	
	        // Required
	
	        credentials: {
	            id: 'dh37fgj492je',
	            key: 'aoijedoaijsdlaksjdl',
	            algorithm: 'sha256'                             // 'sha1', 'sha256'
	        },
	
	        // Optional
	
	        timestamp: Date.now(),                              // A pre-calculated timestamp
	        nonce: '2334f34f',                                  // A pre-generated nonce
	        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
	    }
	*/
	
	exports.message = function (host, port, message, options) {
	
	    // Validate inputs
	
	    if (!host || typeof host !== 'string' ||
	        !port || typeof port !== 'number' ||
	        message === null || message === undefined || typeof message !== 'string' ||
	        !options || typeof options !== 'object') {
	
	        return null;
	    }
	
	    // Application time
	
	    var timestamp = options.timestamp || Utils.nowSecs(options.localtimeOffsetMsec);
	
	    // Validate credentials
	
	    var credentials = options.credentials;
	    if (!credentials ||
	        !credentials.id ||
	        !credentials.key ||
	        !credentials.algorithm) {
	
	        // Invalid credential object
	        return null;
	    }
	
	    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	        return null;
	    }
	
	    // Calculate signature
	
	    var artifacts = {
	        ts: timestamp,
	        nonce: options.nonce || Cryptiles.randomString(6),
	        host: host,
	        port: port,
	        hash: Crypto.calculatePayloadHash(message, credentials.algorithm)
	    };
	
	    // Construct authorization
	
	    var result = {
	        id: credentials.id,
	        ts: artifacts.ts,
	        nonce: artifacts.nonce,
	        hash: artifacts.hash,
	        mac: Crypto.calculateMac('message', credentials, artifacts)
	    };
	
	    return result;
	};
	
	
	


/***/ },
/* 631 */
/*!******************************!*\
  !*** ./~/aws-sign2/index.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 *  Copyright 2010 LearnBoost <dev@learnboost.com>
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * Module dependencies.
	 */
	
	var crypto = __webpack_require__(/*! crypto */ 601)
	  , parse = __webpack_require__(/*! url */ 534).parse
	  ;
	
	/**
	 * Valid keys.
	 */
	
	var keys = 
	  [ 'acl'
	  , 'location'
	  , 'logging'
	  , 'notification'
	  , 'partNumber'
	  , 'policy'
	  , 'requestPayment'
	  , 'torrent'
	  , 'uploadId'
	  , 'uploads'
	  , 'versionId'
	  , 'versioning'
	  , 'versions'
	  , 'website'
	  ]
	
	/**
	 * Return an "Authorization" header value with the given `options`
	 * in the form of "AWS <key>:<signature>"
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */
	
	function authorization (options) {
	  return 'AWS ' + options.key + ':' + sign(options)
	}
	
	module.exports = authorization
	module.exports.authorization = authorization
	
	/**
	 * Simple HMAC-SHA1 Wrapper
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */ 
	
	function hmacSha1 (options) {
	  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
	}
	
	module.exports.hmacSha1 = hmacSha1
	
	/**
	 * Create a base64 sha1 HMAC for `options`. 
	 * 
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */
	
	function sign (options) {
	  options.message = stringToSign(options)
	  return hmacSha1(options)
	}
	module.exports.sign = sign
	
	/**
	 * Create a base64 sha1 HMAC for `options`. 
	 *
	 * Specifically to be used with S3 presigned URLs
	 * 
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */
	
	function signQuery (options) {
	  options.message = queryStringToSign(options)
	  return hmacSha1(options)
	}
	module.exports.signQuery= signQuery
	
	/**
	 * Return a string for sign() with the given `options`.
	 *
	 * Spec:
	 * 
	 *    <verb>\n
	 *    <md5>\n
	 *    <content-type>\n
	 *    <date>\n
	 *    [headers\n]
	 *    <resource>
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */
	
	function stringToSign (options) {
	  var headers = options.amazonHeaders || ''
	  if (headers) headers += '\n'
	  var r = 
	    [ options.verb
	    , options.md5
	    , options.contentType
	    , options.date ? options.date.toUTCString() : ''
	    , headers + options.resource
	    ]
	  return r.join('\n')
	}
	module.exports.queryStringToSign = stringToSign
	
	/**
	 * Return a string for sign() with the given `options`, but is meant exclusively
	 * for S3 presigned URLs
	 *
	 * Spec:
	 * 
	 *    <date>\n
	 *    <resource>
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */
	
	function queryStringToSign (options){
	  return 'GET\n\n\n' + options.date + '\n' + options.resource
	}
	module.exports.queryStringToSign = queryStringToSign
	
	/**
	 * Perform the following:
	 *
	 *  - ignore non-amazon headers
	 *  - lowercase fields
	 *  - sort lexicographically
	 *  - trim whitespace between ":"
	 *  - join with newline
	 *
	 * @param {Object} headers
	 * @return {String}
	 * @api private
	 */
	
	function canonicalizeHeaders (headers) {
	  var buf = []
	    , fields = Object.keys(headers)
	    ;
	  for (var i = 0, len = fields.length; i < len; ++i) {
	    var field = fields[i]
	      , val = headers[field]
	      , field = field.toLowerCase()
	      ;
	    if (0 !== field.indexOf('x-amz')) continue
	    buf.push(field + ':' + val)
	  }
	  return buf.sort().join('\n')
	}
	module.exports.canonicalizeHeaders = canonicalizeHeaders
	
	/**
	 * Perform the following:
	 *
	 *  - ignore non sub-resources
	 *  - sort lexicographically
	 *
	 * @param {String} resource
	 * @return {String}
	 * @api private
	 */
	
	function canonicalizeResource (resource) {
	  var url = parse(resource, true)
	    , path = url.pathname
	    , buf = []
	    ;
	
	  Object.keys(url.query).forEach(function(key){
	    if (!~keys.indexOf(key)) return
	    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
	    buf.push(key + val)
	  })
	
	  return path + (buf.length ? '?' + buf.sort().join('&') : '')
	}
	module.exports.canonicalizeResource = canonicalizeResource


/***/ },
/* 632 */
/*!***************************************!*\
  !*** ./~/http-signature/lib/index.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	var parser = __webpack_require__(/*! ./parser */ 633);
	var signer = __webpack_require__(/*! ./signer */ 672);
	var verify = __webpack_require__(/*! ./verify */ 677);
	var utils = __webpack_require__(/*! ./utils */ 636);
	
	
	
	///--- API
	
	module.exports = {
	
	  parse: parser.parseRequest,
	  parseRequest: parser.parseRequest,
	
	  sign: signer.signRequest,
	  signRequest: signer.signRequest,
	  createSigner: signer.createSigner,
	  isSigner: signer.isSigner,
	
	  sshKeyToPEM: utils.sshKeyToPEM,
	  sshKeyFingerprint: utils.fingerprint,
	  pemToRsaSSHKey: utils.pemToRsaSSHKey,
	
	  verify: verify.verifySignature,
	  verifySignature: verify.verifySignature,
	  verifyHMAC: verify.verifyHMAC
	};


/***/ },
/* 633 */
/*!****************************************!*\
  !*** ./~/http-signature/lib/parser.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Joyent, Inc.  All rights reserved.
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var util = __webpack_require__(/*! util */ 597);
	var utils = __webpack_require__(/*! ./utils */ 636);
	
	
	
	///--- Globals
	
	var HASH_ALGOS = utils.HASH_ALGOS;
	var PK_ALGOS = utils.PK_ALGOS;
	var HttpSignatureError = utils.HttpSignatureError;
	var InvalidAlgorithmError = utils.InvalidAlgorithmError;
	var validateAlgorithm = utils.validateAlgorithm;
	
	var State = {
	  New: 0,
	  Params: 1
	};
	
	var ParamsState = {
	  Name: 0,
	  Quote: 1,
	  Value: 2,
	  Comma: 3
	};
	
	
	///--- Specific Errors
	
	
	function ExpiredRequestError(message) {
	  HttpSignatureError.call(this, message, ExpiredRequestError);
	}
	util.inherits(ExpiredRequestError, HttpSignatureError);
	
	
	function InvalidHeaderError(message) {
	  HttpSignatureError.call(this, message, InvalidHeaderError);
	}
	util.inherits(InvalidHeaderError, HttpSignatureError);
	
	
	function InvalidParamsError(message) {
	  HttpSignatureError.call(this, message, InvalidParamsError);
	}
	util.inherits(InvalidParamsError, HttpSignatureError);
	
	
	function MissingHeaderError(message) {
	  HttpSignatureError.call(this, message, MissingHeaderError);
	}
	util.inherits(MissingHeaderError, HttpSignatureError);
	
	function StrictParsingError(message) {
	  HttpSignatureError.call(this, message, StrictParsingError);
	}
	util.inherits(StrictParsingError, HttpSignatureError);
	
	///--- Exported API
	
	module.exports = {
	
	  /**
	   * Parses the 'Authorization' header out of an http.ServerRequest object.
	   *
	   * Note that this API will fully validate the Authorization header, and throw
	   * on any error.  It will not however check the signature, or the keyId format
	   * as those are specific to your environment.  You can use the options object
	   * to pass in extra constraints.
	   *
	   * As a response object you can expect this:
	   *
	   *     {
	   *       "scheme": "Signature",
	   *       "params": {
	   *         "keyId": "foo",
	   *         "algorithm": "rsa-sha256",
	   *         "headers": [
	   *           "date" or "x-date",
	   *           "digest"
	   *         ],
	   *         "signature": "base64"
	   *       },
	   *       "signingString": "ready to be passed to crypto.verify()"
	   *     }
	   *
	   * @param {Object} request an http.ServerRequest.
	   * @param {Object} options an optional options object with:
	   *                   - clockSkew: allowed clock skew in seconds (default 300).
	   *                   - headers: required header names (def: date or x-date)
	   *                   - algorithms: algorithms to support (default: all).
	   *                   - strict: should enforce latest spec parsing
	   *                             (default: false).
	   * @return {Object} parsed out object (see above).
	   * @throws {TypeError} on invalid input.
	   * @throws {InvalidHeaderError} on an invalid Authorization header error.
	   * @throws {InvalidParamsError} if the params in the scheme are invalid.
	   * @throws {MissingHeaderError} if the params indicate a header not present,
	   *                              either in the request headers from the params,
	   *                              or not in the params from a required header
	   *                              in options.
	   * @throws {StrictParsingError} if old attributes are used in strict parsing
	   *                              mode.
	   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
	   */
	  parseRequest: function parseRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(request.headers, 'request.headers');
	    if (options === undefined) {
	      options = {};
	    }
	    if (options.headers === undefined) {
	      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
	    }
	    assert.object(options, 'options');
	    assert.arrayOfString(options.headers, 'options.headers');
	    assert.optionalNumber(options.clockSkew, 'options.clockSkew');
	
	    if (!request.headers.authorization)
	      throw new MissingHeaderError('no authorization header present in ' +
	                                   'the request');
	
	    options.clockSkew = options.clockSkew || 300;
	
	
	    var i = 0;
	    var state = State.New;
	    var substate = ParamsState.Name;
	    var tmpName = '';
	    var tmpValue = '';
	
	    var parsed = {
	      scheme: '',
	      params: {},
	      signingString: '',
	
	      get algorithm() {
	        return this.params.algorithm.toUpperCase();
	      },
	
	      get keyId() {
	        return this.params.keyId;
	      }
	    };
	
	    var authz = request.headers.authorization;
	    for (i = 0; i < authz.length; i++) {
	      var c = authz.charAt(i);
	
	      switch (Number(state)) {
	
	      case State.New:
	        if (c !== ' ') parsed.scheme += c;
	        else state = State.Params;
	        break;
	
	      case State.Params:
	        switch (Number(substate)) {
	
	        case ParamsState.Name:
	          var code = c.charCodeAt(0);
	          // restricted name of A-Z / a-z
	          if ((code >= 0x41 && code <= 0x5a) || // A-Z
	              (code >= 0x61 && code <= 0x7a)) { // a-z
	            tmpName += c;
	          } else if (c === '=') {
	            if (tmpName.length === 0)
	              throw new InvalidHeaderError('bad param format');
	            substate = ParamsState.Quote;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;
	
	        case ParamsState.Quote:
	          if (c === '"') {
	            tmpValue = '';
	            substate = ParamsState.Value;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;
	
	        case ParamsState.Value:
	          if (c === '"') {
	            parsed.params[tmpName] = tmpValue;
	            substate = ParamsState.Comma;
	          } else {
	            tmpValue += c;
	          }
	          break;
	
	        case ParamsState.Comma:
	          if (c === ',') {
	            tmpName = '';
	            substate = ParamsState.Name;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;
	
	        default:
	          throw new Error('Invalid substate');
	        }
	        break;
	
	      default:
	        throw new Error('Invalid substate');
	      }
	
	    }
	
	    if (!parsed.params.headers || parsed.params.headers === '') {
	      if (request.headers['x-date']) {
	        parsed.params.headers = ['x-date'];
	      } else {
	        parsed.params.headers = ['date'];
	      }
	    } else {
	      parsed.params.headers = parsed.params.headers.split(' ');
	    }
	
	    // Minimally validate the parsed object
	    if (!parsed.scheme || parsed.scheme !== 'Signature')
	      throw new InvalidHeaderError('scheme was not "Signature"');
	
	    if (!parsed.params.keyId)
	      throw new InvalidHeaderError('keyId was not specified');
	
	    if (!parsed.params.algorithm)
	      throw new InvalidHeaderError('algorithm was not specified');
	
	    if (!parsed.params.signature)
	      throw new InvalidHeaderError('signature was not specified');
	
	    // Check the algorithm against the official list
	    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
	    try {
	      validateAlgorithm(parsed.params.algorithm);
	    } catch (e) {
	      if (e instanceof InvalidAlgorithmError)
	        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +
	          'supported'));
	      else
	        throw (e);
	    }
	
	    // Build the signingString
	    for (i = 0; i < parsed.params.headers.length; i++) {
	      var h = parsed.params.headers[i].toLowerCase();
	      parsed.params.headers[i] = h;
	
	      if (h === 'request-line') {
	        if (!options.strict) {
	          /*
	           * We allow headers from the older spec drafts if strict parsing isn't
	           * specified in options.
	           */
	          parsed.signingString +=
	            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
	        } else {
	          /* Strict parsing doesn't allow older draft headers. */
	          throw (new StrictParsingError('request-line is not a valid header ' +
	            'with strict parsing enabled.'));
	        }
	      } else if (h === '(request-target)') {
	        parsed.signingString +=
	          '(request-target): ' + request.method.toLowerCase() + ' ' +
	          request.url;
	      } else {
	        var value = request.headers[h];
	        if (value === undefined)
	          throw new MissingHeaderError(h + ' was not in the request');
	        parsed.signingString += h + ': ' + value;
	      }
	
	      if ((i + 1) < parsed.params.headers.length)
	        parsed.signingString += '\n';
	    }
	
	    // Check against the constraints
	    var date;
	    if (request.headers.date || request.headers['x-date']) {
	        if (request.headers['x-date']) {
	          date = new Date(request.headers['x-date']);
	        } else {
	          date = new Date(request.headers.date);
	        }
	      var now = new Date();
	      var skew = Math.abs(now.getTime() - date.getTime());
	
	      if (skew > options.clockSkew * 1000) {
	        throw new ExpiredRequestError('clock skew of ' +
	                                      (skew / 1000) +
	                                      's was greater than ' +
	                                      options.clockSkew + 's');
	      }
	    }
	
	    options.headers.forEach(function (hdr) {
	      // Remember that we already checked any headers in the params
	      // were in the request, so if this passes we're good.
	      if (parsed.params.headers.indexOf(hdr) < 0)
	        throw new MissingHeaderError(hdr + ' was not a signed header');
	    });
	
	    if (options.algorithms) {
	      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
	        throw new InvalidParamsError(parsed.params.algorithm +
	                                     ' is not a supported algorithm');
	    }
	
	    return parsed;
	  }
	
	};


/***/ },
/* 634 */
/*!*********************************!*\
  !*** ./~/assert-plus/assert.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright (c) 2012, Mark Cavage. All rights reserved.
	// Copyright 2015 Joyent, Inc.
	
	var assert = __webpack_require__(/*! assert */ 635);
	var Stream = __webpack_require__(/*! stream */ 604).Stream;
	var util = __webpack_require__(/*! util */ 597);
	
	
	///--- Globals
	
	/* JSSTYLED */
	var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
	
	
	///--- Internal
	
	function _capitalize(str) {
	    return (str.charAt(0).toUpperCase() + str.slice(1));
	}
	
	function _toss(name, expected, oper, arg, actual) {
	    throw new assert.AssertionError({
	        message: util.format('%s (%s) is required', name, expected),
	        actual: (actual === undefined) ? typeof (arg) : actual(arg),
	        expected: expected,
	        operator: oper || '===',
	        stackStartFunction: _toss.caller
	    });
	}
	
	function _getClass(arg) {
	    return (Object.prototype.toString.call(arg).slice(8, -1));
	}
	
	function noop() {
	    // Why even bother with asserts?
	}
	
	
	///--- Exports
	
	var types = {
	    bool: {
	        check: function (arg) { return typeof (arg) === 'boolean'; }
	    },
	    func: {
	        check: function (arg) { return typeof (arg) === 'function'; }
	    },
	    string: {
	        check: function (arg) { return typeof (arg) === 'string'; }
	    },
	    object: {
	        check: function (arg) {
	            return typeof (arg) === 'object' && arg !== null;
	        }
	    },
	    number: {
	        check: function (arg) {
	            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
	        }
	    },
	    buffer: {
	        check: function (arg) { return Buffer.isBuffer(arg); },
	        operator: 'Buffer.isBuffer'
	    },
	    array: {
	        check: function (arg) { return Array.isArray(arg); },
	        operator: 'Array.isArray'
	    },
	    stream: {
	        check: function (arg) { return arg instanceof Stream; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    date: {
	        check: function (arg) { return arg instanceof Date; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    regexp: {
	        check: function (arg) { return arg instanceof RegExp; },
	        operator: 'instanceof',
	        actual: _getClass
	    },
	    uuid: {
	        check: function (arg) {
	            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
	        },
	        operator: 'isUUID'
	    }
	};
	
	function _setExports(ndebug) {
	    var keys = Object.keys(types);
	    var out;
	
	    /* re-export standard assert */
	    if (process.env.NODE_NDEBUG) {
	        out = noop;
	    } else {
	        out = function (arg, msg) {
	            if (!arg) {
	                _toss(msg, 'true', arg);
	            }
	        };
	    }
	
	    /* standard checks */
	    keys.forEach(function (k) {
	        if (ndebug) {
	            out[k] = noop;
	            return;
	        }
	        var type = types[k];
	        out[k] = function (arg, msg) {
	            if (!type.check(arg)) {
	                _toss(msg, k, type.operator, arg, type.actual);
	            }
	        };
	    });
	
	    /* optional checks */
	    keys.forEach(function (k) {
	        var name = 'optional' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        out[name] = function (arg, msg) {
	            if (arg === undefined || arg === null) {
	                return;
	            }
	            if (!type.check(arg)) {
	                _toss(msg, k, type.operator, arg, type.actual);
	            }
	        };
	    });
	
	    /* arrayOf checks */
	    keys.forEach(function (k) {
	        var name = 'arrayOf' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        var expected = '[' + k + ']';
	        out[name] = function (arg, msg) {
	            if (!Array.isArray(arg)) {
	                _toss(msg, expected, type.operator, arg, type.actual);
	            }
	            var i;
	            for (i = 0; i < arg.length; i++) {
	                if (!type.check(arg[i])) {
	                    _toss(msg, expected, type.operator, arg, type.actual);
	                }
	            }
	        };
	    });
	
	    /* optionalArrayOf checks */
	    keys.forEach(function (k) {
	        var name = 'optionalArrayOf' + _capitalize(k);
	        if (ndebug) {
	            out[name] = noop;
	            return;
	        }
	        var type = types[k];
	        var expected = '[' + k + ']';
	        out[name] = function (arg, msg) {
	            if (arg === undefined || arg === null) {
	                return;
	            }
	            if (!Array.isArray(arg)) {
	                _toss(msg, expected, type.operator, arg, type.actual);
	            }
	            var i;
	            for (i = 0; i < arg.length; i++) {
	                if (!type.check(arg[i])) {
	                    _toss(msg, expected, type.operator, arg, type.actual);
	                }
	            }
	        };
	    });
	
	    /* re-export built-in assertions */
	    Object.keys(assert).forEach(function (k) {
	        if (k === 'AssertionError') {
	            out[k] = assert[k];
	            return;
	        }
	        if (ndebug) {
	            out[k] = noop;
	            return;
	        }
	        out[k] = assert[k];
	    });
	
	    /* export ourselves (for unit tests _only_) */
	    out._setExports = _setExports;
	
	    return out;
	}
	
	module.exports = _setExports(process.env.NODE_NDEBUG);


/***/ },
/* 635 */
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 636 */
/*!***************************************!*\
  !*** ./~/http-signature/lib/utils.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Joyent, Inc.  All rights reserved.
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var sshpk = __webpack_require__(/*! sshpk */ 637);
	var util = __webpack_require__(/*! util */ 597);
	
	var HASH_ALGOS = {
	  'sha1': true,
	  'sha256': true,
	  'sha512': true
	};
	
	var PK_ALGOS = {
	  'rsa': true,
	  'dsa': true,
	  'ecdsa': true
	};
	
	function HttpSignatureError(message, caller) {
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, caller || HttpSignatureError);
	
	  this.message = message;
	  this.name = caller.name;
	}
	util.inherits(HttpSignatureError, Error);
	
	function InvalidAlgorithmError(message) {
	  HttpSignatureError.call(this, message, InvalidAlgorithmError);
	}
	util.inherits(InvalidAlgorithmError, HttpSignatureError);
	
	function validateAlgorithm(algorithm) {
	  var alg = algorithm.toLowerCase().split('-');
	
	  if (alg.length !== 2) {
	    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' is not a ' +
	      'valid algorithm'));
	  }
	
	  if (alg[0] !== 'hmac' && !PK_ALGOS[alg[0]]) {
	    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' type keys ' +
	      'are not supported'));
	  }
	
	  if (!HASH_ALGOS[alg[1]]) {
	    throw (new InvalidAlgorithmError(alg[1].toUpperCase() + ' is not a ' +
	      'supported hash algorithm'));
	  }
	
	  return (alg);
	}
	
	///--- API
	
	module.exports = {
	
	  HASH_ALGOS: HASH_ALGOS,
	  PK_ALGOS: PK_ALGOS,
	
	  HttpSignatureError: HttpSignatureError,
	  InvalidAlgorithmError: InvalidAlgorithmError,
	
	  validateAlgorithm: validateAlgorithm,
	
	  /**
	   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
	   *
	   * The intent of this module is to interoperate with OpenSSL only,
	   * specifically the node crypto module's `verify` method.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} PEM encoded form of the RSA public key.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} on invalid ssh key formatted data.
	   */
	  sshKeyToPEM: function sshKeyToPEM(key) {
	    assert.string(key, 'ssh_key');
	
	    var k = sshpk.parseKey(key, 'ssh');
	    return (k.toString('pem'));
	  },
	
	
	  /**
	   * Generates an OpenSSH fingerprint from an ssh public key.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} key fingerprint.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} if what you passed doesn't look like an ssh public key.
	   */
	  fingerprint: function fingerprint(key) {
	    assert.string(key, 'ssh_key');
	
	    var k = sshpk.parseKey(key, 'ssh');
	    return (k.fingerprint('md5').toString('hex'));
	  },
	
	  /**
	   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
	   *
	   * The reverse of the above function.
	   */
	  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
	    assert.equal('string', typeof (pem), 'typeof pem');
	
	    var k = sshpk.parseKey(pem, 'pem');
	    k.comment = comment;
	    return (k.toString('ssh'));
	  }
	};


/***/ },
/* 637 */
/*!******************************!*\
  !*** ./~/sshpk/lib/index.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	var Key = __webpack_require__(/*! ./key */ 638);
	var Fingerprint = __webpack_require__(/*! ./fingerprint */ 640);
	var Signature = __webpack_require__(/*! ./signature */ 644);
	var PrivateKey = __webpack_require__(/*! ./private-key */ 643);
	var errs = __webpack_require__(/*! ./errors */ 641);
	
	module.exports = {
		/* top-level classes */
		Key: Key,
		parseKey: Key.parse,
		Fingerprint: Fingerprint,
		parseFingerprint: Fingerprint.parse,
		Signature: Signature,
		parseSignature: Signature.parse,
		PrivateKey: PrivateKey,
		parsePrivateKey: PrivateKey.parse,
	
		/* errors */
		FingerprintFormatError: errs.FingerprintFormatError,
		InvalidAlgorithmError: errs.InvalidAlgorithmError,
		KeyParseError: errs.KeyParseError,
		SignatureParseError: errs.SignatureParseError,
		KeyEncryptedError: errs.KeyEncryptedError
	};


/***/ },
/* 638 */
/*!****************************!*\
  !*** ./~/sshpk/lib/key.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = Key;
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var algs = __webpack_require__(/*! ./algs */ 639);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var Fingerprint = __webpack_require__(/*! ./fingerprint */ 640);
	var Signature = __webpack_require__(/*! ./signature */ 644);
	var DiffieHellman = __webpack_require__(/*! ./dhe */ 668);
	var errs = __webpack_require__(/*! ./errors */ 641);
	var utils = __webpack_require__(/*! ./utils */ 642);
	var PrivateKey = __webpack_require__(/*! ./private-key */ 643);
	var edCompat;
	
	try {
		edCompat = __webpack_require__(/*! ./ed-compat */ 652);
	} catch (e) {
		/* Just continue through, and bail out if we try to use it. */
	}
	
	var InvalidAlgorithmError = errs.InvalidAlgorithmError;
	var KeyParseError = errs.KeyParseError;
	
	var formats = {};
	formats['auto'] = __webpack_require__(/*! ./formats/auto */ 654);
	formats['pem'] = __webpack_require__(/*! ./formats/pem */ 655);
	formats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ 656);
	formats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ 657);
	formats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ 659);
	formats['ssh'] = __webpack_require__(/*! ./formats/ssh */ 660);
	formats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ 658);
	formats['openssh'] = formats['ssh-private'];
	
	function Key(opts) {
		assert.object(opts, 'options');
		assert.arrayOfObject(opts.parts, 'options.parts');
		assert.string(opts.type, 'options.type');
		assert.optionalString(opts.comment, 'options.comment');
	
		var algInfo = algs.info[opts.type];
		if (typeof (algInfo) !== 'object')
			throw (new InvalidAlgorithmError(opts.type));
	
		var partLookup = {};
		for (var i = 0; i < opts.parts.length; ++i) {
			var part = opts.parts[i];
			partLookup[part.name] = part;
		}
	
		this.type = opts.type;
		this.parts = opts.parts;
		this.part = partLookup;
		this.comment = undefined;
		this.source = opts.source;
	
		/* for speeding up hashing/fingerprint operations */
		this._rfc4253Cache = opts._rfc4253Cache;
		this._hashCache = {};
	
		var sz;
		this.curve = undefined;
		if (this.type === 'ecdsa') {
			var curve = this.part.curve.data.toString();
			this.curve = curve;
			sz = algs.curves[curve].size;
		} else if (this.type === 'ed25519') {
			sz = 256;
			this.curve = 'curve25519';
		} else {
			var szPart = this.part[algInfo.sizePart];
			sz = szPart.data.length;
			sz = sz * 8 - utils.countZeros(szPart.data);
		}
		this.size = sz;
	}
	
	Key.formats = formats;
	
	Key.prototype.toBuffer = function (format, options) {
		if (format === undefined)
			format = 'ssh';
		assert.string(format, 'format');
		assert.object(formats[format], 'formats[format]');
		assert.optionalObject(options, 'options');
	
		if (format === 'rfc4253') {
			if (this._rfc4253Cache === undefined)
				this._rfc4253Cache = formats['rfc4253'].write(this);
			return (this._rfc4253Cache);
		}
	
		return (formats[format].write(this, options));
	};
	
	Key.prototype.toString = function (format, options) {
		return (this.toBuffer(format, options).toString());
	};
	
	Key.prototype.hash = function (algo) {
		assert.string(algo, 'algorithm');
		algo = algo.toLowerCase();
		if (algs.hashAlgs[algo] === undefined)
			throw (new InvalidAlgorithmError(algo));
	
		if (this._hashCache[algo])
			return (this._hashCache[algo]);
	
		var hash = crypto.createHash(algo).
		    update(this.toBuffer('rfc4253')).digest();
		this._hashCache[algo] = hash;
		return (hash);
	};
	
	Key.prototype.fingerprint = function (algo) {
		if (algo === undefined)
			algo = 'sha256';
		assert.string(algo, 'algorithm');
		var opts = {
			hash: this.hash(algo),
			algorithm: algo
		};
		return (new Fingerprint(opts));
	};
	
	Key.prototype.defaultHashAlgorithm = function () {
		var hashAlgo = 'sha1';
		if (this.type === 'rsa')
			hashAlgo = 'sha256';
		if (this.type === 'dsa' && this.size > 1024)
			hashAlgo = 'sha256';
		if (this.type === 'ed25519')
			hashAlgo = 'sha512';
		if (this.type === 'ecdsa') {
			if (this.size <= 256)
				hashAlgo = 'sha256';
			else if (this.size <= 384)
				hashAlgo = 'sha384';
			else
				hashAlgo = 'sha512';
		}
		return (hashAlgo);
	};
	
	Key.prototype.createVerify = function (hashAlgo) {
		if (hashAlgo === undefined)
			hashAlgo = this.defaultHashAlgorithm();
		assert.string(hashAlgo, 'hash algorithm');
	
		/* ED25519 is not supported by OpenSSL, use a javascript impl. */
		if (this.type === 'ed25519' && edCompat !== undefined)
			return (new edCompat.Verifier(this, hashAlgo));
		if (this.type === 'curve25519')
			throw (new Error('Curve25519 keys are not suitable for ' +
			    'signing or verification'));
	
		var v, nm, err;
		try {
			nm = hashAlgo.toUpperCase();
			v = crypto.createVerify(nm);
		} catch (e) {
			err = e;
		}
		if (v === undefined || (err instanceof Error &&
		    err.message.match(/Unknown message digest/))) {
			nm = 'RSA-';
			nm += hashAlgo.toUpperCase();
			v = crypto.createVerify(nm);
		}
		assert.ok(v, 'failed to create verifier');
		var oldVerify = v.verify.bind(v);
		var key = this.toBuffer('pkcs8');
		var self = this;
		v.verify = function (signature, fmt) {
			if (Signature.isSignature(signature, [2, 0])) {
				if (signature.type !== self.type)
					return (false);
				if (signature.hashAlgorithm &&
				    signature.hashAlgorithm !== hashAlgo)
					return (false);
				return (oldVerify(key, signature.toBuffer('asn1')));
	
			} else if (typeof (signature) === 'string' ||
			    Buffer.isBuffer(signature)) {
				return (oldVerify(key, signature, fmt));
	
			/*
			 * Avoid doing this on valid arguments, walking the prototype
			 * chain can be quite slow.
			 */
			} else if (Signature.isSignature(signature, [1, 0])) {
				throw (new Error('signature was created by too old ' +
				    'a version of sshpk and cannot be verified'));
	
			} else {
				throw (new TypeError('signature must be a string, ' +
				    'Buffer, or Signature object'));
			}
		};
		return (v);
	};
	
	Key.prototype.createDiffieHellman = function () {
		if (this.type === 'rsa')
			throw (new Error('RSA keys do not support Diffie-Hellman'));
	
		return (new DiffieHellman(this));
	};
	Key.prototype.createDH = Key.prototype.createDiffieHellman;
	
	Key.parse = function (data, format, options) {
		if (typeof (data) !== 'string')
			assert.buffer(data, 'data');
		if (format === undefined)
			format = 'auto';
		assert.string(format, 'format');
		if (typeof (options) === 'string')
			options = { filename: options };
		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		assert.optionalString(options.filename, 'options.filename');
		if (options.filename === undefined)
			options.filename = '(unnamed)';
	
		assert.object(formats[format], 'formats[format]');
	
		try {
			var k = formats[format].read(data, options);
			if (k instanceof PrivateKey)
				k = k.toPublic();
			if (!k.comment)
				k.comment = options.filename;
			return (k);
		} catch (e) {
			if (e.name === 'KeyEncryptedError')
				throw (e);
			throw (new KeyParseError(options.filename, format, e));
		}
	};
	
	Key.isKey = function (obj, ver) {
		return (utils.isCompatible(obj, Key, ver));
	};
	
	/*
	 * API versions for Key:
	 * [1,0] -- initial ver, may take Signature for createVerify or may not
	 * [1,1] -- added pkcs1, pkcs8 formats
	 * [1,2] -- added auto, ssh-private, openssh formats
	 * [1,3] -- added defaultHashAlgorithm
	 * [1,4] -- added ed support, createDH
	 * [1,5] -- first explicitly tagged version
	 */
	Key.prototype._sshpkApiVersion = [1, 5];
	
	Key._oldVersionDetect = function (obj) {
		assert.func(obj.toBuffer);
		assert.func(obj.fingerprint);
		if (obj.createDH)
			return ([1, 4]);
		if (obj.defaultHashAlgorithm)
			return ([1, 3]);
		if (obj.formats['auto'])
			return ([1, 2]);
		if (obj.formats['pkcs1'])
			return ([1, 1]);
		return ([1, 0]);
	};


/***/ },
/* 639 */
/*!*****************************!*\
  !*** ./~/sshpk/lib/algs.js ***!
  \*****************************/
/***/ function(module, exports) {

	// Copyright 2015 Joyent, Inc.
	
	var algInfo = {
		'dsa': {
			parts: ['p', 'q', 'g', 'y'],
			sizePart: 'p'
		},
		'rsa': {
			parts: ['e', 'n'],
			sizePart: 'n'
		},
		'ecdsa': {
			parts: ['curve', 'Q'],
			sizePart: 'Q'
		},
		'ed25519': {
			parts: ['R'],
			normalize: false,
			sizePart: 'R'
		}
	};
	algInfo['curve25519'] = algInfo['ed25519'];
	
	var algPrivInfo = {
		'dsa': {
			parts: ['p', 'q', 'g', 'y', 'x']
		},
		'rsa': {
			parts: ['n', 'e', 'd', 'iqmp', 'p', 'q']
		},
		'ecdsa': {
			parts: ['curve', 'Q', 'd']
		},
		'ed25519': {
			parts: ['R', 'r'],
			normalize: false
		}
	};
	algPrivInfo['curve25519'] = algPrivInfo['ed25519'];
	
	var hashAlgs = {
		'md5': true,
		'sha1': true,
		'sha256': true,
		'sha384': true,
		'sha512': true
	};
	
	/*
	 * Taken from
	 * http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf
	 */
	var curves = {
		'nistp256': {
			size: 256,
			pkcs8oid: '1.2.840.10045.3.1.7',
			p: new Buffer(('00' +
			    'ffffffff 00000001 00000000 00000000' +
			    '00000000 ffffffff ffffffff ffffffff').
			    replace(/ /g, ''), 'hex'),
			a: new Buffer(('00' +
			    'FFFFFFFF 00000001 00000000 00000000' +
			    '00000000 FFFFFFFF FFFFFFFF FFFFFFFC').
			    replace(/ /g, ''), 'hex'),
			b: new Buffer((
			    '5ac635d8 aa3a93e7 b3ebbd55 769886bc' +
			    '651d06b0 cc53b0f6 3bce3c3e 27d2604b').
			    replace(/ /g, ''), 'hex'),
			s: new Buffer(('00' +
			    'c49d3608 86e70493 6a6678e1 139d26b7' +
			    '819f7e90').
			    replace(/ /g, ''), 'hex'),
			n: new Buffer(('00' +
			    'ffffffff 00000000 ffffffff ffffffff' +
			    'bce6faad a7179e84 f3b9cac2 fc632551').
			    replace(/ /g, ''), 'hex'),
			G: new Buffer(('04' +
			    '6b17d1f2 e12c4247 f8bce6e5 63a440f2' +
			    '77037d81 2deb33a0 f4a13945 d898c296' +
			    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16' +
			    '2bce3357 6b315ece cbb64068 37bf51f5').
			    replace(/ /g, ''), 'hex')
		},
		'nistp384': {
			size: 384,
			pkcs8oid: '1.3.132.0.34',
			p: new Buffer(('00' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff fffffffe' +
			    'ffffffff 00000000 00000000 ffffffff').
			    replace(/ /g, ''), 'hex'),
			a: new Buffer(('00' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE' +
			    'FFFFFFFF 00000000 00000000 FFFFFFFC').
			    replace(/ /g, ''), 'hex'),
			b: new Buffer((
			    'b3312fa7 e23ee7e4 988e056b e3f82d19' +
			    '181d9c6e fe814112 0314088f 5013875a' +
			    'c656398d 8a2ed19d 2a85c8ed d3ec2aef').
			    replace(/ /g, ''), 'hex'),
			s: new Buffer(('00' +
			    'a335926a a319a27a 1d00896a 6773a482' +
			    '7acdac73').
			    replace(/ /g, ''), 'hex'),
			n: new Buffer(('00' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff c7634d81 f4372ddf' +
			    '581a0db2 48b0a77a ecec196a ccc52973').
			    replace(/ /g, ''), 'hex'),
			G: new Buffer(('04' +
			    'aa87ca22 be8b0537 8eb1c71e f320ad74' +
			    '6e1d3b62 8ba79b98 59f741e0 82542a38' +
			    '5502f25d bf55296c 3a545e38 72760ab7' +
			    '3617de4a 96262c6f 5d9e98bf 9292dc29' +
			    'f8f41dbd 289a147c e9da3113 b5f0b8c0' +
			    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f').
			    replace(/ /g, ''), 'hex')
		},
		'nistp521': {
			size: 521,
			pkcs8oid: '1.3.132.0.35',
			p: new Buffer((
			    '01ffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffff').replace(/ /g, ''), 'hex'),
			a: new Buffer(('01FF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
			    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC').
			    replace(/ /g, ''), 'hex'),
			b: new Buffer(('51' +
			    '953eb961 8e1c9a1f 929a21a0 b68540ee' +
			    'a2da725b 99b315f3 b8b48991 8ef109e1' +
			    '56193951 ec7e937b 1652c0bd 3bb1bf07' +
			    '3573df88 3d2c34f1 ef451fd4 6b503f00').
			    replace(/ /g, ''), 'hex'),
			s: new Buffer(('00' +
			    'd09e8800 291cb853 96cc6717 393284aa' +
			    'a0da64ba').replace(/ /g, ''), 'hex'),
			n: new Buffer(('01ff' +
			    'ffffffff ffffffff ffffffff ffffffff' +
			    'ffffffff ffffffff ffffffff fffffffa' +
			    '51868783 bf2f966b 7fcc0148 f709a5d0' +
			    '3bb5c9b8 899c47ae bb6fb71e 91386409').
			    replace(/ /g, ''), 'hex'),
			G: new Buffer(('04' +
			    '00c6 858e06b7 0404e9cd 9e3ecb66 2395b442' +
			         '9c648139 053fb521 f828af60 6b4d3dba' +
			         'a14b5e77 efe75928 fe1dc127 a2ffa8de' +
			         '3348b3c1 856a429b f97e7e31 c2e5bd66' +
			    '0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9' +
			         '98f54449 579b4468 17afbd17 273e662c' +
			         '97ee7299 5ef42640 c550b901 3fad0761' +
			         '353c7086 a272c240 88be9476 9fd16650').
			    replace(/ /g, ''), 'hex')
		}
	};
	
	module.exports = {
		info: algInfo,
		privInfo: algPrivInfo,
		hashAlgs: hashAlgs,
		curves: curves
	};


/***/ },
/* 640 */
/*!************************************!*\
  !*** ./~/sshpk/lib/fingerprint.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = Fingerprint;
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var algs = __webpack_require__(/*! ./algs */ 639);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var errs = __webpack_require__(/*! ./errors */ 641);
	var Key = __webpack_require__(/*! ./key */ 638);
	var utils = __webpack_require__(/*! ./utils */ 642);
	
	var FingerprintFormatError = errs.FingerprintFormatError;
	var InvalidAlgorithmError = errs.InvalidAlgorithmError;
	
	function Fingerprint(opts) {
		assert.object(opts, 'options');
		assert.buffer(opts.hash, 'options.hash');
		assert.string(opts.algorithm, 'options.algorithm');
	
		this.algorithm = opts.algorithm.toLowerCase();
		if (algs.hashAlgs[this.algorithm] !== true)
			throw (new InvalidAlgorithmError(this.algorithm));
	
		this.hash = opts.hash;
	}
	
	Fingerprint.prototype.toString = function (format) {
		if (format === undefined) {
			if (this.algorithm === 'md5')
				format = 'hex';
			else
				format = 'base64';
		}
		assert.string(format);
	
		switch (format) {
		case 'hex':
			return (addColons(this.hash.toString('hex')));
		case 'base64':
			return (sshBase64Format(this.algorithm,
			    this.hash.toString('base64')));
		default:
			throw (new FingerprintFormatError(undefined, format));
		}
	};
	
	Fingerprint.prototype.matches = function (key) {
		assert.object(key, 'key');
		utils.assertCompatible(key, Key, [1, 0], 'key');
	
		var theirHash = key.hash(this.algorithm);
		var theirHash2 = crypto.createHash(this.algorithm).
		    update(theirHash).digest('base64');
	
		if (this.hash2 === undefined)
			this.hash2 = crypto.createHash(this.algorithm).
			    update(this.hash).digest('base64');
	
		return (this.hash2 === theirHash2);
	};
	
	Fingerprint.parse = function (fp, enAlgs) {
		assert.string(fp, 'fingerprint');
	
		var alg, hash;
		assert.optionalArrayOfString(enAlgs, 'algorithms');
	
		var parts = fp.split(':');
		if (parts.length == 2) {
			alg = parts[0].toLowerCase();
			/*JSSTYLED*/
			var base64RE = /^[A-Za-z0-9+\/=]+$/;
			if (!base64RE.test(parts[1]))
				throw (new FingerprintFormatError(fp));
			try {
				hash = new Buffer(parts[1], 'base64');
			} catch (e) {
				throw (new FingerprintFormatError(fp));
			}
		} else if (parts.length > 2) {
			alg = 'md5';
			if (parts[0].toLowerCase() === 'md5')
				parts = parts.slice(1);
			parts = parts.join('');
			/*JSSTYLED*/
			var md5RE = /^[a-fA-F0-9]+$/;
			if (!md5RE.test(parts))
				throw (new FingerprintFormatError(fp));
			try {
				hash = new Buffer(parts, 'hex');
			} catch (e) {
				throw (new FingerprintFormatError(fp));
			}
		}
	
		if (alg === undefined)
			throw (new FingerprintFormatError(fp));
	
		if (algs.hashAlgs[alg] === undefined)
			throw (new InvalidAlgorithmError(alg));
	
		if (enAlgs !== undefined) {
			enAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });
			if (enAlgs.indexOf(alg) === -1)
				throw (new InvalidAlgorithmError(alg));
		}
	
		return (new Fingerprint({algorithm: alg, hash: hash}));
	};
	
	function addColons(s) {
		/*JSSTYLED*/
		return (s.replace(/(.{2})(?=.)/g, '$1:'));
	}
	
	function base64Strip(s) {
		/*JSSTYLED*/
		return (s.replace(/=*$/, ''));
	}
	
	function sshBase64Format(alg, h) {
		return (alg.toUpperCase() + ':' + base64Strip(h));
	}
	
	Fingerprint.isFingerprint = function (obj, ver) {
		return (utils.isCompatible(obj, Fingerprint, ver));
	};
	
	/*
	 * API versions for Fingerprint:
	 * [1,0] -- initial ver
	 * [1,1] -- first tagged ver
	 */
	Fingerprint.prototype._sshpkApiVersion = [1, 1];
	
	Fingerprint._oldVersionDetect = function (obj) {
		assert.func(obj.toString);
		assert.func(obj.matches);
		return ([1, 0]);
	};


/***/ },
/* 641 */
/*!*******************************!*\
  !*** ./~/sshpk/lib/errors.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var util = __webpack_require__(/*! util */ 597);
	
	function FingerprintFormatError(fp, format) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, FingerprintFormatError);
		this.name = 'FingerprintFormatError';
		this.fingerprint = fp;
		this.format = format;
		this.message = 'Fingerprint format is not supported, or is invalid: ';
		if (fp !== undefined)
			this.message += ' fingerprint = ' + fp;
		if (format !== undefined)
			this.message += ' format = ' + format;
	}
	util.inherits(FingerprintFormatError, Error);
	
	function InvalidAlgorithmError(alg) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, InvalidAlgorithmError);
		this.name = 'InvalidAlgorithmError';
		this.algorithm = alg;
		this.message = 'Algorithm "' + alg + '" is not supported';
	}
	util.inherits(InvalidAlgorithmError, Error);
	
	function KeyParseError(name, format, innerErr) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, KeyParseError);
		this.name = 'KeyParseError';
		this.format = format;
		this.keyName = name;
		this.innerErr = innerErr;
		this.message = 'Failed to parse ' + name + ' as a valid ' + format +
		    ' format key: ' + innerErr.message;
	}
	util.inherits(KeyParseError, Error);
	
	function SignatureParseError(type, format, innerErr) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, SignatureParseError);
		this.name = 'SignatureParseError';
		this.type = type;
		this.format = format;
		this.innerErr = innerErr;
		this.message = 'Failed to parse the given data as a ' + type +
		    ' signature in ' + format + ' format: ' + innerErr.message;
	}
	util.inherits(SignatureParseError, Error);
	
	function KeyEncryptedError(name, format) {
		if (Error.captureStackTrace)
			Error.captureStackTrace(this, KeyEncryptedError);
		this.name = 'KeyEncryptedError';
		this.format = format;
		this.keyName = name;
		this.message = 'The ' + format + ' format key ' + name + ' is ' +
		    'encrypted (password-protected), and no passphrase was ' +
		    'provided in `options`';
	}
	util.inherits(KeyEncryptedError, Error);
	
	module.exports = {
		FingerprintFormatError: FingerprintFormatError,
		InvalidAlgorithmError: InvalidAlgorithmError,
		KeyParseError: KeyParseError,
		SignatureParseError: SignatureParseError,
		KeyEncryptedError: KeyEncryptedError
	};


/***/ },
/* 642 */
/*!******************************!*\
  !*** ./~/sshpk/lib/utils.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		bufferSplit: bufferSplit,
		addRSAMissing: addRSAMissing,
		calculateDSAPublic: calculateDSAPublic,
		mpNormalize: mpNormalize,
		ecNormalize: ecNormalize,
		countZeros: countZeros,
		assertCompatible: assertCompatible,
		isCompatible: isCompatible,
		opensslKeyDeriv: opensslKeyDeriv
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var PrivateKey = __webpack_require__(/*! ./private-key */ 643);
	var crypto = __webpack_require__(/*! crypto */ 601);
	
	var MAX_CLASS_DEPTH = 3;
	
	function isCompatible(obj, klass, needVer) {
		if (obj === null || typeof (obj) !== 'object')
			return (false);
		if (needVer === undefined)
			needVer = klass.prototype._sshpkApiVersion;
		if (obj instanceof klass &&
		    klass.prototype._sshpkApiVersion[0] == needVer[0])
			return (true);
		var proto = Object.getPrototypeOf(obj);
		var depth = 0;
		while (proto.constructor.name !== klass.name) {
			proto = Object.getPrototypeOf(proto);
			if (!proto || ++depth > MAX_CLASS_DEPTH)
				return (false);
		}
		if (proto.constructor.name !== klass.name)
			return (false);
		var ver = proto._sshpkApiVersion;
		if (ver === undefined)
			ver = klass._oldVersionDetect(obj);
		if (ver[0] != needVer[0] || ver[1] < needVer[1])
			return (false);
		return (true);
	}
	
	function assertCompatible(obj, klass, needVer, name) {
		if (name === undefined)
			name = 'object';
		assert.ok(obj, name + ' must not be null');
		assert.object(obj, name + ' must be an object');
		if (needVer === undefined)
			needVer = klass.prototype._sshpkApiVersion;
		if (obj instanceof klass &&
		    klass.prototype._sshpkApiVersion[0] == needVer[0])
			return;
		var proto = Object.getPrototypeOf(obj);
		var depth = 0;
		while (proto.constructor.name !== klass.name) {
			proto = Object.getPrototypeOf(proto);
			assert.ok(proto && ++depth <= MAX_CLASS_DEPTH,
			    name + ' must be a ' + klass.name + ' instance');
		}
		assert.strictEqual(proto.constructor.name, klass.name,
		    name + ' must be a ' + klass.name + ' instance');
		var ver = proto._sshpkApiVersion;
		if (ver === undefined)
			ver = klass._oldVersionDetect(obj);
		assert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],
		    name + ' must be compatible with ' + klass.name + ' klass ' +
		    'version ' + needVer[0] + '.' + needVer[1]);
	}
	
	var CIPHER_LEN = {
		'des-ede3-cbc': { key: 7, iv: 8 },
		'aes-128-cbc': { key: 16, iv: 16 }
	};
	var PKCS5_SALT_LEN = 8;
	
	function opensslKeyDeriv(cipher, salt, passphrase, count) {
		assert.buffer(salt, 'salt');
		assert.buffer(passphrase, 'passphrase');
		assert.number(count, 'iteration count');
	
		var clen = CIPHER_LEN[cipher];
		assert.object(clen, 'supported cipher');
	
		salt = salt.slice(0, PKCS5_SALT_LEN);
	
		var D, D_prev, bufs;
		var material = new Buffer(0);
		while (material.length < clen.key + clen.iv) {
			bufs = [];
			if (D_prev)
				bufs.push(D_prev);
			bufs.push(passphrase);
			bufs.push(salt);
			D = Buffer.concat(bufs);
			for (var j = 0; j < count; ++j)
				D = crypto.createHash('md5').update(D).digest();
			material = Buffer.concat([material, D]);
			D_prev = D;
		}
	
		return ({
		    key: material.slice(0, clen.key),
		    iv: material.slice(clen.key, clen.key + clen.iv)
		});
	}
	
	/* Count leading zero bits on a buffer */
	function countZeros(buf) {
		var o = 0, obit = 8;
		while (o < buf.length) {
			var mask = (1 << obit);
			if ((buf[o] & mask) === mask)
				break;
			obit--;
			if (obit < 0) {
				o++;
				obit = 8;
			}
		}
		return (o*8 + (8 - obit) - 1);
	}
	
	function bufferSplit(buf, chr) {
		assert.buffer(buf);
		assert.string(chr);
	
		var parts = [];
		var lastPart = 0;
		var matches = 0;
		for (var i = 0; i < buf.length; ++i) {
			if (buf[i] === chr.charCodeAt(matches))
				++matches;
			else if (buf[i] === chr.charCodeAt(0))
				matches = 1;
			else
				matches = 0;
	
			if (matches >= chr.length) {
				var newPart = i + 1;
				parts.push(buf.slice(lastPart, newPart - matches));
				lastPart = newPart;
				matches = 0;
			}
		}
		if (lastPart <= buf.length)
			parts.push(buf.slice(lastPart, buf.length));
	
		return (parts);
	}
	
	function ecNormalize(buf, addZero) {
		assert.buffer(buf);
		if (buf[0] === 0x00 && buf[1] === 0x04) {
			if (addZero)
				return (buf);
			return (buf.slice(1));
		} else if (buf[0] === 0x04) {
			if (!addZero)
				return (buf);
		} else {
			while (buf[0] === 0x00)
				buf = buf.slice(1);
			if (buf[0] === 0x02 || buf[0] === 0x03)
				throw (new Error('Compressed elliptic curve points ' +
				    'are not supported'));
			if (buf[0] !== 0x04)
				throw (new Error('Not a valid elliptic curve point'));
			if (!addZero)
				return (buf);
		}
		var b = new Buffer(buf.length + 1);
		b[0] = 0x0;
		buf.copy(b, 1);
		return (b);
	}
	
	function mpNormalize(buf) {
		assert.buffer(buf);
		while (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)
			buf = buf.slice(1);
		if ((buf[0] & 0x80) === 0x80) {
			var b = new Buffer(buf.length + 1);
			b[0] = 0x00;
			buf.copy(b, 1);
			buf = b;
		}
		return (buf);
	}
	
	function bigintToMpBuf(bigint) {
		var buf = new Buffer(bigint.toByteArray());
		buf = mpNormalize(buf);
		return (buf);
	}
	
	function calculateDSAPublic(g, p, x) {
		assert.buffer(g);
		assert.buffer(p);
		assert.buffer(x);
		try {
			var bigInt = __webpack_require__(/*! jsbn */ 667).BigInteger;
		} catch (e) {
			throw (new Error('To load a PKCS#8 format DSA private key, ' +
			    'the node jsbn library is required.'));
		}
		g = new bigInt(g);
		p = new bigInt(p);
		x = new bigInt(x);
		var y = g.modPow(x, p);
		var ybuf = bigintToMpBuf(y);
		return (ybuf);
	}
	
	function addRSAMissing(key) {
		assert.object(key);
		assertCompatible(key, PrivateKey, [1, 1]);
		try {
			var bigInt = __webpack_require__(/*! jsbn */ 667).BigInteger;
		} catch (e) {
			throw (new Error('To write a PEM private key from ' +
			    'this source, the node jsbn lib is required.'));
		}
	
		var d = new bigInt(key.part.d.data);
		var buf;
	
		if (!key.part.dmodp) {
			var p = new bigInt(key.part.p.data);
			var dmodp = d.mod(p.subtract(1));
	
			buf = bigintToMpBuf(dmodp);
			key.part.dmodp = {name: 'dmodp', data: buf};
			key.parts.push(key.part.dmodp);
		}
		if (!key.part.dmodq) {
			var q = new bigInt(key.part.q.data);
			var dmodq = d.mod(q.subtract(1));
	
			buf = bigintToMpBuf(dmodq);
			key.part.dmodq = {name: 'dmodq', data: buf};
			key.parts.push(key.part.dmodq);
		}
	}


/***/ },
/* 643 */
/*!************************************!*\
  !*** ./~/sshpk/lib/private-key.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = PrivateKey;
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var algs = __webpack_require__(/*! ./algs */ 639);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var Fingerprint = __webpack_require__(/*! ./fingerprint */ 640);
	var Signature = __webpack_require__(/*! ./signature */ 644);
	var errs = __webpack_require__(/*! ./errors */ 641);
	var util = __webpack_require__(/*! util */ 597);
	var utils = __webpack_require__(/*! ./utils */ 642);
	var edCompat;
	var ed;
	
	try {
		edCompat = __webpack_require__(/*! ./ed-compat */ 652);
	} catch (e) {
		/* Just continue through, and bail out if we try to use it. */
	}
	
	var Key = __webpack_require__(/*! ./key */ 638);
	
	var InvalidAlgorithmError = errs.InvalidAlgorithmError;
	var KeyParseError = errs.KeyParseError;
	var KeyEncryptedError = errs.KeyEncryptedError;
	
	var formats = {};
	formats['auto'] = __webpack_require__(/*! ./formats/auto */ 654);
	formats['pem'] = __webpack_require__(/*! ./formats/pem */ 655);
	formats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ 656);
	formats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ 657);
	formats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ 659);
	formats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ 658);
	formats['openssh'] = formats['ssh-private'];
	formats['ssh'] = formats['ssh-private'];
	
	function PrivateKey(opts) {
		assert.object(opts, 'options');
		Key.call(this, opts);
	
		this._pubCache = undefined;
	}
	util.inherits(PrivateKey, Key);
	
	PrivateKey.formats = formats;
	
	PrivateKey.prototype.toBuffer = function (format, options) {
		if (format === undefined)
			format = 'pkcs1';
		assert.string(format, 'format');
		assert.object(formats[format], 'formats[format]');
		assert.optionalObject(options, 'options');
	
		return (formats[format].write(this, options));
	};
	
	PrivateKey.prototype.hash = function (algo) {
		return (this.toPublic().hash(algo));
	};
	
	PrivateKey.prototype.toPublic = function () {
		if (this._pubCache)
			return (this._pubCache);
	
		var algInfo = algs.info[this.type];
		var pubParts = [];
		for (var i = 0; i < algInfo.parts.length; ++i) {
			var p = algInfo.parts[i];
			pubParts.push(this.part[p]);
		}
	
		this._pubCache = new Key({
			type: this.type,
			source: this,
			parts: pubParts
		});
		if (this.comment)
			this._pubCache.comment = this.comment;
		return (this._pubCache);
	};
	
	PrivateKey.prototype.derive = function (newType, newSize) {
		assert.string(newType, 'type');
		assert.optionalNumber(newSize, 'size');
		var priv, pub;
	
		if (this.type === 'ed25519' && newType === 'curve25519') {
			if (ed === undefined)
				ed = __webpack_require__(/*! jodid25519 */ 661);
	
			priv = this.part.r.data;
			if (priv[0] === 0x00)
				priv = priv.slice(1);
			priv = priv.slice(0, 32);
	
			pub = ed.dh.publicKey(priv);
			priv = utils.mpNormalize(Buffer.concat([priv, pub]));
	
			return (new PrivateKey({
				type: 'curve25519',
				parts: [
					{ name: 'R', data: utils.mpNormalize(pub) },
					{ name: 'r', data: priv }
				]
			}));
		} else if (this.type === 'curve25519' && newType === 'ed25519') {
			if (ed === undefined)
				ed = __webpack_require__(/*! jodid25519 */ 661);
	
			priv = this.part.r.data;
			if (priv[0] === 0x00)
				priv = priv.slice(1);
			priv = priv.slice(0, 32);
	
			pub = ed.eddsa.publicKey(priv.toString('binary'));
			pub = new Buffer(pub, 'binary');
	
			priv = utils.mpNormalize(Buffer.concat([priv, pub]));
	
			return (new PrivateKey({
				type: 'ed25519',
				parts: [
					{ name: 'R', data: utils.mpNormalize(pub) },
					{ name: 'r', data: priv }
				]
			}));
		}
		throw (new Error('Key derivation not supported from ' + this.type +
		    ' to ' + newType));
	};
	
	PrivateKey.prototype.createVerify = function (hashAlgo) {
		return (this.toPublic().createVerify(hashAlgo));
	};
	
	PrivateKey.prototype.createSign = function (hashAlgo) {
		if (hashAlgo === undefined)
			hashAlgo = this.defaultHashAlgorithm();
		assert.string(hashAlgo, 'hash algorithm');
	
		/* ED25519 is not supported by OpenSSL, use a javascript impl. */
		if (this.type === 'ed25519' && edCompat !== undefined)
			return (new edCompat.Signer(this, hashAlgo));
		if (this.type === 'curve25519')
			throw (new Error('Curve25519 keys are not suitable for ' +
			    'signing or verification'));
	
		var v, nm, err;
		try {
			nm = hashAlgo.toUpperCase();
			v = crypto.createSign(nm);
		} catch (e) {
			err = e;
		}
		if (v === undefined || (err instanceof Error &&
		    err.message.match(/Unknown message digest/))) {
			nm = 'RSA-';
			nm += hashAlgo.toUpperCase();
			v = crypto.createSign(nm);
		}
		assert.ok(v, 'failed to create verifier');
		var oldSign = v.sign.bind(v);
		var key = this.toBuffer('pkcs1');
		var type = this.type;
		v.sign = function () {
			var sig = oldSign(key);
			if (typeof (sig) === 'string')
				sig = new Buffer(sig, 'binary');
			sig = Signature.parse(sig, type, 'asn1');
			sig.hashAlgorithm = hashAlgo;
			return (sig);
		};
		return (v);
	};
	
	PrivateKey.parse = function (data, format, options) {
		if (typeof (data) !== 'string')
			assert.buffer(data, 'data');
		if (format === undefined)
			format = 'auto';
		assert.string(format, 'format');
		if (typeof (options) === 'string')
			options = { filename: options };
		assert.optionalObject(options, 'options');
		if (options === undefined)
			options = {};
		assert.optionalString(options.filename, 'options.filename');
		if (options.filename === undefined)
			options.filename = '(unnamed)';
	
		assert.object(formats[format], 'formats[format]');
	
		try {
			var k = formats[format].read(data, options);
			assert.ok(k instanceof PrivateKey, 'key is not a private key');
			if (!k.comment)
				k.comment = options.filename;
			return (k);
		} catch (e) {
			if (e.name === 'KeyEncryptedError')
				throw (e);
			throw (new KeyParseError(options.filename, format, e));
		}
	};
	
	PrivateKey.isPrivateKey = function (obj, ver) {
		return (utils.isCompatible(obj, PrivateKey, ver));
	};
	
	/*
	 * API versions for PrivateKey:
	 * [1,0] -- initial ver
	 * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats
	 * [1,2] -- added defaultHashAlgorithm
	 * [1,3] -- added derive, ed, createDH
	 * [1,4] -- first tagged version
	 */
	PrivateKey.prototype._sshpkApiVersion = [1, 4];
	
	PrivateKey._oldVersionDetect = function (obj) {
		assert.func(obj.toPublic);
		assert.func(obj.createSign);
		if (obj.derive)
			return ([1, 3]);
		if (obj.defaultHashAlgorithm)
			return ([1, 2]);
		if (obj.formats['auto'])
			return ([1, 1]);
		return ([1, 0]);
	};


/***/ },
/* 644 */
/*!**********************************!*\
  !*** ./~/sshpk/lib/signature.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = Signature;
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var algs = __webpack_require__(/*! ./algs */ 639);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var errs = __webpack_require__(/*! ./errors */ 641);
	var utils = __webpack_require__(/*! ./utils */ 642);
	var asn1 = __webpack_require__(/*! asn1 */ 645);
	var SSHBuffer = __webpack_require__(/*! ./ssh-buffer */ 651);
	
	var InvalidAlgorithmError = errs.InvalidAlgorithmError;
	var SignatureParseError = errs.SignatureParseError;
	
	function Signature(opts) {
		assert.object(opts, 'options');
		assert.arrayOfObject(opts.parts, 'options.parts');
		assert.string(opts.type, 'options.type');
	
		var partLookup = {};
		for (var i = 0; i < opts.parts.length; ++i) {
			var part = opts.parts[i];
			partLookup[part.name] = part;
		}
	
		this.type = opts.type;
		this.hashAlgorithm = opts.hashAlgo;
		this.parts = opts.parts;
		this.part = partLookup;
	}
	
	Signature.prototype.toBuffer = function (format) {
		if (format === undefined)
			format = 'asn1';
		assert.string(format, 'format');
	
		var buf;
	
		switch (this.type) {
		case 'rsa':
		case 'ed25519':
			if (format === 'ssh') {
				buf = new SSHBuffer({});
				buf.writeString('ssh-' + this.type);
				buf.writePart(this.part.sig);
				return (buf.toBuffer());
			} else {
				return (this.part.sig.data);
			}
	
		case 'dsa':
		case 'ecdsa':
			var r, s;
			if (format === 'asn1') {
				var der = new asn1.BerWriter();
				der.startSequence();
				r = utils.mpNormalize(this.part.r.data);
				s = utils.mpNormalize(this.part.s.data);
				der.writeBuffer(r, asn1.Ber.Integer);
				der.writeBuffer(s, asn1.Ber.Integer);
				der.endSequence();
				return (der.buffer);
			} else if (format === 'ssh' && this.type === 'dsa') {
				buf = new SSHBuffer({});
				buf.writeString('ssh-dss');
				r = this.part.r.data;
				if (r[0] === 0x00)
					r = r.slice(1);
				s = this.part.s.data;
				buf.writeBuffer(Buffer.concat([r, s]));
				return (buf.toBuffer());
			} else if (format === 'ssh' && this.type === 'ecdsa') {
				var inner = new SSHBuffer({});
				r = this.part.r;
				if (r[0] === 0x00)
					r = r.slice(1);
				inner.writePart(r);
				inner.writePart(this.part.s);
	
				buf = new SSHBuffer({});
				/* XXX: find a more proper way to do this? */
				var curve;
				var sz = this.part.r.data.length * 8;
				if (sz === 256)
					curve = 'nistp256';
				else if (sz === 384)
					curve = 'nistp384';
				else if (sz === 528)
					curve = 'nistp521';
				buf.writeString('ecdsa-sha2-' + curve);
				buf.writeBuffer(inner.toBuffer());
				return (buf.toBuffer());
			}
			throw (new Error('Invalid signature format'));
		default:
			throw (new Error('Invalid signature data'));
		}
	};
	
	Signature.prototype.toString = function (format) {
		assert.optionalString(format, 'format');
		return (this.toBuffer(format).toString('base64'));
	};
	
	Signature.parse = function (data, type, format) {
		if (typeof (data) === 'string')
			data = new Buffer(data, 'base64');
		assert.buffer(data, 'data');
		assert.string(format, 'format');
		assert.string(type, 'type');
	
		var opts = {};
		opts.type = type.toLowerCase();
		opts.parts = [];
	
		try {
			assert.ok(data.length > 0, 'signature must not be empty');
			switch (opts.type) {
			case 'rsa':
				return (parseOneNum(data, type, format, opts,
				    'ssh-rsa'));
			case 'ed25519':
				return (parseOneNum(data, type, format, opts,
				    'ssh-ed25519'));
	
			case 'dsa':
			case 'ecdsa':
				if (format === 'asn1')
					return (parseDSAasn1(data, type, format, opts));
				else if (opts.type === 'dsa')
					return (parseDSA(data, type, format, opts));
				else
					return (parseECDSA(data, type, format, opts));
	
			default:
				throw (new InvalidAlgorithmError(type));
			}
	
		} catch (e) {
			if (e instanceof InvalidAlgorithmError)
				throw (e);
			throw (new SignatureParseError(type, format, e));
		}
	};
	
	function parseOneNum(data, type, format, opts, headType) {
		if (format === 'ssh') {
			try {
				var buf = new SSHBuffer({buffer: data});
				var head = buf.readString();
			} catch (e) {
				/* fall through */
			}
			if (head === headType) {
				var sig = buf.readPart();
				assert.ok(buf.atEnd(), 'extra trailing bytes');
				sig.name = 'sig';
				opts.parts.push(sig);
				return (new Signature(opts));
			}
		}
		opts.parts.push({name: 'sig', data: data});
		return (new Signature(opts));
	}
	
	function parseDSAasn1(data, type, format, opts) {
		var der = new asn1.BerReader(data);
		der.readSequence();
		var r = der.readString(asn1.Ber.Integer, true);
		var s = der.readString(asn1.Ber.Integer, true);
	
		opts.parts.push({name: 'r', data: utils.mpNormalize(r)});
		opts.parts.push({name: 's', data: utils.mpNormalize(s)});
	
		return (new Signature(opts));
	}
	
	function parseDSA(data, type, format, opts) {
		if (data.length != 40) {
			var buf = new SSHBuffer({buffer: data});
			var d = buf.readBuffer();
			if (d.toString('ascii') === 'ssh-dss')
				d = buf.readBuffer();
			assert.ok(buf.atEnd(), 'extra trailing bytes');
			assert.strictEqual(d.length, 40, 'invalid inner length');
			data = d;
		}
		opts.parts.push({name: 'r', data: data.slice(0, 20)});
		opts.parts.push({name: 's', data: data.slice(20, 40)});
		return (new Signature(opts));
	}
	
	function parseECDSA(data, type, format, opts) {
		var buf = new SSHBuffer({buffer: data});
	
		var r, s;
		var inner = buf.readBuffer();
		if (inner.toString('ascii').match(/^ecdsa-/)) {
			inner = buf.readBuffer();
			assert.ok(buf.atEnd(), 'extra trailing bytes on outer');
			buf = new SSHBuffer({buffer: inner});
			r = buf.readPart();
		} else {
			r = {data: inner};
		}
	
		s = buf.readPart();
		assert.ok(buf.atEnd(), 'extra trailing bytes');
	
		r.name = 'r';
		s.name = 's';
	
		opts.parts.push(r);
		opts.parts.push(s);
		return (new Signature(opts));
	}
	
	Signature.isSignature = function (obj, ver) {
		return (utils.isCompatible(obj, Signature, ver));
	};
	
	/*
	 * API versions for Signature:
	 * [1,0] -- initial ver
	 * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent
	 *          hashAlgorithm property
	 * [2,1] -- first tagged version
	 */
	Signature.prototype._sshpkApiVersion = [2, 1];
	
	Signature._oldVersionDetect = function (obj) {
		assert.func(obj.toBuffer);
		if (obj.hasOwnProperty('hashAlgorithm'))
			return ([2, 0]);
		return ([1, 0]);
	};


/***/ },
/* 645 */
/*!*****************************!*\
  !*** ./~/asn1/lib/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
	
	// If you have no idea what ASN.1 or BER is, see this:
	// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc
	
	var Ber = __webpack_require__(/*! ./ber/index */ 646);
	
	
	
	///--- Exported API
	
	module.exports = {
	
	  Ber: Ber,
	
	  BerReader: Ber.Reader,
	
	  BerWriter: Ber.Writer
	
	};


/***/ },
/* 646 */
/*!*********************************!*\
  !*** ./~/asn1/lib/ber/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
	
	var errors = __webpack_require__(/*! ./errors */ 647);
	var types = __webpack_require__(/*! ./types */ 648);
	
	var Reader = __webpack_require__(/*! ./reader */ 649);
	var Writer = __webpack_require__(/*! ./writer */ 650);
	
	
	///--- Exports
	
	module.exports = {
	
	  Reader: Reader,
	
	  Writer: Writer
	
	};
	
	for (var t in types) {
	  if (types.hasOwnProperty(t))
	    module.exports[t] = types[t];
	}
	for (var e in errors) {
	  if (errors.hasOwnProperty(e))
	    module.exports[e] = errors[e];
	}


/***/ },
/* 647 */
/*!**********************************!*\
  !*** ./~/asn1/lib/ber/errors.js ***!
  \**********************************/
/***/ function(module, exports) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
	
	
	module.exports = {
	
	  newInvalidAsn1Error: function(msg) {
	    var e = new Error();
	    e.name = 'InvalidAsn1Error';
	    e.message = msg || '';
	    return e;
	  }
	
	};


/***/ },
/* 648 */
/*!*********************************!*\
  !*** ./~/asn1/lib/ber/types.js ***!
  \*********************************/
/***/ function(module, exports) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
	
	
	module.exports = {
	  EOC: 0,
	  Boolean: 1,
	  Integer: 2,
	  BitString: 3,
	  OctetString: 4,
	  Null: 5,
	  OID: 6,
	  ObjectDescriptor: 7,
	  External: 8,
	  Real: 9, // float
	  Enumeration: 10,
	  PDV: 11,
	  Utf8String: 12,
	  RelativeOID: 13,
	  Sequence: 16,
	  Set: 17,
	  NumericString: 18,
	  PrintableString: 19,
	  T61String: 20,
	  VideotexString: 21,
	  IA5String: 22,
	  UTCTime: 23,
	  GeneralizedTime: 24,
	  GraphicString: 25,
	  VisibleString: 26,
	  GeneralString: 28,
	  UniversalString: 29,
	  CharacterString: 30,
	  BMPString: 31,
	  Constructor: 32,
	  Context: 128
	};


/***/ },
/* 649 */
/*!**********************************!*\
  !*** ./~/asn1/lib/ber/reader.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
	
	var assert = __webpack_require__(/*! assert */ 635);
	
	var ASN1 = __webpack_require__(/*! ./types */ 648);
	var errors = __webpack_require__(/*! ./errors */ 647);
	
	
	///--- Globals
	
	var newInvalidAsn1Error = errors.newInvalidAsn1Error;
	
	
	
	///--- API
	
	function Reader(data) {
	  if (!data || !Buffer.isBuffer(data))
	    throw new TypeError('data must be a node Buffer');
	
	  this._buf = data;
	  this._size = data.length;
	
	  // These hold the "current" state
	  this._len = 0;
	  this._offset = 0;
	}
	
	Object.defineProperty(Reader.prototype, 'length', {
	  enumerable: true,
	  get: function () { return (this._len); }
	});
	
	Object.defineProperty(Reader.prototype, 'offset', {
	  enumerable: true,
	  get: function () { return (this._offset); }
	});
	
	Object.defineProperty(Reader.prototype, 'remain', {
	  get: function () { return (this._size - this._offset); }
	});
	
	Object.defineProperty(Reader.prototype, 'buffer', {
	  get: function () { return (this._buf.slice(this._offset)); }
	});
	
	
	/**
	 * Reads a single byte and advances offset; you can pass in `true` to make this
	 * a "peek" operation (i.e., get the byte, but don't advance the offset).
	 *
	 * @param {Boolean} peek true means don't move offset.
	 * @return {Number} the next byte, null if not enough data.
	 */
	Reader.prototype.readByte = function(peek) {
	  if (this._size - this._offset < 1)
	    return null;
	
	  var b = this._buf[this._offset] & 0xff;
	
	  if (!peek)
	    this._offset += 1;
	
	  return b;
	};
	
	
	Reader.prototype.peek = function() {
	  return this.readByte(true);
	};
	
	
	/**
	 * Reads a (potentially) variable length off the BER buffer.  This call is
	 * not really meant to be called directly, as callers have to manipulate
	 * the internal buffer afterwards.
	 *
	 * As a result of this call, you can call `Reader.length`, until the
	 * next thing called that does a readLength.
	 *
	 * @return {Number} the amount of offset to advance the buffer.
	 * @throws {InvalidAsn1Error} on bad ASN.1
	 */
	Reader.prototype.readLength = function(offset) {
	  if (offset === undefined)
	    offset = this._offset;
	
	  if (offset >= this._size)
	    return null;
	
	  var lenB = this._buf[offset++] & 0xff;
	  if (lenB === null)
	    return null;
	
	  if ((lenB & 0x80) == 0x80) {
	    lenB &= 0x7f;
	
	    if (lenB == 0)
	      throw newInvalidAsn1Error('Indefinite length not supported');
	
	    if (lenB > 4)
	      throw newInvalidAsn1Error('encoding too long');
	
	    if (this._size - offset < lenB)
	      return null;
	
	    this._len = 0;
	    for (var i = 0; i < lenB; i++)
	      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);
	
	  } else {
	    // Wasn't a variable length
	    this._len = lenB;
	  }
	
	  return offset;
	};
	
	
	/**
	 * Parses the next sequence in this BER buffer.
	 *
	 * To get the length of the sequence, call `Reader.length`.
	 *
	 * @return {Number} the sequence's tag.
	 */
	Reader.prototype.readSequence = function(tag) {
	  var seq = this.peek();
	  if (seq === null)
	    return null;
	  if (tag !== undefined && tag !== seq)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + seq.toString(16));
	
	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;
	
	  this._offset = o;
	  return seq;
	};
	
	
	Reader.prototype.readInt = function() {
	  return this._readTag(ASN1.Integer);
	};
	
	
	Reader.prototype.readBoolean = function() {
	  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
	};
	
	
	Reader.prototype.readEnumeration = function() {
	  return this._readTag(ASN1.Enumeration);
	};
	
	
	Reader.prototype.readString = function(tag, retbuf) {
	  if (!tag)
	    tag = ASN1.OctetString;
	
	  var b = this.peek();
	  if (b === null)
	    return null;
	
	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));
	
	  var o = this.readLength(this._offset + 1); // stored in `length`
	
	  if (o === null)
	    return null;
	
	  if (this.length > this._size - o)
	    return null;
	
	  this._offset = o;
	
	  if (this.length === 0)
	    return retbuf ? new Buffer(0) : '';
	
	  var str = this._buf.slice(this._offset, this._offset + this.length);
	  this._offset += this.length;
	
	  return retbuf ? str : str.toString('utf8');
	};
	
	Reader.prototype.readOID = function(tag) {
	  if (!tag)
	    tag = ASN1.OID;
	
	  var b = this.readString(tag, true);
	  if (b === null)
	    return null;
	
	  var values = [];
	  var value = 0;
	
	  for (var i = 0; i < b.length; i++) {
	    var byte = b[i] & 0xff;
	
	    value <<= 7;
	    value += byte & 0x7f;
	    if ((byte & 0x80) == 0) {
	      values.push(value);
	      value = 0;
	    }
	  }
	
	  value = values.shift();
	  values.unshift(value % 40);
	  values.unshift((value / 40) >> 0);
	
	  return values.join('.');
	};
	
	
	Reader.prototype._readTag = function(tag) {
	  assert.ok(tag !== undefined);
	
	  var b = this.peek();
	
	  if (b === null)
	    return null;
	
	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));
	
	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;
	
	  if (this.length > 4)
	    throw newInvalidAsn1Error('Integer too long: ' + this.length);
	
	  if (this.length > this._size - o)
	    return null;
	  this._offset = o;
	
	  var fb = this._buf[this._offset];
	  var value = 0;
	
	  for (var i = 0; i < this.length; i++) {
	    value <<= 8;
	    value |= (this._buf[this._offset++] & 0xff);
	  }
	
	  if ((fb & 0x80) == 0x80 && i !== 4)
	    value -= (1 << (i * 8));
	
	  return value >> 0;
	};
	
	
	
	///--- Exported API
	
	module.exports = Reader;


/***/ },
/* 650 */
/*!**********************************!*\
  !*** ./~/asn1/lib/ber/writer.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.
	
	var assert = __webpack_require__(/*! assert */ 635);
	var ASN1 = __webpack_require__(/*! ./types */ 648);
	var errors = __webpack_require__(/*! ./errors */ 647);
	
	
	///--- Globals
	
	var newInvalidAsn1Error = errors.newInvalidAsn1Error;
	
	var DEFAULT_OPTS = {
	  size: 1024,
	  growthFactor: 8
	};
	
	
	///--- Helpers
	
	function merge(from, to) {
	  assert.ok(from);
	  assert.equal(typeof(from), 'object');
	  assert.ok(to);
	  assert.equal(typeof(to), 'object');
	
	  var keys = Object.getOwnPropertyNames(from);
	  keys.forEach(function(key) {
	    if (to[key])
	      return;
	
	    var value = Object.getOwnPropertyDescriptor(from, key);
	    Object.defineProperty(to, key, value);
	  });
	
	  return to;
	}
	
	
	
	///--- API
	
	function Writer(options) {
	  options = merge(DEFAULT_OPTS, options || {});
	
	  this._buf = new Buffer(options.size || 1024);
	  this._size = this._buf.length;
	  this._offset = 0;
	  this._options = options;
	
	  // A list of offsets in the buffer where we need to insert
	  // sequence tag/len pairs.
	  this._seq = [];
	}
	
	Object.defineProperty(Writer.prototype, 'buffer', {
	  get: function () {
	    if (this._seq.length)
	      throw new InvalidAsn1Error(this._seq.length + ' unended sequence(s)');
	
	    return (this._buf.slice(0, this._offset));
	  }
	});
	
	Writer.prototype.writeByte = function(b) {
	  if (typeof(b) !== 'number')
	    throw new TypeError('argument must be a Number');
	
	  this._ensure(1);
	  this._buf[this._offset++] = b;
	};
	
	
	Writer.prototype.writeInt = function(i, tag) {
	  if (typeof(i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Integer;
	
	  var sz = 4;
	
	  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
	         (sz > 1)) {
	    sz--;
	    i <<= 8;
	  }
	
	  if (sz > 4)
	    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');
	
	  this._ensure(2 + sz);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = sz;
	
	  while (sz-- > 0) {
	    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
	    i <<= 8;
	  }
	
	};
	
	
	Writer.prototype.writeNull = function() {
	  this.writeByte(ASN1.Null);
	  this.writeByte(0x00);
	};
	
	
	Writer.prototype.writeEnumeration = function(i, tag) {
	  if (typeof(i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Enumeration;
	
	  return this.writeInt(i, tag);
	};
	
	
	Writer.prototype.writeBoolean = function(b, tag) {
	  if (typeof(b) !== 'boolean')
	    throw new TypeError('argument must be a Boolean');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Boolean;
	
	  this._ensure(3);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = 0x01;
	  this._buf[this._offset++] = b ? 0xff : 0x00;
	};
	
	
	Writer.prototype.writeString = function(s, tag) {
	  if (typeof(s) !== 'string')
	    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.OctetString;
	
	  var len = Buffer.byteLength(s);
	  this.writeByte(tag);
	  this.writeLength(len);
	  if (len) {
	    this._ensure(len);
	    this._buf.write(s, this._offset);
	    this._offset += len;
	  }
	};
	
	
	Writer.prototype.writeBuffer = function(buf, tag) {
	  if (typeof(tag) !== 'number')
	    throw new TypeError('tag must be a number');
	  if (!Buffer.isBuffer(buf))
	    throw new TypeError('argument must be a buffer');
	
	  this.writeByte(tag);
	  this.writeLength(buf.length);
	  this._ensure(buf.length);
	  buf.copy(this._buf, this._offset, 0, buf.length);
	  this._offset += buf.length;
	};
	
	
	Writer.prototype.writeStringArray = function(strings) {
	  if ((!strings instanceof Array))
	    throw new TypeError('argument must be an Array[String]');
	
	  var self = this;
	  strings.forEach(function(s) {
	    self.writeString(s);
	  });
	};
	
	// This is really to solve DER cases, but whatever for now
	Writer.prototype.writeOID = function(s, tag) {
	  if (typeof(s) !== 'string')
	    throw new TypeError('argument must be a string');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.OID;
	
	  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
	    throw new Error('argument is not a valid OID string');
	
	  function encodeOctet(bytes, octet) {
	    if (octet < 128) {
	        bytes.push(octet);
	    } else if (octet < 16384) {
	        bytes.push((octet >>> 7) | 0x80);
	        bytes.push(octet & 0x7F);
	    } else if (octet < 2097152) {
	      bytes.push((octet >>> 14) | 0x80);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else if (octet < 268435456) {
	      bytes.push((octet >>> 21) | 0x80);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else {
	      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    }
	  }
	
	  var tmp = s.split('.');
	  var bytes = [];
	  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
	  tmp.slice(2).forEach(function(b) {
	    encodeOctet(bytes, parseInt(b, 10));
	  });
	
	  var self = this;
	  this._ensure(2 + bytes.length);
	  this.writeByte(tag);
	  this.writeLength(bytes.length);
	  bytes.forEach(function(b) {
	    self.writeByte(b);
	  });
	};
	
	
	Writer.prototype.writeLength = function(len) {
	  if (typeof(len) !== 'number')
	    throw new TypeError('argument must be a Number');
	
	  this._ensure(4);
	
	  if (len <= 0x7f) {
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xff) {
	    this._buf[this._offset++] = 0x81;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffff) {
	    this._buf[this._offset++] = 0x82;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffffff) {
	    this._buf[this._offset++] = 0x83;
	    this._buf[this._offset++] = len >> 16;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else {
	    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
	  }
	};
	
	Writer.prototype.startSequence = function(tag) {
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Sequence | ASN1.Constructor;
	
	  this.writeByte(tag);
	  this._seq.push(this._offset);
	  this._ensure(3);
	  this._offset += 3;
	};
	
	
	Writer.prototype.endSequence = function() {
	  var seq = this._seq.pop();
	  var start = seq + 3;
	  var len = this._offset - start;
	
	  if (len <= 0x7f) {
	    this._shift(start, len, -2);
	    this._buf[seq] = len;
	  } else if (len <= 0xff) {
	    this._shift(start, len, -1);
	    this._buf[seq] = 0x81;
	    this._buf[seq + 1] = len;
	  } else if (len <= 0xffff) {
	    this._buf[seq] = 0x82;
	    this._buf[seq + 1] = len >> 8;
	    this._buf[seq + 2] = len;
	  } else if (len <= 0xffffff) {
	    this._shift(start, len, 1);
	    this._buf[seq] = 0x83;
	    this._buf[seq + 1] = len >> 16;
	    this._buf[seq + 2] = len >> 8;
	    this._buf[seq + 3] = len;
	  } else {
	    throw new InvalidAsn1Error('Sequence too long');
	  }
	};
	
	
	Writer.prototype._shift = function(start, len, shift) {
	  assert.ok(start !== undefined);
	  assert.ok(len !== undefined);
	  assert.ok(shift);
	
	  this._buf.copy(this._buf, start + shift, start, start + len);
	  this._offset += shift;
	};
	
	Writer.prototype._ensure = function(len) {
	  assert.ok(len);
	
	  if (this._size - this._offset < len) {
	    var sz = this._size * this._options.growthFactor;
	    if (sz - this._offset < len)
	      sz += len;
	
	    var buf = new Buffer(sz);
	
	    this._buf.copy(buf, 0, 0, this._offset);
	    this._buf = buf;
	    this._size = sz;
	  }
	};
	
	
	
	///--- Exported API
	
	module.exports = Writer;


/***/ },
/* 651 */
/*!***********************************!*\
  !*** ./~/sshpk/lib/ssh-buffer.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = SSHBuffer;
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	
	function SSHBuffer(opts) {
		assert.object(opts, 'options');
		if (opts.buffer !== undefined)
			assert.buffer(opts.buffer, 'options.buffer');
	
		this._size = opts.buffer ? opts.buffer.length : 1024;
		this._buffer = opts.buffer || (new Buffer(this._size));
		this._offset = 0;
	}
	
	SSHBuffer.prototype.toBuffer = function () {
		return (this._buffer.slice(0, this._offset));
	};
	
	SSHBuffer.prototype.atEnd = function () {
		return (this._offset >= this._buffer.length);
	};
	
	SSHBuffer.prototype.remainder = function () {
		return (this._buffer.slice(this._offset));
	};
	
	SSHBuffer.prototype.skip = function (n) {
		this._offset += n;
	};
	
	SSHBuffer.prototype.expand = function () {
		this._size *= 2;
		var buf = new Buffer(this._size);
		this._buffer.copy(buf, 0);
		this._buffer = buf;
	};
	
	SSHBuffer.prototype.readPart = function () {
		return ({data: this.readBuffer()});
	};
	
	SSHBuffer.prototype.readBuffer = function () {
		var len = this._buffer.readUInt32BE(this._offset);
		this._offset += 4;
		assert.ok(this._offset + len <= this._buffer.length,
		    'length out of bounds at +0x' + this._offset.toString(16) +
		    ' (data truncated?)');
		var buf = this._buffer.slice(this._offset, this._offset + len);
		this._offset += len;
		return (buf);
	};
	
	SSHBuffer.prototype.readString = function () {
		return (this.readBuffer().toString());
	};
	
	SSHBuffer.prototype.readCString = function () {
		var offset = this._offset;
		while (offset < this._buffer.length &&
		    this._buffer[offset] !== 0x00)
			offset++;
		assert.ok(offset < this._buffer.length, 'c string does not terminate');
		var str = this._buffer.slice(this._offset, offset).toString();
		this._offset = offset + 1;
		return (str);
	};
	
	SSHBuffer.prototype.readInt = function () {
		var v = this._buffer.readUInt32BE(this._offset);
		this._offset += 4;
		return (v);
	};
	
	SSHBuffer.prototype.readChar = function () {
		var v = this._buffer[this._offset++];
		return (v);
	};
	
	SSHBuffer.prototype.writeBuffer = function (buf) {
		while (this._offset + 4 + buf.length > this._size)
			this.expand();
		this._buffer.writeUInt32BE(buf.length, this._offset);
		this._offset += 4;
		buf.copy(this._buffer, this._offset);
		this._offset += buf.length;
	};
	
	SSHBuffer.prototype.writeString = function (str) {
		this.writeBuffer(new Buffer(str, 'utf8'));
	};
	
	SSHBuffer.prototype.writeCString = function (str) {
		while (this._offset + 1 + str.length > this._size)
			this.expand();
		this._buffer.write(str, this._offset);
		this._offset += str.length;
		this._buffer[this._offset++] = 0;
	};
	
	SSHBuffer.prototype.writeInt = function (v) {
		while (this._offset + 4 > this._size)
			this.expand();
		this._buffer.writeUInt32BE(v, this._offset);
		this._offset += 4;
	};
	
	SSHBuffer.prototype.writeChar = function (v) {
		while (this._offset + 1 > this._size)
			this.expand();
		this._buffer[this._offset++] = v;
	};
	
	SSHBuffer.prototype.writePart = function (p) {
		this.writeBuffer(p.data);
	};
	
	SSHBuffer.prototype.write = function (buf) {
		while (this._offset + buf.length > this._size)
			this.expand();
		buf.copy(this._buffer, this._offset);
		this._offset += buf.length;
	};


/***/ },
/* 652 */
/*!**********************************!*\
  !*** ./~/sshpk/lib/ed-compat.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		Verifier: Verifier,
		Signer: Signer
	};
	
	var nacl;
	var stream = __webpack_require__(/*! stream */ 604);
	var util = __webpack_require__(/*! util */ 597);
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var Signature = __webpack_require__(/*! ./signature */ 644);
	
	function Verifier(key, hashAlgo) {
		if (nacl === undefined)
			nacl = __webpack_require__(/*! tweetnacl */ 653);
	
		if (hashAlgo.toLowerCase() !== 'sha512')
			throw (new Error('ED25519 only supports the use of ' +
			    'SHA-512 hashes'));
	
		this.key = key;
		this.chunks = [];
	
		stream.Writable.call(this, {});
	}
	util.inherits(Verifier, stream.Writable);
	
	Verifier.prototype._write = function (chunk, enc, cb) {
		this.chunks.push(chunk);
		cb();
	};
	
	Verifier.prototype.update = function (chunk) {
		if (typeof (chunk) === 'string')
			chunk = new Buffer(chunk, 'binary');
		this.chunks.push(chunk);
	};
	
	Verifier.prototype.verify = function (signature, fmt) {
		var sig;
		if (Signature.isSignature(signature, [2, 0])) {
			if (signature.type !== 'ed25519')
				return (false);
			sig = signature.toBuffer('raw');
	
		} else if (typeof (signature) === 'string') {
			sig = new Buffer(signature, 'base64');
	
		} else if (Signature.isSignature(signature, [1, 0])) {
			throw (new Error('signature was created by too old ' +
			    'a version of sshpk and cannot be verified'));
		}
	
		assert.buffer(sig);
		return (nacl.sign.detached.verify(
		    new Uint8Array(Buffer.concat(this.chunks)),
		    new Uint8Array(sig),
		    new Uint8Array(this.key.part.R.data)));
	};
	
	function Signer(key, hashAlgo) {
		if (nacl === undefined)
			nacl = __webpack_require__(/*! tweetnacl */ 653);
	
		if (hashAlgo.toLowerCase() !== 'sha512')
			throw (new Error('ED25519 only supports the use of ' +
			    'SHA-512 hashes'));
	
		this.key = key;
		this.chunks = [];
	
		stream.Writable.call(this, {});
	}
	util.inherits(Signer, stream.Writable);
	
	Signer.prototype._write = function (chunk, enc, cb) {
		this.chunks.push(chunk);
		cb();
	};
	
	Signer.prototype.update = function (chunk) {
		if (typeof (chunk) === 'string')
			chunk = new Buffer(chunk, 'binary');
		this.chunks.push(chunk);
	};
	
	Signer.prototype.sign = function () {
		var sig = nacl.sign.detached(
		    new Uint8Array(Buffer.concat(this.chunks)),
		    new Uint8Array(this.key.part.r.data));
		var sigBuf = new Buffer(sig);
		var sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');
		sigObj.hashAlgorithm = 'sha512';
		return (sigObj);
	};


/***/ },
/* 653 */
/*!**********************************!*\
  !*** ./~/tweetnacl/nacl-fast.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	(function(nacl) {
	'use strict';
	
	// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	//
	// Implementation derived from TweetNaCl version 20140427.
	// See for details: http://tweetnacl.cr.yp.to/
	
	var gf = function(init) {
	  var i, r = new Float64Array(16);
	  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
	  return r;
	};
	
	//  Pluggable, initialized in high-level API below.
	var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };
	
	var _0 = new Uint8Array(16);
	var _9 = new Uint8Array(32); _9[0] = 9;
	
	var gf0 = gf(),
	    gf1 = gf([1]),
	    _121665 = gf([0xdb41, 1]),
	    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
	    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
	    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
	    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
	    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);
	
	function ts64(x, i, h, l) {
	  x[i]   = (h >> 24) & 0xff;
	  x[i+1] = (h >> 16) & 0xff;
	  x[i+2] = (h >>  8) & 0xff;
	  x[i+3] = h & 0xff;
	  x[i+4] = (l >> 24)  & 0xff;
	  x[i+5] = (l >> 16)  & 0xff;
	  x[i+6] = (l >>  8)  & 0xff;
	  x[i+7] = l & 0xff;
	}
	
	function vn(x, xi, y, yi, n) {
	  var i,d = 0;
	  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
	  return (1 & ((d - 1) >>> 8)) - 1;
	}
	
	function crypto_verify_16(x, xi, y, yi) {
	  return vn(x,xi,y,yi,16);
	}
	
	function crypto_verify_32(x, xi, y, yi) {
	  return vn(x,xi,y,yi,32);
	}
	
	function core_salsa20(o, p, k, c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
	
	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;
	
	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	
	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }
	   x0 =  x0 +  j0 | 0;
	   x1 =  x1 +  j1 | 0;
	   x2 =  x2 +  j2 | 0;
	   x3 =  x3 +  j3 | 0;
	   x4 =  x4 +  j4 | 0;
	   x5 =  x5 +  j5 | 0;
	   x6 =  x6 +  j6 | 0;
	   x7 =  x7 +  j7 | 0;
	   x8 =  x8 +  j8 | 0;
	   x9 =  x9 +  j9 | 0;
	  x10 = x10 + j10 | 0;
	  x11 = x11 + j11 | 0;
	  x12 = x12 + j12 | 0;
	  x13 = x13 + j13 | 0;
	  x14 = x14 + j14 | 0;
	  x15 = x15 + j15 | 0;
	
	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;
	
	  o[ 4] = x1 >>>  0 & 0xff;
	  o[ 5] = x1 >>>  8 & 0xff;
	  o[ 6] = x1 >>> 16 & 0xff;
	  o[ 7] = x1 >>> 24 & 0xff;
	
	  o[ 8] = x2 >>>  0 & 0xff;
	  o[ 9] = x2 >>>  8 & 0xff;
	  o[10] = x2 >>> 16 & 0xff;
	  o[11] = x2 >>> 24 & 0xff;
	
	  o[12] = x3 >>>  0 & 0xff;
	  o[13] = x3 >>>  8 & 0xff;
	  o[14] = x3 >>> 16 & 0xff;
	  o[15] = x3 >>> 24 & 0xff;
	
	  o[16] = x4 >>>  0 & 0xff;
	  o[17] = x4 >>>  8 & 0xff;
	  o[18] = x4 >>> 16 & 0xff;
	  o[19] = x4 >>> 24 & 0xff;
	
	  o[20] = x5 >>>  0 & 0xff;
	  o[21] = x5 >>>  8 & 0xff;
	  o[22] = x5 >>> 16 & 0xff;
	  o[23] = x5 >>> 24 & 0xff;
	
	  o[24] = x6 >>>  0 & 0xff;
	  o[25] = x6 >>>  8 & 0xff;
	  o[26] = x6 >>> 16 & 0xff;
	  o[27] = x6 >>> 24 & 0xff;
	
	  o[28] = x7 >>>  0 & 0xff;
	  o[29] = x7 >>>  8 & 0xff;
	  o[30] = x7 >>> 16 & 0xff;
	  o[31] = x7 >>> 24 & 0xff;
	
	  o[32] = x8 >>>  0 & 0xff;
	  o[33] = x8 >>>  8 & 0xff;
	  o[34] = x8 >>> 16 & 0xff;
	  o[35] = x8 >>> 24 & 0xff;
	
	  o[36] = x9 >>>  0 & 0xff;
	  o[37] = x9 >>>  8 & 0xff;
	  o[38] = x9 >>> 16 & 0xff;
	  o[39] = x9 >>> 24 & 0xff;
	
	  o[40] = x10 >>>  0 & 0xff;
	  o[41] = x10 >>>  8 & 0xff;
	  o[42] = x10 >>> 16 & 0xff;
	  o[43] = x10 >>> 24 & 0xff;
	
	  o[44] = x11 >>>  0 & 0xff;
	  o[45] = x11 >>>  8 & 0xff;
	  o[46] = x11 >>> 16 & 0xff;
	  o[47] = x11 >>> 24 & 0xff;
	
	  o[48] = x12 >>>  0 & 0xff;
	  o[49] = x12 >>>  8 & 0xff;
	  o[50] = x12 >>> 16 & 0xff;
	  o[51] = x12 >>> 24 & 0xff;
	
	  o[52] = x13 >>>  0 & 0xff;
	  o[53] = x13 >>>  8 & 0xff;
	  o[54] = x13 >>> 16 & 0xff;
	  o[55] = x13 >>> 24 & 0xff;
	
	  o[56] = x14 >>>  0 & 0xff;
	  o[57] = x14 >>>  8 & 0xff;
	  o[58] = x14 >>> 16 & 0xff;
	  o[59] = x14 >>> 24 & 0xff;
	
	  o[60] = x15 >>>  0 & 0xff;
	  o[61] = x15 >>>  8 & 0xff;
	  o[62] = x15 >>> 16 & 0xff;
	  o[63] = x15 >>> 24 & 0xff;
	}
	
	function core_hsalsa20(o,p,k,c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
	
	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;
	
	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	
	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);
	
	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);
	
	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);
	
	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }
	
	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;
	
	  o[ 4] = x5 >>>  0 & 0xff;
	  o[ 5] = x5 >>>  8 & 0xff;
	  o[ 6] = x5 >>> 16 & 0xff;
	  o[ 7] = x5 >>> 24 & 0xff;
	
	  o[ 8] = x10 >>>  0 & 0xff;
	  o[ 9] = x10 >>>  8 & 0xff;
	  o[10] = x10 >>> 16 & 0xff;
	  o[11] = x10 >>> 24 & 0xff;
	
	  o[12] = x15 >>>  0 & 0xff;
	  o[13] = x15 >>>  8 & 0xff;
	  o[14] = x15 >>> 16 & 0xff;
	  o[15] = x15 >>> 24 & 0xff;
	
	  o[16] = x6 >>>  0 & 0xff;
	  o[17] = x6 >>>  8 & 0xff;
	  o[18] = x6 >>> 16 & 0xff;
	  o[19] = x6 >>> 24 & 0xff;
	
	  o[20] = x7 >>>  0 & 0xff;
	  o[21] = x7 >>>  8 & 0xff;
	  o[22] = x7 >>> 16 & 0xff;
	  o[23] = x7 >>> 24 & 0xff;
	
	  o[24] = x8 >>>  0 & 0xff;
	  o[25] = x8 >>>  8 & 0xff;
	  o[26] = x8 >>> 16 & 0xff;
	  o[27] = x8 >>> 24 & 0xff;
	
	  o[28] = x9 >>>  0 & 0xff;
	  o[29] = x9 >>>  8 & 0xff;
	  o[30] = x9 >>> 16 & 0xff;
	  o[31] = x9 >>> 24 & 0xff;
	}
	
	function crypto_core_salsa20(out,inp,k,c) {
	  core_salsa20(out,inp,k,c);
	}
	
	function crypto_core_hsalsa20(out,inp,k,c) {
	  core_hsalsa20(out,inp,k,c);
	}
	
	var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
	            // "expand 32-byte k"
	
	function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	    mpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	  }
	  return 0;
	}
	
	function crypto_stream_salsa20(c,cpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = x[i];
	  }
	  return 0;
	}
	
	function crypto_stream(c,cpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20(c,cpos,d,sn,s);
	}
	
	function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
	}
	
	/*
	* Port of Andrew Moon's Poly1305-donna-16. Public domain.
	* https://github.com/floodyberry/poly1305-donna
	*/
	
	var poly1305 = function(key) {
	  this.buffer = new Uint8Array(16);
	  this.r = new Uint16Array(10);
	  this.h = new Uint16Array(10);
	  this.pad = new Uint16Array(8);
	  this.leftover = 0;
	  this.fin = 0;
	
	  var t0, t1, t2, t3, t4, t5, t6, t7;
	
	  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
	  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
	  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
	  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
	  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
	  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	  this.r[9] = ((t7 >>>  5)) & 0x007f;
	
	  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
	  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
	  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
	  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
	  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
	  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
	  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
	  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
	};
	
	poly1305.prototype.blocks = function(m, mpos, bytes) {
	  var hibit = this.fin ? 0 : (1 << 11);
	  var t0, t1, t2, t3, t4, t5, t6, t7, c;
	  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
	
	  var h0 = this.h[0],
	      h1 = this.h[1],
	      h2 = this.h[2],
	      h3 = this.h[3],
	      h4 = this.h[4],
	      h5 = this.h[5],
	      h6 = this.h[6],
	      h7 = this.h[7],
	      h8 = this.h[8],
	      h9 = this.h[9];
	
	  var r0 = this.r[0],
	      r1 = this.r[1],
	      r2 = this.r[2],
	      r3 = this.r[3],
	      r4 = this.r[4],
	      r5 = this.r[5],
	      r6 = this.r[6],
	      r7 = this.r[7],
	      r8 = this.r[8],
	      r9 = this.r[9];
	
	  while (bytes >= 16) {
	    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
	    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
	    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
	    h5 += ((t4 >>>  1)) & 0x1fff;
	    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
	    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	    h9 += ((t7 >>> 5)) | hibit;
	
	    c = 0;
	
	    d0 = c;
	    d0 += h0 * r0;
	    d0 += h1 * (5 * r9);
	    d0 += h2 * (5 * r8);
	    d0 += h3 * (5 * r7);
	    d0 += h4 * (5 * r6);
	    c = (d0 >>> 13); d0 &= 0x1fff;
	    d0 += h5 * (5 * r5);
	    d0 += h6 * (5 * r4);
	    d0 += h7 * (5 * r3);
	    d0 += h8 * (5 * r2);
	    d0 += h9 * (5 * r1);
	    c += (d0 >>> 13); d0 &= 0x1fff;
	
	    d1 = c;
	    d1 += h0 * r1;
	    d1 += h1 * r0;
	    d1 += h2 * (5 * r9);
	    d1 += h3 * (5 * r8);
	    d1 += h4 * (5 * r7);
	    c = (d1 >>> 13); d1 &= 0x1fff;
	    d1 += h5 * (5 * r6);
	    d1 += h6 * (5 * r5);
	    d1 += h7 * (5 * r4);
	    d1 += h8 * (5 * r3);
	    d1 += h9 * (5 * r2);
	    c += (d1 >>> 13); d1 &= 0x1fff;
	
	    d2 = c;
	    d2 += h0 * r2;
	    d2 += h1 * r1;
	    d2 += h2 * r0;
	    d2 += h3 * (5 * r9);
	    d2 += h4 * (5 * r8);
	    c = (d2 >>> 13); d2 &= 0x1fff;
	    d2 += h5 * (5 * r7);
	    d2 += h6 * (5 * r6);
	    d2 += h7 * (5 * r5);
	    d2 += h8 * (5 * r4);
	    d2 += h9 * (5 * r3);
	    c += (d2 >>> 13); d2 &= 0x1fff;
	
	    d3 = c;
	    d3 += h0 * r3;
	    d3 += h1 * r2;
	    d3 += h2 * r1;
	    d3 += h3 * r0;
	    d3 += h4 * (5 * r9);
	    c = (d3 >>> 13); d3 &= 0x1fff;
	    d3 += h5 * (5 * r8);
	    d3 += h6 * (5 * r7);
	    d3 += h7 * (5 * r6);
	    d3 += h8 * (5 * r5);
	    d3 += h9 * (5 * r4);
	    c += (d3 >>> 13); d3 &= 0x1fff;
	
	    d4 = c;
	    d4 += h0 * r4;
	    d4 += h1 * r3;
	    d4 += h2 * r2;
	    d4 += h3 * r1;
	    d4 += h4 * r0;
	    c = (d4 >>> 13); d4 &= 0x1fff;
	    d4 += h5 * (5 * r9);
	    d4 += h6 * (5 * r8);
	    d4 += h7 * (5 * r7);
	    d4 += h8 * (5 * r6);
	    d4 += h9 * (5 * r5);
	    c += (d4 >>> 13); d4 &= 0x1fff;
	
	    d5 = c;
	    d5 += h0 * r5;
	    d5 += h1 * r4;
	    d5 += h2 * r3;
	    d5 += h3 * r2;
	    d5 += h4 * r1;
	    c = (d5 >>> 13); d5 &= 0x1fff;
	    d5 += h5 * r0;
	    d5 += h6 * (5 * r9);
	    d5 += h7 * (5 * r8);
	    d5 += h8 * (5 * r7);
	    d5 += h9 * (5 * r6);
	    c += (d5 >>> 13); d5 &= 0x1fff;
	
	    d6 = c;
	    d6 += h0 * r6;
	    d6 += h1 * r5;
	    d6 += h2 * r4;
	    d6 += h3 * r3;
	    d6 += h4 * r2;
	    c = (d6 >>> 13); d6 &= 0x1fff;
	    d6 += h5 * r1;
	    d6 += h6 * r0;
	    d6 += h7 * (5 * r9);
	    d6 += h8 * (5 * r8);
	    d6 += h9 * (5 * r7);
	    c += (d6 >>> 13); d6 &= 0x1fff;
	
	    d7 = c;
	    d7 += h0 * r7;
	    d7 += h1 * r6;
	    d7 += h2 * r5;
	    d7 += h3 * r4;
	    d7 += h4 * r3;
	    c = (d7 >>> 13); d7 &= 0x1fff;
	    d7 += h5 * r2;
	    d7 += h6 * r1;
	    d7 += h7 * r0;
	    d7 += h8 * (5 * r9);
	    d7 += h9 * (5 * r8);
	    c += (d7 >>> 13); d7 &= 0x1fff;
	
	    d8 = c;
	    d8 += h0 * r8;
	    d8 += h1 * r7;
	    d8 += h2 * r6;
	    d8 += h3 * r5;
	    d8 += h4 * r4;
	    c = (d8 >>> 13); d8 &= 0x1fff;
	    d8 += h5 * r3;
	    d8 += h6 * r2;
	    d8 += h7 * r1;
	    d8 += h8 * r0;
	    d8 += h9 * (5 * r9);
	    c += (d8 >>> 13); d8 &= 0x1fff;
	
	    d9 = c;
	    d9 += h0 * r9;
	    d9 += h1 * r8;
	    d9 += h2 * r7;
	    d9 += h3 * r6;
	    d9 += h4 * r5;
	    c = (d9 >>> 13); d9 &= 0x1fff;
	    d9 += h5 * r4;
	    d9 += h6 * r3;
	    d9 += h7 * r2;
	    d9 += h8 * r1;
	    d9 += h9 * r0;
	    c += (d9 >>> 13); d9 &= 0x1fff;
	
	    c = (((c << 2) + c)) | 0;
	    c = (c + d0) | 0;
	    d0 = c & 0x1fff;
	    c = (c >>> 13);
	    d1 += c;
	
	    h0 = d0;
	    h1 = d1;
	    h2 = d2;
	    h3 = d3;
	    h4 = d4;
	    h5 = d5;
	    h6 = d6;
	    h7 = d7;
	    h8 = d8;
	    h9 = d9;
	
	    mpos += 16;
	    bytes -= 16;
	  }
	  this.h[0] = h0;
	  this.h[1] = h1;
	  this.h[2] = h2;
	  this.h[3] = h3;
	  this.h[4] = h4;
	  this.h[5] = h5;
	  this.h[6] = h6;
	  this.h[7] = h7;
	  this.h[8] = h8;
	  this.h[9] = h9;
	};
	
	poly1305.prototype.finish = function(mac, macpos) {
	  var g = new Uint16Array(10);
	  var c, mask, f, i;
	
	  if (this.leftover) {
	    i = this.leftover;
	    this.buffer[i++] = 1;
	    for (; i < 16; i++) this.buffer[i] = 0;
	    this.fin = 1;
	    this.blocks(this.buffer, 0, 16);
	  }
	
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  for (i = 2; i < 10; i++) {
	    this.h[i] += c;
	    c = this.h[i] >>> 13;
	    this.h[i] &= 0x1fff;
	  }
	  this.h[0] += (c * 5);
	  c = this.h[0] >>> 13;
	  this.h[0] &= 0x1fff;
	  this.h[1] += c;
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  this.h[2] += c;
	
	  g[0] = this.h[0] + 5;
	  c = g[0] >>> 13;
	  g[0] &= 0x1fff;
	  for (i = 1; i < 10; i++) {
	    g[i] = this.h[i] + c;
	    c = g[i] >>> 13;
	    g[i] &= 0x1fff;
	  }
	  g[9] -= (1 << 13);
	
	  mask = (g[9] >>> ((2 * 8) - 1)) - 1;
	  for (i = 0; i < 10; i++) g[i] &= mask;
	  mask = ~mask;
	  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];
	
	  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
	  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
	  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
	  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
	  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
	  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
	  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
	  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;
	
	  f = this.h[0] + this.pad[0];
	  this.h[0] = f & 0xffff;
	  for (i = 1; i < 8; i++) {
	    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
	    this.h[i] = f & 0xffff;
	  }
	
	  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
	  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
	  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
	  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
	  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
	  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
	  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
	  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
	  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
	  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
	  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
	  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
	  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
	  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
	  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
	  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
	};
	
	poly1305.prototype.update = function(m, mpos, bytes) {
	  var i, want;
	
	  if (this.leftover) {
	    want = (16 - this.leftover);
	    if (want > bytes)
	      want = bytes;
	    for (i = 0; i < want; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    bytes -= want;
	    mpos += want;
	    this.leftover += want;
	    if (this.leftover < 16)
	      return;
	    this.blocks(this.buffer, 0, 16);
	    this.leftover = 0;
	  }
	
	  if (bytes >= 16) {
	    want = bytes - (bytes % 16);
	    this.blocks(m, mpos, want);
	    mpos += want;
	    bytes -= want;
	  }
	
	  if (bytes) {
	    for (i = 0; i < bytes; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    this.leftover += bytes;
	  }
	};
	
	function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
	  var s = new poly1305(k);
	  s.update(m, mpos, n);
	  s.finish(out, outpos);
	  return 0;
	}
	
	function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
	  var x = new Uint8Array(16);
	  crypto_onetimeauth(x,0,m,mpos,n,k);
	  return crypto_verify_16(h,hpos,x,0);
	}
	
	function crypto_secretbox(c,m,d,n,k) {
	  var i;
	  if (d < 32) return -1;
	  crypto_stream_xor(c,0,m,0,d,n,k);
	  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
	  for (i = 0; i < 16; i++) c[i] = 0;
	  return 0;
	}
	
	function crypto_secretbox_open(m,c,d,n,k) {
	  var i;
	  var x = new Uint8Array(32);
	  if (d < 32) return -1;
	  crypto_stream(x,0,32,n,k);
	  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
	  crypto_stream_xor(m,0,c,0,d,n,k);
	  for (i = 0; i < 32; i++) m[i] = 0;
	  return 0;
	}
	
	function set25519(r, a) {
	  var i;
	  for (i = 0; i < 16; i++) r[i] = a[i]|0;
	}
	
	function car25519(o) {
	  var i, v, c = 1;
	  for (i = 0; i < 16; i++) {
	    v = o[i] + c + 65535;
	    c = Math.floor(v / 65536);
	    o[i] = v - c * 65536;
	  }
	  o[0] += c-1 + 37 * (c-1);
	}
	
	function sel25519(p, q, b) {
	  var t, c = ~(b-1);
	  for (var i = 0; i < 16; i++) {
	    t = c & (p[i] ^ q[i]);
	    p[i] ^= t;
	    q[i] ^= t;
	  }
	}
	
	function pack25519(o, n) {
	  var i, j, b;
	  var m = gf(), t = gf();
	  for (i = 0; i < 16; i++) t[i] = n[i];
	  car25519(t);
	  car25519(t);
	  car25519(t);
	  for (j = 0; j < 2; j++) {
	    m[0] = t[0] - 0xffed;
	    for (i = 1; i < 15; i++) {
	      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
	      m[i-1] &= 0xffff;
	    }
	    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
	    b = (m[15]>>16) & 1;
	    m[14] &= 0xffff;
	    sel25519(t, m, 1-b);
	  }
	  for (i = 0; i < 16; i++) {
	    o[2*i] = t[i] & 0xff;
	    o[2*i+1] = t[i]>>8;
	  }
	}
	
	function neq25519(a, b) {
	  var c = new Uint8Array(32), d = new Uint8Array(32);
	  pack25519(c, a);
	  pack25519(d, b);
	  return crypto_verify_32(c, 0, d, 0);
	}
	
	function par25519(a) {
	  var d = new Uint8Array(32);
	  pack25519(d, a);
	  return d[0] & 1;
	}
	
	function unpack25519(o, n) {
	  var i;
	  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
	  o[15] &= 0x7fff;
	}
	
	function A(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
	}
	
	function Z(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
	}
	
	function M(o, a, b) {
	  var v, c,
	     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
	     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
	    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
	    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
	    b0 = b[0],
	    b1 = b[1],
	    b2 = b[2],
	    b3 = b[3],
	    b4 = b[4],
	    b5 = b[5],
	    b6 = b[6],
	    b7 = b[7],
	    b8 = b[8],
	    b9 = b[9],
	    b10 = b[10],
	    b11 = b[11],
	    b12 = b[12],
	    b13 = b[13],
	    b14 = b[14],
	    b15 = b[15];
	
	  v = a[0];
	  t0 += v * b0;
	  t1 += v * b1;
	  t2 += v * b2;
	  t3 += v * b3;
	  t4 += v * b4;
	  t5 += v * b5;
	  t6 += v * b6;
	  t7 += v * b7;
	  t8 += v * b8;
	  t9 += v * b9;
	  t10 += v * b10;
	  t11 += v * b11;
	  t12 += v * b12;
	  t13 += v * b13;
	  t14 += v * b14;
	  t15 += v * b15;
	  v = a[1];
	  t1 += v * b0;
	  t2 += v * b1;
	  t3 += v * b2;
	  t4 += v * b3;
	  t5 += v * b4;
	  t6 += v * b5;
	  t7 += v * b6;
	  t8 += v * b7;
	  t9 += v * b8;
	  t10 += v * b9;
	  t11 += v * b10;
	  t12 += v * b11;
	  t13 += v * b12;
	  t14 += v * b13;
	  t15 += v * b14;
	  t16 += v * b15;
	  v = a[2];
	  t2 += v * b0;
	  t3 += v * b1;
	  t4 += v * b2;
	  t5 += v * b3;
	  t6 += v * b4;
	  t7 += v * b5;
	  t8 += v * b6;
	  t9 += v * b7;
	  t10 += v * b8;
	  t11 += v * b9;
	  t12 += v * b10;
	  t13 += v * b11;
	  t14 += v * b12;
	  t15 += v * b13;
	  t16 += v * b14;
	  t17 += v * b15;
	  v = a[3];
	  t3 += v * b0;
	  t4 += v * b1;
	  t5 += v * b2;
	  t6 += v * b3;
	  t7 += v * b4;
	  t8 += v * b5;
	  t9 += v * b6;
	  t10 += v * b7;
	  t11 += v * b8;
	  t12 += v * b9;
	  t13 += v * b10;
	  t14 += v * b11;
	  t15 += v * b12;
	  t16 += v * b13;
	  t17 += v * b14;
	  t18 += v * b15;
	  v = a[4];
	  t4 += v * b0;
	  t5 += v * b1;
	  t6 += v * b2;
	  t7 += v * b3;
	  t8 += v * b4;
	  t9 += v * b5;
	  t10 += v * b6;
	  t11 += v * b7;
	  t12 += v * b8;
	  t13 += v * b9;
	  t14 += v * b10;
	  t15 += v * b11;
	  t16 += v * b12;
	  t17 += v * b13;
	  t18 += v * b14;
	  t19 += v * b15;
	  v = a[5];
	  t5 += v * b0;
	  t6 += v * b1;
	  t7 += v * b2;
	  t8 += v * b3;
	  t9 += v * b4;
	  t10 += v * b5;
	  t11 += v * b6;
	  t12 += v * b7;
	  t13 += v * b8;
	  t14 += v * b9;
	  t15 += v * b10;
	  t16 += v * b11;
	  t17 += v * b12;
	  t18 += v * b13;
	  t19 += v * b14;
	  t20 += v * b15;
	  v = a[6];
	  t6 += v * b0;
	  t7 += v * b1;
	  t8 += v * b2;
	  t9 += v * b3;
	  t10 += v * b4;
	  t11 += v * b5;
	  t12 += v * b6;
	  t13 += v * b7;
	  t14 += v * b8;
	  t15 += v * b9;
	  t16 += v * b10;
	  t17 += v * b11;
	  t18 += v * b12;
	  t19 += v * b13;
	  t20 += v * b14;
	  t21 += v * b15;
	  v = a[7];
	  t7 += v * b0;
	  t8 += v * b1;
	  t9 += v * b2;
	  t10 += v * b3;
	  t11 += v * b4;
	  t12 += v * b5;
	  t13 += v * b6;
	  t14 += v * b7;
	  t15 += v * b8;
	  t16 += v * b9;
	  t17 += v * b10;
	  t18 += v * b11;
	  t19 += v * b12;
	  t20 += v * b13;
	  t21 += v * b14;
	  t22 += v * b15;
	  v = a[8];
	  t8 += v * b0;
	  t9 += v * b1;
	  t10 += v * b2;
	  t11 += v * b3;
	  t12 += v * b4;
	  t13 += v * b5;
	  t14 += v * b6;
	  t15 += v * b7;
	  t16 += v * b8;
	  t17 += v * b9;
	  t18 += v * b10;
	  t19 += v * b11;
	  t20 += v * b12;
	  t21 += v * b13;
	  t22 += v * b14;
	  t23 += v * b15;
	  v = a[9];
	  t9 += v * b0;
	  t10 += v * b1;
	  t11 += v * b2;
	  t12 += v * b3;
	  t13 += v * b4;
	  t14 += v * b5;
	  t15 += v * b6;
	  t16 += v * b7;
	  t17 += v * b8;
	  t18 += v * b9;
	  t19 += v * b10;
	  t20 += v * b11;
	  t21 += v * b12;
	  t22 += v * b13;
	  t23 += v * b14;
	  t24 += v * b15;
	  v = a[10];
	  t10 += v * b0;
	  t11 += v * b1;
	  t12 += v * b2;
	  t13 += v * b3;
	  t14 += v * b4;
	  t15 += v * b5;
	  t16 += v * b6;
	  t17 += v * b7;
	  t18 += v * b8;
	  t19 += v * b9;
	  t20 += v * b10;
	  t21 += v * b11;
	  t22 += v * b12;
	  t23 += v * b13;
	  t24 += v * b14;
	  t25 += v * b15;
	  v = a[11];
	  t11 += v * b0;
	  t12 += v * b1;
	  t13 += v * b2;
	  t14 += v * b3;
	  t15 += v * b4;
	  t16 += v * b5;
	  t17 += v * b6;
	  t18 += v * b7;
	  t19 += v * b8;
	  t20 += v * b9;
	  t21 += v * b10;
	  t22 += v * b11;
	  t23 += v * b12;
	  t24 += v * b13;
	  t25 += v * b14;
	  t26 += v * b15;
	  v = a[12];
	  t12 += v * b0;
	  t13 += v * b1;
	  t14 += v * b2;
	  t15 += v * b3;
	  t16 += v * b4;
	  t17 += v * b5;
	  t18 += v * b6;
	  t19 += v * b7;
	  t20 += v * b8;
	  t21 += v * b9;
	  t22 += v * b10;
	  t23 += v * b11;
	  t24 += v * b12;
	  t25 += v * b13;
	  t26 += v * b14;
	  t27 += v * b15;
	  v = a[13];
	  t13 += v * b0;
	  t14 += v * b1;
	  t15 += v * b2;
	  t16 += v * b3;
	  t17 += v * b4;
	  t18 += v * b5;
	  t19 += v * b6;
	  t20 += v * b7;
	  t21 += v * b8;
	  t22 += v * b9;
	  t23 += v * b10;
	  t24 += v * b11;
	  t25 += v * b12;
	  t26 += v * b13;
	  t27 += v * b14;
	  t28 += v * b15;
	  v = a[14];
	  t14 += v * b0;
	  t15 += v * b1;
	  t16 += v * b2;
	  t17 += v * b3;
	  t18 += v * b4;
	  t19 += v * b5;
	  t20 += v * b6;
	  t21 += v * b7;
	  t22 += v * b8;
	  t23 += v * b9;
	  t24 += v * b10;
	  t25 += v * b11;
	  t26 += v * b12;
	  t27 += v * b13;
	  t28 += v * b14;
	  t29 += v * b15;
	  v = a[15];
	  t15 += v * b0;
	  t16 += v * b1;
	  t17 += v * b2;
	  t18 += v * b3;
	  t19 += v * b4;
	  t20 += v * b5;
	  t21 += v * b6;
	  t22 += v * b7;
	  t23 += v * b8;
	  t24 += v * b9;
	  t25 += v * b10;
	  t26 += v * b11;
	  t27 += v * b12;
	  t28 += v * b13;
	  t29 += v * b14;
	  t30 += v * b15;
	
	  t0  += 38 * t16;
	  t1  += 38 * t17;
	  t2  += 38 * t18;
	  t3  += 38 * t19;
	  t4  += 38 * t20;
	  t5  += 38 * t21;
	  t6  += 38 * t22;
	  t7  += 38 * t23;
	  t8  += 38 * t24;
	  t9  += 38 * t25;
	  t10 += 38 * t26;
	  t11 += 38 * t27;
	  t12 += 38 * t28;
	  t13 += 38 * t29;
	  t14 += 38 * t30;
	  // t15 left as is
	
	  // first car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);
	
	  // second car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);
	
	  o[ 0] = t0;
	  o[ 1] = t1;
	  o[ 2] = t2;
	  o[ 3] = t3;
	  o[ 4] = t4;
	  o[ 5] = t5;
	  o[ 6] = t6;
	  o[ 7] = t7;
	  o[ 8] = t8;
	  o[ 9] = t9;
	  o[10] = t10;
	  o[11] = t11;
	  o[12] = t12;
	  o[13] = t13;
	  o[14] = t14;
	  o[15] = t15;
	}
	
	function S(o, a) {
	  M(o, a, a);
	}
	
	function inv25519(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 253; a >= 0; a--) {
	    S(c, c);
	    if(a !== 2 && a !== 4) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}
	
	function pow2523(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 250; a >= 0; a--) {
	      S(c, c);
	      if(a !== 1) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}
	
	function crypto_scalarmult(q, n, p) {
	  var z = new Uint8Array(32);
	  var x = new Float64Array(80), r, i;
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf();
	  for (i = 0; i < 31; i++) z[i] = n[i];
	  z[31]=(n[31]&127)|64;
	  z[0]&=248;
	  unpack25519(x,p);
	  for (i = 0; i < 16; i++) {
	    b[i]=x[i];
	    d[i]=a[i]=c[i]=0;
	  }
	  a[0]=d[0]=1;
	  for (i=254; i>=0; --i) {
	    r=(z[i>>>3]>>>(i&7))&1;
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	    A(e,a,c);
	    Z(a,a,c);
	    A(c,b,d);
	    Z(b,b,d);
	    S(d,e);
	    S(f,a);
	    M(a,c,a);
	    M(c,b,e);
	    A(e,a,c);
	    Z(a,a,c);
	    S(b,a);
	    Z(c,d,f);
	    M(a,c,_121665);
	    A(a,a,d);
	    M(c,c,a);
	    M(a,d,f);
	    M(d,b,x);
	    S(b,e);
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	  }
	  for (i = 0; i < 16; i++) {
	    x[i+16]=a[i];
	    x[i+32]=c[i];
	    x[i+48]=b[i];
	    x[i+64]=d[i];
	  }
	  var x32 = x.subarray(32);
	  var x16 = x.subarray(16);
	  inv25519(x32,x32);
	  M(x16,x16,x32);
	  pack25519(q,x16);
	  return 0;
	}
	
	function crypto_scalarmult_base(q, n) {
	  return crypto_scalarmult(q, n, _9);
	}
	
	function crypto_box_keypair(y, x) {
	  randombytes(x, 32);
	  return crypto_scalarmult_base(y, x);
	}
	
	function crypto_box_beforenm(k, y, x) {
	  var s = new Uint8Array(32);
	  crypto_scalarmult(s, x, y);
	  return crypto_core_hsalsa20(k, _0, s, sigma);
	}
	
	var crypto_box_afternm = crypto_secretbox;
	var crypto_box_open_afternm = crypto_secretbox_open;
	
	function crypto_box(c, m, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_afternm(c, m, d, n, k);
	}
	
	function crypto_box_open(m, c, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_open_afternm(m, c, d, n, k);
	}
	
	var K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];
	
	function crypto_hashblocks_hl(hh, hl, m, n) {
	  var wh = new Int32Array(16), wl = new Int32Array(16),
	      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
	      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
	      th, tl, i, j, h, l, a, b, c, d;
	
	  var ah0 = hh[0],
	      ah1 = hh[1],
	      ah2 = hh[2],
	      ah3 = hh[3],
	      ah4 = hh[4],
	      ah5 = hh[5],
	      ah6 = hh[6],
	      ah7 = hh[7],
	
	      al0 = hl[0],
	      al1 = hl[1],
	      al2 = hl[2],
	      al3 = hl[3],
	      al4 = hl[4],
	      al5 = hl[5],
	      al6 = hl[6],
	      al7 = hl[7];
	
	  var pos = 0;
	  while (n >= 128) {
	    for (i = 0; i < 16; i++) {
	      j = 8 * i + pos;
	      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
	      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
	    }
	    for (i = 0; i < 80; i++) {
	      bh0 = ah0;
	      bh1 = ah1;
	      bh2 = ah2;
	      bh3 = ah3;
	      bh4 = ah4;
	      bh5 = ah5;
	      bh6 = ah6;
	      bh7 = ah7;
	
	      bl0 = al0;
	      bl1 = al1;
	      bl2 = al2;
	      bl3 = al3;
	      bl4 = al4;
	      bl5 = al5;
	      bl6 = al6;
	      bl7 = al7;
	
	      // add
	      h = ah7;
	      l = al7;
	
	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;
	
	      // Sigma1
	      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
	      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // Ch
	      h = (ah4 & ah5) ^ (~ah4 & ah6);
	      l = (al4 & al5) ^ (~al4 & al6);
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // K
	      h = K[i*2];
	      l = K[i*2+1];
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // w
	      h = wh[i%16];
	      l = wl[i%16];
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;
	
	      th = c & 0xffff | d << 16;
	      tl = a & 0xffff | b << 16;
	
	      // add
	      h = th;
	      l = tl;
	
	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;
	
	      // Sigma0
	      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
	      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      // Maj
	      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
	      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;
	
	      bh7 = (c & 0xffff) | (d << 16);
	      bl7 = (a & 0xffff) | (b << 16);
	
	      // add
	      h = bh3;
	      l = bl3;
	
	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;
	
	      h = th;
	      l = tl;
	
	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;
	
	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;
	
	      bh3 = (c & 0xffff) | (d << 16);
	      bl3 = (a & 0xffff) | (b << 16);
	
	      ah1 = bh0;
	      ah2 = bh1;
	      ah3 = bh2;
	      ah4 = bh3;
	      ah5 = bh4;
	      ah6 = bh5;
	      ah7 = bh6;
	      ah0 = bh7;
	
	      al1 = bl0;
	      al2 = bl1;
	      al3 = bl2;
	      al4 = bl3;
	      al5 = bl4;
	      al6 = bl5;
	      al7 = bl6;
	      al0 = bl7;
	
	      if (i%16 === 15) {
	        for (j = 0; j < 16; j++) {
	          // add
	          h = wh[j];
	          l = wl[j];
	
	          a = l & 0xffff; b = l >>> 16;
	          c = h & 0xffff; d = h >>> 16;
	
	          h = wh[(j+9)%16];
	          l = wl[(j+9)%16];
	
	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;
	
	          // sigma0
	          th = wh[(j+1)%16];
	          tl = wl[(j+1)%16];
	          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
	          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));
	
	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;
	
	          // sigma1
	          th = wh[(j+14)%16];
	          tl = wl[(j+14)%16];
	          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
	          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));
	
	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;
	
	          b += a >>> 16;
	          c += b >>> 16;
	          d += c >>> 16;
	
	          wh[j] = (c & 0xffff) | (d << 16);
	          wl[j] = (a & 0xffff) | (b << 16);
	        }
	      }
	    }
	
	    // add
	    h = ah0;
	    l = al0;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[0];
	    l = hl[0];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[0] = ah0 = (c & 0xffff) | (d << 16);
	    hl[0] = al0 = (a & 0xffff) | (b << 16);
	
	    h = ah1;
	    l = al1;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[1];
	    l = hl[1];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[1] = ah1 = (c & 0xffff) | (d << 16);
	    hl[1] = al1 = (a & 0xffff) | (b << 16);
	
	    h = ah2;
	    l = al2;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[2];
	    l = hl[2];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[2] = ah2 = (c & 0xffff) | (d << 16);
	    hl[2] = al2 = (a & 0xffff) | (b << 16);
	
	    h = ah3;
	    l = al3;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[3];
	    l = hl[3];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[3] = ah3 = (c & 0xffff) | (d << 16);
	    hl[3] = al3 = (a & 0xffff) | (b << 16);
	
	    h = ah4;
	    l = al4;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[4];
	    l = hl[4];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[4] = ah4 = (c & 0xffff) | (d << 16);
	    hl[4] = al4 = (a & 0xffff) | (b << 16);
	
	    h = ah5;
	    l = al5;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[5];
	    l = hl[5];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[5] = ah5 = (c & 0xffff) | (d << 16);
	    hl[5] = al5 = (a & 0xffff) | (b << 16);
	
	    h = ah6;
	    l = al6;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[6];
	    l = hl[6];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[6] = ah6 = (c & 0xffff) | (d << 16);
	    hl[6] = al6 = (a & 0xffff) | (b << 16);
	
	    h = ah7;
	    l = al7;
	
	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;
	
	    h = hh[7];
	    l = hl[7];
	
	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;
	
	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;
	
	    hh[7] = ah7 = (c & 0xffff) | (d << 16);
	    hl[7] = al7 = (a & 0xffff) | (b << 16);
	
	    pos += 128;
	    n -= 128;
	  }
	
	  return n;
	}
	
	function crypto_hash(out, m, n) {
	  var hh = new Int32Array(8),
	      hl = new Int32Array(8),
	      x = new Uint8Array(256),
	      i, b = n;
	
	  hh[0] = 0x6a09e667;
	  hh[1] = 0xbb67ae85;
	  hh[2] = 0x3c6ef372;
	  hh[3] = 0xa54ff53a;
	  hh[4] = 0x510e527f;
	  hh[5] = 0x9b05688c;
	  hh[6] = 0x1f83d9ab;
	  hh[7] = 0x5be0cd19;
	
	  hl[0] = 0xf3bcc908;
	  hl[1] = 0x84caa73b;
	  hl[2] = 0xfe94f82b;
	  hl[3] = 0x5f1d36f1;
	  hl[4] = 0xade682d1;
	  hl[5] = 0x2b3e6c1f;
	  hl[6] = 0xfb41bd6b;
	  hl[7] = 0x137e2179;
	
	  crypto_hashblocks_hl(hh, hl, m, n);
	  n %= 128;
	
	  for (i = 0; i < n; i++) x[i] = m[b-n+i];
	  x[n] = 128;
	
	  n = 256-128*(n<112?1:0);
	  x[n-9] = 0;
	  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
	  crypto_hashblocks_hl(hh, hl, x, n);
	
	  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);
	
	  return 0;
	}
	
	function add(p, q) {
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf(),
	      g = gf(), h = gf(), t = gf();
	
	  Z(a, p[1], p[0]);
	  Z(t, q[1], q[0]);
	  M(a, a, t);
	  A(b, p[0], p[1]);
	  A(t, q[0], q[1]);
	  M(b, b, t);
	  M(c, p[3], q[3]);
	  M(c, c, D2);
	  M(d, p[2], q[2]);
	  A(d, d, d);
	  Z(e, b, a);
	  Z(f, d, c);
	  A(g, d, c);
	  A(h, b, a);
	
	  M(p[0], e, f);
	  M(p[1], h, g);
	  M(p[2], g, f);
	  M(p[3], e, h);
	}
	
	function cswap(p, q, b) {
	  var i;
	  for (i = 0; i < 4; i++) {
	    sel25519(p[i], q[i], b);
	  }
	}
	
	function pack(r, p) {
	  var tx = gf(), ty = gf(), zi = gf();
	  inv25519(zi, p[2]);
	  M(tx, p[0], zi);
	  M(ty, p[1], zi);
	  pack25519(r, ty);
	  r[31] ^= par25519(tx) << 7;
	}
	
	function scalarmult(p, q, s) {
	  var b, i;
	  set25519(p[0], gf0);
	  set25519(p[1], gf1);
	  set25519(p[2], gf1);
	  set25519(p[3], gf0);
	  for (i = 255; i >= 0; --i) {
	    b = (s[(i/8)|0] >> (i&7)) & 1;
	    cswap(p, q, b);
	    add(q, p);
	    add(p, p);
	    cswap(p, q, b);
	  }
	}
	
	function scalarbase(p, s) {
	  var q = [gf(), gf(), gf(), gf()];
	  set25519(q[0], X);
	  set25519(q[1], Y);
	  set25519(q[2], gf1);
	  M(q[3], X, Y);
	  scalarmult(p, q, s);
	}
	
	function crypto_sign_keypair(pk, sk, seeded) {
	  var d = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()];
	  var i;
	
	  if (!seeded) randombytes(sk, 32);
	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;
	
	  scalarbase(p, d);
	  pack(pk, p);
	
	  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
	  return 0;
	}
	
	var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);
	
	function modL(r, x) {
	  var carry, i, j, k;
	  for (i = 63; i >= 32; --i) {
	    carry = 0;
	    for (j = i - 32, k = i - 12; j < k; ++j) {
	      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
	      carry = (x[j] + 128) >> 8;
	      x[j] -= carry * 256;
	    }
	    x[j] += carry;
	    x[i] = 0;
	  }
	  carry = 0;
	  for (j = 0; j < 32; j++) {
	    x[j] += carry - (x[31] >> 4) * L[j];
	    carry = x[j] >> 8;
	    x[j] &= 255;
	  }
	  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
	  for (i = 0; i < 32; i++) {
	    x[i+1] += x[i] >> 8;
	    r[i] = x[i] & 255;
	  }
	}
	
	function reduce(r) {
	  var x = new Float64Array(64), i;
	  for (i = 0; i < 64; i++) x[i] = r[i];
	  for (i = 0; i < 64; i++) r[i] = 0;
	  modL(r, x);
	}
	
	// Note: difference from C - smlen returned, not passed as argument.
	function crypto_sign(sm, m, n, sk) {
	  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
	  var i, j, x = new Float64Array(64);
	  var p = [gf(), gf(), gf(), gf()];
	
	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;
	
	  var smlen = n + 64;
	  for (i = 0; i < n; i++) sm[64 + i] = m[i];
	  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
	
	  crypto_hash(r, sm.subarray(32), n+32);
	  reduce(r);
	  scalarbase(p, r);
	  pack(sm, p);
	
	  for (i = 32; i < 64; i++) sm[i] = sk[i];
	  crypto_hash(h, sm, n + 64);
	  reduce(h);
	
	  for (i = 0; i < 64; i++) x[i] = 0;
	  for (i = 0; i < 32; i++) x[i] = r[i];
	  for (i = 0; i < 32; i++) {
	    for (j = 0; j < 32; j++) {
	      x[i+j] += h[i] * d[j];
	    }
	  }
	
	  modL(sm.subarray(32), x);
	  return smlen;
	}
	
	function unpackneg(r, p) {
	  var t = gf(), chk = gf(), num = gf(),
	      den = gf(), den2 = gf(), den4 = gf(),
	      den6 = gf();
	
	  set25519(r[2], gf1);
	  unpack25519(r[1], p);
	  S(num, r[1]);
	  M(den, num, D);
	  Z(num, num, r[2]);
	  A(den, r[2], den);
	
	  S(den2, den);
	  S(den4, den2);
	  M(den6, den4, den2);
	  M(t, den6, num);
	  M(t, t, den);
	
	  pow2523(t, t);
	  M(t, t, num);
	  M(t, t, den);
	  M(t, t, den);
	  M(r[0], t, den);
	
	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) M(r[0], r[0], I);
	
	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) return -1;
	
	  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);
	
	  M(r[3], r[0], r[1]);
	  return 0;
	}
	
	function crypto_sign_open(m, sm, n, pk) {
	  var i, mlen;
	  var t = new Uint8Array(32), h = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()],
	      q = [gf(), gf(), gf(), gf()];
	
	  mlen = -1;
	  if (n < 64) return -1;
	
	  if (unpackneg(q, pk)) return -1;
	
	  for (i = 0; i < n; i++) m[i] = sm[i];
	  for (i = 0; i < 32; i++) m[i+32] = pk[i];
	  crypto_hash(h, m, n);
	  reduce(h);
	  scalarmult(p, q, h);
	
	  scalarbase(q, sm.subarray(32));
	  add(p, q);
	  pack(t, p);
	
	  n -= 64;
	  if (crypto_verify_32(sm, 0, t, 0)) {
	    for (i = 0; i < n; i++) m[i] = 0;
	    return -1;
	  }
	
	  for (i = 0; i < n; i++) m[i] = sm[i + 64];
	  mlen = n;
	  return mlen;
	}
	
	var crypto_secretbox_KEYBYTES = 32,
	    crypto_secretbox_NONCEBYTES = 24,
	    crypto_secretbox_ZEROBYTES = 32,
	    crypto_secretbox_BOXZEROBYTES = 16,
	    crypto_scalarmult_BYTES = 32,
	    crypto_scalarmult_SCALARBYTES = 32,
	    crypto_box_PUBLICKEYBYTES = 32,
	    crypto_box_SECRETKEYBYTES = 32,
	    crypto_box_BEFORENMBYTES = 32,
	    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
	    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
	    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
	    crypto_sign_BYTES = 64,
	    crypto_sign_PUBLICKEYBYTES = 32,
	    crypto_sign_SECRETKEYBYTES = 64,
	    crypto_sign_SEEDBYTES = 32,
	    crypto_hash_BYTES = 64;
	
	nacl.lowlevel = {
	  crypto_core_hsalsa20: crypto_core_hsalsa20,
	  crypto_stream_xor: crypto_stream_xor,
	  crypto_stream: crypto_stream,
	  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
	  crypto_stream_salsa20: crypto_stream_salsa20,
	  crypto_onetimeauth: crypto_onetimeauth,
	  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
	  crypto_verify_16: crypto_verify_16,
	  crypto_verify_32: crypto_verify_32,
	  crypto_secretbox: crypto_secretbox,
	  crypto_secretbox_open: crypto_secretbox_open,
	  crypto_scalarmult: crypto_scalarmult,
	  crypto_scalarmult_base: crypto_scalarmult_base,
	  crypto_box_beforenm: crypto_box_beforenm,
	  crypto_box_afternm: crypto_box_afternm,
	  crypto_box: crypto_box,
	  crypto_box_open: crypto_box_open,
	  crypto_box_keypair: crypto_box_keypair,
	  crypto_hash: crypto_hash,
	  crypto_sign: crypto_sign,
	  crypto_sign_keypair: crypto_sign_keypair,
	  crypto_sign_open: crypto_sign_open,
	
	  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
	  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
	  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
	  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
	  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
	  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
	  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
	  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
	  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
	  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
	  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
	  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
	  crypto_sign_BYTES: crypto_sign_BYTES,
	  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
	  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
	  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
	  crypto_hash_BYTES: crypto_hash_BYTES
	};
	
	/* High-level API */
	
	function checkLengths(k, n) {
	  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
	  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
	}
	
	function checkBoxLengths(pk, sk) {
	  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
	  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
	}
	
	function checkArrayTypes() {
	  var t, i;
	  for (i = 0; i < arguments.length; i++) {
	     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
	       throw new TypeError('unexpected type ' + t + ', use Uint8Array');
	  }
	}
	
	function cleanup(arr) {
	  for (var i = 0; i < arr.length; i++) arr[i] = 0;
	}
	
	nacl.util = {};
	
	nacl.util.decodeUTF8 = function(s) {
	  var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
	  for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	  return b;
	};
	
	nacl.util.encodeUTF8 = function(arr) {
	  var i, s = [];
	  for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
	  return decodeURIComponent(escape(s.join('')));
	};
	
	nacl.util.encodeBase64 = function(arr) {
	  if (typeof btoa === 'undefined') {
	    return (new Buffer(arr)).toString('base64');
	  } else {
	    var i, s = [], len = arr.length;
	    for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
	    return btoa(s.join(''));
	  }
	};
	
	nacl.util.decodeBase64 = function(s) {
	  if (typeof atob === 'undefined') {
	    return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
	  } else {
	    var i, d = atob(s), b = new Uint8Array(d.length);
	    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	    return b;
	  }
	};
	
	nacl.randomBytes = function(n) {
	  var b = new Uint8Array(n);
	  randombytes(b, n);
	  return b;
	};
	
	nacl.secretbox = function(msg, nonce, key) {
	  checkArrayTypes(msg, nonce, key);
	  checkLengths(key, nonce);
	  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
	  var c = new Uint8Array(m.length);
	  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
	  crypto_secretbox(c, m, m.length, nonce, key);
	  return c.subarray(crypto_secretbox_BOXZEROBYTES);
	};
	
	nacl.secretbox.open = function(box, nonce, key) {
	  checkArrayTypes(box, nonce, key);
	  checkLengths(key, nonce);
	  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
	  var m = new Uint8Array(c.length);
	  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
	  if (c.length < 32) return false;
	  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
	  return m.subarray(crypto_secretbox_ZEROBYTES);
	};
	
	nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
	nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
	nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
	
	nacl.scalarMult = function(n, p) {
	  checkArrayTypes(n, p);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult(q, n, p);
	  return q;
	};
	
	nacl.scalarMult.base = function(n) {
	  checkArrayTypes(n);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult_base(q, n);
	  return q;
	};
	
	nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
	nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
	
	nacl.box = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox(msg, nonce, k);
	};
	
	nacl.box.before = function(publicKey, secretKey) {
	  checkArrayTypes(publicKey, secretKey);
	  checkBoxLengths(publicKey, secretKey);
	  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
	  crypto_box_beforenm(k, publicKey, secretKey);
	  return k;
	};
	
	nacl.box.after = nacl.secretbox;
	
	nacl.box.open = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox.open(msg, nonce, k);
	};
	
	nacl.box.open.after = nacl.secretbox.open;
	
	nacl.box.keyPair = function() {
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
	  crypto_box_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};
	
	nacl.box.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  crypto_scalarmult_base(pk, secretKey);
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};
	
	nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
	nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
	nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
	nacl.box.nonceLength = crypto_box_NONCEBYTES;
	nacl.box.overheadLength = nacl.secretbox.overheadLength;
	
	nacl.sign = function(msg, secretKey) {
	  checkArrayTypes(msg, secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
	  crypto_sign(signedMsg, msg, msg.length, secretKey);
	  return signedMsg;
	};
	
	nacl.sign.open = function(signedMsg, publicKey) {
	  if (arguments.length !== 2)
	    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
	  checkArrayTypes(signedMsg, publicKey);
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var tmp = new Uint8Array(signedMsg.length);
	  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
	  if (mlen < 0) return null;
	  var m = new Uint8Array(mlen);
	  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
	  return m;
	};
	
	nacl.sign.detached = function(msg, secretKey) {
	  var signedMsg = nacl.sign(msg, secretKey);
	  var sig = new Uint8Array(crypto_sign_BYTES);
	  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
	  return sig;
	};
	
	nacl.sign.detached.verify = function(msg, sig, publicKey) {
	  checkArrayTypes(msg, sig, publicKey);
	  if (sig.length !== crypto_sign_BYTES)
	    throw new Error('bad signature size');
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var i;
	  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
	  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
	  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
	};
	
	nacl.sign.keyPair = function() {
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  crypto_sign_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};
	
	nacl.sign.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};
	
	nacl.sign.keyPair.fromSeed = function(seed) {
	  checkArrayTypes(seed);
	  if (seed.length !== crypto_sign_SEEDBYTES)
	    throw new Error('bad seed size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  for (var i = 0; i < 32; i++) sk[i] = seed[i];
	  crypto_sign_keypair(pk, sk, true);
	  return {publicKey: pk, secretKey: sk};
	};
	
	nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
	nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
	nacl.sign.seedLength = crypto_sign_SEEDBYTES;
	nacl.sign.signatureLength = crypto_sign_BYTES;
	
	nacl.hash = function(msg) {
	  checkArrayTypes(msg);
	  var h = new Uint8Array(crypto_hash_BYTES);
	  crypto_hash(h, msg, msg.length);
	  return h;
	};
	
	nacl.hash.hashLength = crypto_hash_BYTES;
	
	nacl.verify = function(x, y) {
	  checkArrayTypes(x, y);
	  // Zero length arguments are considered not equal.
	  if (x.length === 0 || y.length === 0) return false;
	  if (x.length !== y.length) return false;
	  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
	};
	
	nacl.setPRNG = function(fn) {
	  randombytes = fn;
	};
	
	(function() {
	  // Initialize PRNG if environment provides CSPRNG.
	  // If not, methods calling randombytes will throw.
	  var crypto;
	  if (typeof window !== 'undefined') {
	    // Browser.
	    if (window.crypto && window.crypto.getRandomValues) {
	      crypto = window.crypto; // Standard
	    } else if (window.msCrypto && window.msCrypto.getRandomValues) {
	      crypto = window.msCrypto; // Internet Explorer 11+
	    }
	    if (crypto) {
	      nacl.setPRNG(function(x, n) {
	        var i, v = new Uint8Array(n);
	        crypto.getRandomValues(v);
	        for (i = 0; i < n; i++) x[i] = v[i];
	        cleanup(v);
	      });
	    }
	  } else if (true) {
	    // Node.js.
	    crypto = __webpack_require__(/*! crypto */ 601);
	    if (crypto) {
	      nacl.setPRNG(function(x, n) {
	        var i, v = crypto.randomBytes(n);
	        for (i = 0; i < n; i++) x[i] = v[i];
	        cleanup(v);
	      });
	    }
	  }
	})();
	
	})(typeof module !== 'undefined' && module.exports ? module.exports : (window.nacl = window.nacl || {}));


/***/ },
/* 654 */
/*!*************************************!*\
  !*** ./~/sshpk/lib/formats/auto.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		read: read,
		write: write
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var utils = __webpack_require__(/*! ../utils */ 642);
	var Key = __webpack_require__(/*! ../key */ 638);
	var PrivateKey = __webpack_require__(/*! ../private-key */ 643);
	
	var pem = __webpack_require__(/*! ./pem */ 655);
	var ssh = __webpack_require__(/*! ./ssh */ 660);
	var rfc4253 = __webpack_require__(/*! ./rfc4253 */ 659);
	
	function read(buf, options) {
		if (typeof (buf) === 'string') {
			if (buf.trim().match(/^[-]+[ ]*BEGIN/))
				return (pem.read(buf, options));
			if (buf.match(/^\s*ssh-[a-z]/))
				return (ssh.read(buf, options));
			if (buf.match(/^\s*ecdsa-/))
				return (ssh.read(buf, options));
			buf = new Buffer(buf, 'binary');
		} else {
			assert.buffer(buf);
			if (findPEMHeader(buf))
				return (pem.read(buf, options));
			if (findSSHHeader(buf))
				return (ssh.read(buf, options));
		}
		if (buf.readUInt32BE(0) < buf.length)
			return (rfc4253.read(buf, options));
		throw (new Error('Failed to auto-detect format of key'));
	}
	
	function findSSHHeader(buf) {
		var offset = 0;
		while (offset < buf.length &&
		    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
			++offset;
		if (offset + 4 <= buf.length &&
		    buf.slice(offset, offset + 4).toString('ascii') === 'ssh-')
			return (true);
		if (offset + 6 <= buf.length &&
		    buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')
			return (true);
		return (false);
	}
	
	function findPEMHeader(buf) {
		var offset = 0;
		while (offset < buf.length &&
		    (buf[offset] === 32 || buf[offset] === 10))
			++offset;
		if (buf[offset] !== 45)
			return (false);
		while (offset < buf.length &&
		    (buf[offset] === 45))
			++offset;
		while (offset < buf.length &&
		    (buf[offset] === 32))
			++offset;
		if (offset + 5 > buf.length ||
		    buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN')
			return (false);
		return (true);
	}
	
	function write(key, options) {
		throw (new Error('"auto" format cannot be used for writing'));
	}


/***/ },
/* 655 */
/*!************************************!*\
  !*** ./~/sshpk/lib/formats/pem.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		read: read,
		write: write
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var asn1 = __webpack_require__(/*! asn1 */ 645);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var algs = __webpack_require__(/*! ../algs */ 639);
	var utils = __webpack_require__(/*! ../utils */ 642);
	var Key = __webpack_require__(/*! ../key */ 638);
	var PrivateKey = __webpack_require__(/*! ../private-key */ 643);
	
	var pkcs1 = __webpack_require__(/*! ./pkcs1 */ 656);
	var pkcs8 = __webpack_require__(/*! ./pkcs8 */ 657);
	var sshpriv = __webpack_require__(/*! ./ssh-private */ 658);
	var rfc4253 = __webpack_require__(/*! ./rfc4253 */ 659);
	
	var errors = __webpack_require__(/*! ../errors */ 641);
	
	/*
	 * For reading we support both PKCS#1 and PKCS#8. If we find a private key,
	 * we just take the public component of it and use that.
	 */
	function read(buf, options, forceType) {
		var input = buf;
		if (typeof (buf) !== 'string') {
			assert.buffer(buf, 'buf');
			buf = buf.toString('ascii');
		}
	
		var lines = buf.trim().split('\n');
	
		var m = lines[0].match(/*JSSTYLED*/
		    /[-]+[ ]*BEGIN ([A-Z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
		assert.ok(m, 'invalid PEM header');
	
		var m2 = lines[lines.length - 1].match(/*JSSTYLED*/
		    /[-]+[ ]*END ([A-Z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
		assert.ok(m2, 'invalid PEM footer');
	
		/* Begin and end banners must match key type */
		assert.equal(m[2], m2[2]);
		var type = m[2].toLowerCase();
	
		var alg;
		if (m[1]) {
			/* They also must match algorithms, if given */
			assert.equal(m[1], m2[1], 'PEM header and footer mismatch');
			alg = m[1].trim();
		}
	
		var headers = {};
		while (true) {
			lines = lines.slice(1);
			m = lines[0].match(/*JSSTYLED*/
			    /^([A-Za-z0-9-]+): (.+)$/);
			if (!m)
				break;
			headers[m[1].toLowerCase()] = m[2];
		}
	
		var cipher, key, iv;
		if (headers['proc-type']) {
			var parts = headers['proc-type'].split(',');
			if (parts[0] === '4' && parts[1] === 'ENCRYPTED') {
				if (typeof (options.passphrase) === 'string') {
					options.passphrase = new Buffer(
					    options.passphrase, 'utf-8');
				}
				if (!Buffer.isBuffer(options.passphrase)) {
					throw (new errors.KeyEncryptedError(
					    options.filename, 'PEM'));
				} else {
					parts = headers['dek-info'].split(',');
					assert.ok(parts.length === 2);
					cipher = parts[0].toLowerCase();
					iv = new Buffer(parts[1], 'hex');
					key = utils.opensslKeyDeriv(cipher, iv,
					    options.passphrase, 1).key;
				}
			}
		}
	
		/* Chop off the first and last lines */
		lines = lines.slice(0, -1).join('');
		buf = new Buffer(lines, 'base64');
	
		if (cipher && key && iv) {
			var cipherStream = crypto.createDecipheriv(cipher, key, iv);
			var chunk, chunks = [];
			cipherStream.once('error', function (e) {
				if (e.toString().indexOf('bad decrypt') !== -1) {
					throw (new Error('Incorrect passphrase ' +
					    'supplied, could not decrypt key'));
				}
				throw (e);
			});
			cipherStream.write(buf);
			cipherStream.end();
			while ((chunk = cipherStream.read()) !== null)
				chunks.push(chunk);
			buf = Buffer.concat(chunks);
		}
	
		/* The new OpenSSH internal format abuses PEM headers */
		if (alg && alg.toLowerCase() === 'openssh')
			return (sshpriv.readSSHPrivate(type, buf));
		if (alg && alg.toLowerCase() === 'ssh2')
			return (rfc4253.readType(type, buf));
	
		var der = new asn1.BerReader(buf);
		der.originalInput = input;
	
		/*
		 * All of the PEM file types start with a sequence tag, so chop it
		 * off here
		 */
		der.readSequence();
	
		/* PKCS#1 type keys name an algorithm in the banner explicitly */
		if (alg) {
			if (forceType)
				assert.strictEqual(forceType, 'pkcs1');
			return (pkcs1.readPkcs1(alg, type, der));
		} else {
			if (forceType)
				assert.strictEqual(forceType, 'pkcs8');
			return (pkcs8.readPkcs8(alg, type, der));
		}
	}
	
	function write(key, options, type) {
		assert.object(key);
	
		var alg = {'ecdsa': 'EC', 'rsa': 'RSA', 'dsa': 'DSA'}[key.type];
		var header;
	
		var der = new asn1.BerWriter();
	
		if (PrivateKey.isPrivateKey(key)) {
			if (type && type === 'pkcs8') {
				header = 'PRIVATE KEY';
				pkcs8.writePkcs8(der, key);
			} else {
				if (type)
					assert.strictEqual(type, 'pkcs1');
				header = alg + ' PRIVATE KEY';
				pkcs1.writePkcs1(der, key);
			}
	
		} else if (Key.isKey(key)) {
			if (type && type === 'pkcs1') {
				header = alg + ' PUBLIC KEY';
				pkcs1.writePkcs1(der, key);
			} else {
				if (type)
					assert.strictEqual(type, 'pkcs8');
				header = 'PUBLIC KEY';
				pkcs8.writePkcs8(der, key);
			}
	
		} else {
			throw (new Error('key is not a Key or PrivateKey'));
		}
	
		var tmp = der.buffer.toString('base64');
		var len = tmp.length + (tmp.length / 64) +
		    18 + 16 + header.length*2 + 10;
		var buf = new Buffer(len);
		var o = 0;
		o += buf.write('-----BEGIN ' + header + '-----\n', o);
		for (var i = 0; i < tmp.length; ) {
			var limit = i + 64;
			if (limit > tmp.length)
				limit = tmp.length;
			o += buf.write(tmp.slice(i, limit), o);
			buf[o++] = 10;
			i = limit;
		}
		o += buf.write('-----END ' + header + '-----\n', o);
	
		return (buf.slice(0, o));
	}


/***/ },
/* 656 */
/*!**************************************!*\
  !*** ./~/sshpk/lib/formats/pkcs1.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		read: read,
		readPkcs1: readPkcs1,
		write: write,
		writePkcs1: writePkcs1
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var asn1 = __webpack_require__(/*! asn1 */ 645);
	var algs = __webpack_require__(/*! ../algs */ 639);
	var utils = __webpack_require__(/*! ../utils */ 642);
	
	var Key = __webpack_require__(/*! ../key */ 638);
	var PrivateKey = __webpack_require__(/*! ../private-key */ 643);
	var pem = __webpack_require__(/*! ./pem */ 655);
	
	var pkcs8 = __webpack_require__(/*! ./pkcs8 */ 657);
	var readECDSACurve = pkcs8.readECDSACurve;
	
	function read(buf, options) {
		return (pem.read(buf, options, 'pkcs1'));
	}
	
	function write(key, options) {
		return (pem.write(key, options, 'pkcs1'));
	}
	
	/* Helper to read in a single mpint */
	function readMPInt(der, nm) {
		assert.strictEqual(der.peek(), asn1.Ber.Integer,
		    nm + ' is not an Integer');
		return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
	}
	
	function readPkcs1(alg, type, der) {
		switch (alg) {
		case 'RSA':
			if (type === 'public')
				return (readPkcs1RSAPublic(der));
			else if (type === 'private')
				return (readPkcs1RSAPrivate(der));
			throw (new Error('Unknown key type: ' + type));
		case 'DSA':
			if (type === 'public')
				return (readPkcs1DSAPublic(der));
			else if (type === 'private')
				return (readPkcs1DSAPrivate(der));
			throw (new Error('Unknown key type: ' + type));
		case 'EC':
		case 'ECDSA':
			if (type === 'private')
				return (readPkcs1ECDSAPrivate(der));
			else if (type === 'public')
				return (readPkcs1ECDSAPublic(der));
			throw (new Error('Unknown key type: ' + type));
		default:
			throw (new Error('Unknown key algo: ' + alg));
		}
	}
	
	function readPkcs1RSAPublic(der) {
		// modulus and exponent
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'exponent');
	
		// now, make the key
		var key = {
			type: 'rsa',
			parts: [
				{ name: 'e', data: e },
				{ name: 'n', data: n }
			]
		};
	
		return (new Key(key));
	}
	
	function readPkcs1RSAPrivate(der) {
		var version = readMPInt(der, 'version');
		assert.strictEqual(version[0], 0);
	
		// modulus then public exponent
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'public exponent');
		var d = readMPInt(der, 'private exponent');
		var p = readMPInt(der, 'prime1');
		var q = readMPInt(der, 'prime2');
		var dmodp = readMPInt(der, 'exponent1');
		var dmodq = readMPInt(der, 'exponent2');
		var iqmp = readMPInt(der, 'iqmp');
	
		// now, make the key
		var key = {
			type: 'rsa',
			parts: [
				{ name: 'n', data: n },
				{ name: 'e', data: e },
				{ name: 'd', data: d },
				{ name: 'iqmp', data: iqmp },
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'dmodp', data: dmodp },
				{ name: 'dmodq', data: dmodq }
			]
		};
	
		return (new PrivateKey(key));
	}
	
	function readPkcs1DSAPrivate(der) {
		var version = readMPInt(der, 'version');
		assert.strictEqual(version.readUInt8(0), 0);
	
		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');
		var y = readMPInt(der, 'y');
		var x = readMPInt(der, 'x');
	
		// now, make the key
		var key = {
			type: 'dsa',
			parts: [
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g },
				{ name: 'y', data: y },
				{ name: 'x', data: x }
			]
		};
	
		return (new PrivateKey(key));
	}
	
	function readPkcs1DSAPublic(der) {
		var y = readMPInt(der, 'y');
		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');
	
		var key = {
			type: 'dsa',
			parts: [
				{ name: 'y', data: y },
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g }
			]
		};
	
		return (new Key(key));
	}
	
	function readPkcs1ECDSAPublic(der) {
		der.readSequence();
	
		var oid = der.readOID();
		assert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');
	
		var curveOid = der.readOID();
	
		var curve;
		var curves = Object.keys(algs.curves);
		for (var j = 0; j < curves.length; ++j) {
			var c = curves[j];
			var cd = algs.curves[c];
			if (cd.pkcs8oid === curveOid) {
				curve = c;
				break;
			}
		}
		assert.string(curve, 'a known ECDSA named curve');
	
		var Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);
	
		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: new Buffer(curve) },
				{ name: 'Q', data: Q }
			]
		};
	
		return (new Key(key));
	}
	
	function readPkcs1ECDSAPrivate(der) {
		var version = readMPInt(der, 'version');
		assert.strictEqual(version.readUInt8(0), 1);
	
		// private key
		var d = der.readString(asn1.Ber.OctetString, true);
	
		der.readSequence(0xa0);
		var curve = readECDSACurve(der);
		assert.string(curve, 'a known elliptic curve');
	
		der.readSequence(0xa1);
		var Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);
	
		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: new Buffer(curve) },
				{ name: 'Q', data: Q },
				{ name: 'd', data: d }
			]
		};
	
		return (new PrivateKey(key));
	}
	
	function writePkcs1(der, key) {
		der.startSequence();
	
		switch (key.type) {
		case 'rsa':
			if (PrivateKey.isPrivateKey(key))
				writePkcs1RSAPrivate(der, key);
			else
				writePkcs1RSAPublic(der, key);
			break;
		case 'dsa':
			if (PrivateKey.isPrivateKey(key))
				writePkcs1DSAPrivate(der, key);
			else
				writePkcs1DSAPublic(der, key);
			break;
		case 'ecdsa':
			if (PrivateKey.isPrivateKey(key))
				writePkcs1ECDSAPrivate(der, key);
			else
				writePkcs1ECDSAPublic(der, key);
			break;
		default:
			throw (new Error('Unknown key algo: ' + key.type));
		}
	
		der.endSequence();
	}
	
	function writePkcs1RSAPublic(der, key) {
		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
	}
	
	function writePkcs1RSAPrivate(der, key) {
		var ver = new Buffer(1);
		ver[0] = 0;
		der.writeBuffer(ver, asn1.Ber.Integer);
	
		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		if (!key.part.dmodp || !key.part.dmodq)
			utils.addRSAMissing(key);
		der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
	}
	
	function writePkcs1DSAPrivate(der, key) {
		var ver = new Buffer(1);
		ver[0] = 0;
		der.writeBuffer(ver, asn1.Ber.Integer);
	
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
	}
	
	function writePkcs1DSAPublic(der, key) {
		der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
	}
	
	function writePkcs1ECDSAPublic(der, key) {
		der.startSequence();
	
		der.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */
		var curve = key.part.curve.data.toString();
		var curveOid = algs.curves[curve].pkcs8oid;
		assert.string(curveOid, 'a known ECDSA named curve');
		der.writeOID(curveOid);
	
		der.endSequence();
	
		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
	}
	
	function writePkcs1ECDSAPrivate(der, key) {
		var ver = new Buffer(1);
		ver[0] = 1;
		der.writeBuffer(ver, asn1.Ber.Integer);
	
		der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
	
		der.startSequence(0xa0);
		var curve = key.part.curve.data.toString();
		var curveOid = algs.curves[curve].pkcs8oid;
		assert.string(curveOid, 'a known ECDSA named curve');
		der.writeOID(curveOid);
		der.endSequence();
	
		der.startSequence(0xa1);
		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
		der.endSequence();
	}


/***/ },
/* 657 */
/*!**************************************!*\
  !*** ./~/sshpk/lib/formats/pkcs8.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		read: read,
		readPkcs8: readPkcs8,
		write: write,
		writePkcs8: writePkcs8,
	
		readECDSACurve: readECDSACurve,
		writeECDSACurve: writeECDSACurve
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var asn1 = __webpack_require__(/*! asn1 */ 645);
	var algs = __webpack_require__(/*! ../algs */ 639);
	var utils = __webpack_require__(/*! ../utils */ 642);
	var Key = __webpack_require__(/*! ../key */ 638);
	var PrivateKey = __webpack_require__(/*! ../private-key */ 643);
	var pem = __webpack_require__(/*! ./pem */ 655);
	
	function read(buf, options) {
		return (pem.read(buf, options, 'pkcs8'));
	}
	
	function write(key, options) {
		return (pem.write(key, options, 'pkcs8'));
	}
	
	/* Helper to read in a single mpint */
	function readMPInt(der, nm) {
		assert.strictEqual(der.peek(), asn1.Ber.Integer,
		    nm + ' is not an Integer');
		return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
	}
	
	function readPkcs8(alg, type, der) {
		/* Private keys in pkcs#8 format have a weird extra int */
		if (der.peek() === asn1.Ber.Integer) {
			assert.strictEqual(type, 'private',
			    'unexpected Integer at start of public key');
			der.readString(asn1.Ber.Integer, true);
		}
	
		der.readSequence();
	
		var oid = der.readOID();
		switch (oid) {
		case '1.2.840.113549.1.1.1':
			if (type === 'public')
				return (readPkcs8RSAPublic(der));
			else
				return (readPkcs8RSAPrivate(der));
		case '1.2.840.10040.4.1':
			if (type === 'public')
				return (readPkcs8DSAPublic(der));
			else
				return (readPkcs8DSAPrivate(der));
		case '1.2.840.10045.2.1':
			if (type === 'public')
				return (readPkcs8ECDSAPublic(der));
			else
				return (readPkcs8ECDSAPrivate(der));
		default:
			throw (new Error('Unknown key type OID ' + oid));
		}
	}
	
	function readPkcs8RSAPublic(der) {
		// Null -- XXX this probably isn't good practice
		der.readByte();
		der.readByte();
	
		// bit string sequence
		der.readSequence(asn1.Ber.BitString);
		der.readByte();
		der.readSequence();
	
		// modulus
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'exponent');
	
		// now, make the key
		var key = {
			type: 'rsa',
			source: der.originalInput,
			parts: [
				{ name: 'e', data: e },
				{ name: 'n', data: n }
			]
		};
	
		return (new Key(key));
	}
	
	function readPkcs8RSAPrivate(der) {
		der.readByte();
		der.readByte();
	
		der.readSequence(asn1.Ber.OctetString);
		der.readSequence();
	
		var ver = readMPInt(der, 'version');
		assert.equal(ver[0], 0x0, 'unknown RSA private key version');
	
		// modulus then public exponent
		var n = readMPInt(der, 'modulus');
		var e = readMPInt(der, 'public exponent');
		var d = readMPInt(der, 'private exponent');
		var p = readMPInt(der, 'prime1');
		var q = readMPInt(der, 'prime2');
		var dmodp = readMPInt(der, 'exponent1');
		var dmodq = readMPInt(der, 'exponent2');
		var iqmp = readMPInt(der, 'iqmp');
	
		// now, make the key
		var key = {
			type: 'rsa',
			parts: [
				{ name: 'n', data: n },
				{ name: 'e', data: e },
				{ name: 'd', data: d },
				{ name: 'iqmp', data: iqmp },
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'dmodp', data: dmodp },
				{ name: 'dmodq', data: dmodq }
			]
		};
	
		return (new PrivateKey(key));
	}
	
	function readPkcs8DSAPublic(der) {
		der.readSequence();
	
		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');
	
		// bit string sequence
		der.readSequence(asn1.Ber.BitString);
		der.readByte();
	
		var y = readMPInt(der, 'y');
	
		// now, make the key
		var key = {
			type: 'dsa',
			parts: [
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g },
				{ name: 'y', data: y }
			]
		};
	
		return (new Key(key));
	}
	
	function readPkcs8DSAPrivate(der) {
		der.readSequence();
	
		var p = readMPInt(der, 'p');
		var q = readMPInt(der, 'q');
		var g = readMPInt(der, 'g');
	
		der.readSequence(asn1.Ber.OctetString);
		var x = readMPInt(der, 'x');
	
		/* The pkcs#8 format does not include the public key */
		var y = utils.calculateDSAPublic(g, p, x);
	
		var key = {
			type: 'dsa',
			parts: [
				{ name: 'p', data: p },
				{ name: 'q', data: q },
				{ name: 'g', data: g },
				{ name: 'y', data: y },
				{ name: 'x', data: x }
			]
		};
	
		return (new PrivateKey(key));
	}
	
	function readECDSACurve(der) {
		var curveName, curveNames;
		var j, c, cd;
	
		if (der.peek() === asn1.Ber.OID) {
			var oid = der.readOID();
	
			curveNames = Object.keys(algs.curves);
			for (j = 0; j < curveNames.length; ++j) {
				c = curveNames[j];
				cd = algs.curves[c];
				if (cd.pkcs8oid === oid) {
					curveName = c;
					break;
				}
			}
	
		} else {
			// ECParameters sequence
			der.readSequence();
			var version = der.readString(asn1.Ber.Integer, true);
			assert.strictEqual(version[0], 1, 'ECDSA key not version 1');
	
			var curve = {};
	
			// FieldID sequence
			der.readSequence();
			var fieldTypeOid = der.readOID();
			assert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',
			    'ECDSA key is not from a prime-field');
			var p = curve.p = utils.mpNormalize(
			    der.readString(asn1.Ber.Integer, true));
			/*
			 * p always starts with a 1 bit, so count the zeros to get its
			 * real size.
			 */
			curve.size = p.length * 8 - utils.countZeros(p);
	
			// Curve sequence
			der.readSequence();
			curve.a = utils.mpNormalize(
			    der.readString(asn1.Ber.OctetString, true));
			curve.b = utils.mpNormalize(
			    der.readString(asn1.Ber.OctetString, true));
			if (der.peek() === asn1.Ber.BitString)
				curve.s = der.readString(asn1.Ber.BitString, true);
	
			// Combined Gx and Gy
			curve.G = der.readString(asn1.Ber.OctetString, true);
			assert.strictEqual(curve.G[0], 0x4,
			    'uncompressed G is required');
	
			curve.n = utils.mpNormalize(
			    der.readString(asn1.Ber.Integer, true));
			curve.h = utils.mpNormalize(
			    der.readString(asn1.Ber.Integer, true));
			assert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +
			    'required');
	
			curveNames = Object.keys(algs.curves);
			var ks = Object.keys(curve);
			for (j = 0; j < curveNames.length; ++j) {
				c = curveNames[j];
				cd = algs.curves[c];
				var equal = true;
				for (var i = 0; i < ks.length; ++i) {
					var k = ks[i];
					if (cd[k] === undefined)
						continue;
					if (typeof (cd[k]) === 'object' &&
					    cd[k].equals !== undefined) {
						if (!cd[k].equals(curve[k])) {
							equal = false;
							break;
						}
					} else if (Buffer.isBuffer(cd[k])) {
						if (cd[k].toString('binary')
						    !== curve[k].toString('binary')) {
							equal = false;
							break;
						}
					} else {
						if (cd[k] !== curve[k]) {
							equal = false;
							break;
						}
					}
				}
				if (equal) {
					curveName = c;
					break;
				}
			}
		}
		return (curveName);
	}
	
	function readPkcs8ECDSAPrivate(der) {
		var curveName = readECDSACurve(der);
		assert.string(curveName, 'a known elliptic curve');
	
		der.readSequence(asn1.Ber.OctetString);
		der.readSequence();
	
		var version = readMPInt(der, 'version');
		assert.equal(version[0], 1, 'unknown version of ECDSA key');
	
		var d = der.readString(asn1.Ber.OctetString, true);
		der.readSequence(0xa1);
	
		var Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);
	
		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: new Buffer(curveName) },
				{ name: 'Q', data: Q },
				{ name: 'd', data: d }
			]
		};
	
		return (new PrivateKey(key));
	}
	
	function readPkcs8ECDSAPublic(der) {
		var curveName = readECDSACurve(der);
		assert.string(curveName, 'a known elliptic curve');
	
		var Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);
	
		var key = {
			type: 'ecdsa',
			parts: [
				{ name: 'curve', data: new Buffer(curveName) },
				{ name: 'Q', data: Q }
			]
		};
	
		return (new Key(key));
	}
	
	function writePkcs8(der, key) {
		der.startSequence();
	
		if (PrivateKey.isPrivateKey(key)) {
			var sillyInt = new Buffer(1);
			sillyInt[0] = 0x0;
			der.writeBuffer(sillyInt, asn1.Ber.Integer);
		}
	
		der.startSequence();
		switch (key.type) {
		case 'rsa':
			der.writeOID('1.2.840.113549.1.1.1');
			if (PrivateKey.isPrivateKey(key))
				writePkcs8RSAPrivate(key, der);
			else
				writePkcs8RSAPublic(key, der);
			break;
		case 'dsa':
			der.writeOID('1.2.840.10040.4.1');
			if (PrivateKey.isPrivateKey(key))
				writePkcs8DSAPrivate(key, der);
			else
				writePkcs8DSAPublic(key, der);
			break;
		case 'ecdsa':
			der.writeOID('1.2.840.10045.2.1');
			if (PrivateKey.isPrivateKey(key))
				writePkcs8ECDSAPrivate(key, der);
			else
				writePkcs8ECDSAPublic(key, der);
			break;
		default:
			throw (new Error('Unsupported key type: ' + key.type));
		}
	
		der.endSequence();
	}
	
	function writePkcs8RSAPrivate(key, der) {
		der.writeNull();
		der.endSequence();
	
		der.startSequence(asn1.Ber.OctetString);
		der.startSequence();
	
		var version = new Buffer(1);
		version[0] = 0;
		der.writeBuffer(version, asn1.Ber.Integer);
	
		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		if (!key.part.dmodp || !key.part.dmodq)
			utils.addRSAMissing(key);
		der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
	
		der.endSequence();
		der.endSequence();
	}
	
	function writePkcs8RSAPublic(key, der) {
		der.writeNull();
		der.endSequence();
	
		der.startSequence(asn1.Ber.BitString);
		der.writeByte(0x00);
	
		der.startSequence();
		der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
		der.endSequence();
	
		der.endSequence();
	}
	
	function writePkcs8DSAPrivate(key, der) {
		der.startSequence();
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
		der.endSequence();
	
		der.endSequence();
	
		der.startSequence(asn1.Ber.OctetString);
		der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
		der.endSequence();
	}
	
	function writePkcs8DSAPublic(key, der) {
		der.startSequence();
		der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
		der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
		der.endSequence();
		der.endSequence();
	
		der.startSequence(asn1.Ber.BitString);
		der.writeByte(0x00);
		der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
		der.endSequence();
	}
	
	function writeECDSACurve(key, der) {
		var curve = algs.curves[key.curve];
		if (curve.pkcs8oid) {
			/* This one has a name in pkcs#8, so just write the oid */
			der.writeOID(curve.pkcs8oid);
	
		} else {
			// ECParameters sequence
			der.startSequence();
	
			var version = new Buffer(1);
			version.writeUInt8(1, 0);
			der.writeBuffer(version, asn1.Ber.Integer);
	
			// FieldID sequence
			der.startSequence();
			der.writeOID('1.2.840.10045.1.1'); // prime-field
			der.writeBuffer(curve.p, asn1.Ber.Integer);
			der.endSequence();
	
			// Curve sequence
			der.startSequence();
			var a = curve.p;
			if (a[0] === 0x0)
				a = a.slice(1);
			der.writeBuffer(a, asn1.Ber.OctetString);
			der.writeBuffer(curve.b, asn1.Ber.OctetString);
			der.writeBuffer(curve.s, asn1.Ber.BitString);
			der.endSequence();
	
			der.writeBuffer(curve.G, asn1.Ber.OctetString);
			der.writeBuffer(curve.n, asn1.Ber.Integer);
			var h = curve.h;
			if (!h) {
				h = new Buffer(1);
				h[0] = 1;
			}
			der.writeBuffer(h, asn1.Ber.Integer);
	
			// ECParameters
			der.endSequence();
		}
	}
	
	function writePkcs8ECDSAPublic(key, der) {
		writeECDSACurve(key, der);
		der.endSequence();
	
		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
	}
	
	function writePkcs8ECDSAPrivate(key, der) {
		writeECDSACurve(key, der);
		der.endSequence();
	
		der.startSequence(asn1.Ber.OctetString);
		der.startSequence();
	
		var version = new Buffer(1);
		version[0] = 1;
		der.writeBuffer(version, asn1.Ber.Integer);
	
		der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
	
		der.startSequence(0xa1);
		var Q = utils.ecNormalize(key.part.Q.data, true);
		der.writeBuffer(Q, asn1.Ber.BitString);
		der.endSequence();
	
		der.endSequence();
		der.endSequence();
	}


/***/ },
/* 658 */
/*!********************************************!*\
  !*** ./~/sshpk/lib/formats/ssh-private.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		read: read,
		readSSHPrivate: readSSHPrivate,
		write: write
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var asn1 = __webpack_require__(/*! asn1 */ 645);
	var algs = __webpack_require__(/*! ../algs */ 639);
	var utils = __webpack_require__(/*! ../utils */ 642);
	var crypto = __webpack_require__(/*! crypto */ 601);
	
	var Key = __webpack_require__(/*! ../key */ 638);
	var PrivateKey = __webpack_require__(/*! ../private-key */ 643);
	var pem = __webpack_require__(/*! ./pem */ 655);
	var rfc4253 = __webpack_require__(/*! ./rfc4253 */ 659);
	var SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ 651);
	
	function read(buf, options) {
		return (pem.read(buf, options));
	}
	
	var MAGIC = 'openssh-key-v1';
	
	function readSSHPrivate(type, buf) {
		buf = new SSHBuffer({buffer: buf});
	
		var magic = buf.readCString();
		assert.strictEqual(magic, MAGIC, 'bad magic string');
	
		var cipher = buf.readString();
		var kdf = buf.readString();
	
		/* We only support unencrypted keys. */
		if (cipher !== 'none' || kdf !== 'none') {
			throw (new Error('OpenSSH-format key is encrypted ' +
			     '(password-protected). Please use the SSH agent ' +
			     'or decrypt the key.'));
		}
	
		/* Skip over kdfoptions. */
		buf.readString();
	
		var nkeys = buf.readInt();
		if (nkeys !== 1) {
			throw (new Error('OpenSSH-format key file contains ' +
			    'multiple keys: this is unsupported.'));
		}
	
		var pubKey = buf.readBuffer();
	
		if (type === 'public') {
			assert.ok(buf.atEnd(), 'excess bytes left after key');
			return (rfc4253.read(pubKey));
		}
	
		var privKeyBlob = buf.readBuffer();
		assert.ok(buf.atEnd(), 'excess bytes left after key');
	
		buf = new SSHBuffer({buffer: privKeyBlob});
	
		var checkInt1 = buf.readInt();
		var checkInt2 = buf.readInt();
		assert.strictEqual(checkInt1, checkInt2, 'checkints do not match');
	
		var ret = {};
		var key = rfc4253.readInternal(ret, 'private', buf.remainder());
	
		buf.skip(ret.consumed);
	
		var comment = buf.readString();
		key.comment = comment;
	
		return (key);
	}
	
	function write(key, options) {
		var pubKey;
		if (PrivateKey.isPrivateKey(key))
			pubKey = key.toPublic();
		else
			pubKey = key;
	
		var privBuf;
		if (PrivateKey.isPrivateKey(key)) {
			privBuf = new SSHBuffer({});
			var checkInt = crypto.randomBytes(4).readUInt32BE(0);
			privBuf.writeInt(checkInt);
			privBuf.writeInt(checkInt);
			privBuf.write(key.toBuffer('rfc4253'));
			privBuf.writeString(key.comment || '');
	
			var n = 1;
			while (privBuf._offset % 8 !== 0)
				privBuf.writeChar(n++);
		}
	
		var buf = new SSHBuffer({});
	
		buf.writeCString(MAGIC);
		buf.writeString('none');	/* cipher */
		buf.writeString('none');	/* kdf */
		buf.writeBuffer(new Buffer(0));	/* kdfoptions */
	
		buf.writeInt(1);		/* nkeys */
		buf.writeBuffer(pubKey.toBuffer('rfc4253'));
	
		if (privBuf)
			buf.writeBuffer(privBuf.toBuffer());
	
		buf = buf.toBuffer();
	
		var header;
		if (PrivateKey.isPrivateKey(key))
			header = 'OPENSSH PRIVATE KEY';
		else
			header = 'OPENSSH PUBLIC KEY';
	
		var tmp = buf.toString('base64');
		var len = tmp.length + (tmp.length / 70) +
		    18 + 16 + header.length*2 + 10;
		buf = new Buffer(len);
		var o = 0;
		o += buf.write('-----BEGIN ' + header + '-----\n', o);
		for (var i = 0; i < tmp.length; ) {
			var limit = i + 70;
			if (limit > tmp.length)
				limit = tmp.length;
			o += buf.write(tmp.slice(i, limit), o);
			buf[o++] = 10;
			i = limit;
		}
		o += buf.write('-----END ' + header + '-----\n', o);
	
		return (buf.slice(0, o));
	}


/***/ },
/* 659 */
/*!****************************************!*\
  !*** ./~/sshpk/lib/formats/rfc4253.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		read: read.bind(undefined, false, undefined),
		readType: read.bind(undefined, false),
		write: write,
		/* semi-private api, used by sshpk-agent */
		readPartial: read.bind(undefined, true),
	
		/* shared with ssh format */
		readInternal: read,
		keyTypeToAlg: keyTypeToAlg,
		algToKeyType: algToKeyType
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var algs = __webpack_require__(/*! ../algs */ 639);
	var utils = __webpack_require__(/*! ../utils */ 642);
	var Key = __webpack_require__(/*! ../key */ 638);
	var PrivateKey = __webpack_require__(/*! ../private-key */ 643);
	var SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ 651);
	
	function algToKeyType(alg) {
		assert.string(alg);
		if (alg === 'ssh-dss')
			return ('dsa');
		else if (alg === 'ssh-rsa')
			return ('rsa');
		else if (alg === 'ssh-ed25519')
			return ('ed25519');
		else if (alg === 'ssh-curve25519')
			return ('curve25519');
		else if (alg.match(/^ecdsa-sha2-/))
			return ('ecdsa');
		else
			throw (new Error('Unknown algorithm ' + alg));
	}
	
	function keyTypeToAlg(key) {
		assert.object(key);
		if (key.type === 'dsa')
			return ('ssh-dss');
		else if (key.type === 'rsa')
			return ('ssh-rsa');
		else if (key.type === 'ed25519')
			return ('ssh-ed25519');
		else if (key.type === 'curve25519')
			return ('ssh-curve25519');
		else if (key.type === 'ecdsa')
			return ('ecdsa-sha2-' + key.part.curve.data.toString());
		else
			throw (new Error('Unknown key type ' + key.type));
	}
	
	function read(partial, type, buf, options) {
		if (typeof (buf) === 'string')
			buf = new Buffer(buf);
		assert.buffer(buf, 'buf');
	
		var key = {};
	
		var parts = key.parts = [];
		var sshbuf = new SSHBuffer({buffer: buf});
	
		var alg = sshbuf.readString();
		assert.ok(!sshbuf.atEnd(), 'key must have at least one part');
	
		key.type = algToKeyType(alg);
	
		var partCount = algs.info[key.type].parts.length;
		if (type && type === 'private')
			partCount = algs.privInfo[key.type].parts.length;
	
		while (!sshbuf.atEnd() && parts.length < partCount)
			parts.push(sshbuf.readPart());
		while (!partial && !sshbuf.atEnd())
			parts.push(sshbuf.readPart());
	
		assert.ok(parts.length >= 1,
		    'key must have at least one part');
		assert.ok(partial || sshbuf.atEnd(),
		    'leftover bytes at end of key');
	
		var Constructor = Key;
		var algInfo = algs.info[key.type];
		if (type === 'private' || algInfo.parts.length !== parts.length) {
			algInfo = algs.privInfo[key.type];
			Constructor = PrivateKey;
		}
		assert.strictEqual(algInfo.parts.length, parts.length);
	
		if (key.type === 'ecdsa') {
			var res = /^ecdsa-sha2-(.+)$/.exec(alg);
			assert.ok(res !== null);
			assert.strictEqual(res[1], parts[0].data.toString());
		}
	
		var normalized = true;
		for (var i = 0; i < algInfo.parts.length; ++i) {
			parts[i].name = algInfo.parts[i];
			if (parts[i].name !== 'curve' &&
			    algInfo.normalize !== false) {
				var p = parts[i];
				var nd = utils.mpNormalize(p.data);
				if (nd !== p.data) {
					p.data = nd;
					normalized = false;
				}
			}
		}
	
		if (normalized)
			key._rfc4253Cache = sshbuf.toBuffer();
	
		if (partial && typeof (partial) === 'object') {
			partial.remainder = sshbuf.remainder();
			partial.consumed = sshbuf._offset;
		}
	
		return (new Constructor(key));
	}
	
	function write(key, options) {
		assert.object(key);
	
		var alg = keyTypeToAlg(key);
		var i;
	
		var algInfo = algs.info[key.type];
		if (PrivateKey.isPrivateKey(key))
			algInfo = algs.privInfo[key.type];
		var parts = algInfo.parts;
	
		var buf = new SSHBuffer({});
	
		buf.writeString(alg);
	
		for (i = 0; i < parts.length; ++i) {
			var data = key.part[parts[i]].data;
			if (algInfo.normalize !== false)
				data = utils.mpNormalize(data);
			buf.writeBuffer(data);
		}
	
		return (buf.toBuffer());
	}


/***/ },
/* 660 */
/*!************************************!*\
  !*** ./~/sshpk/lib/formats/ssh.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = {
		read: read,
		write: write
	};
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var rfc4253 = __webpack_require__(/*! ./rfc4253 */ 659);
	var utils = __webpack_require__(/*! ../utils */ 642);
	var Key = __webpack_require__(/*! ../key */ 638);
	var PrivateKey = __webpack_require__(/*! ../private-key */ 643);
	
	var sshpriv = __webpack_require__(/*! ./ssh-private */ 658);
	
	/*JSSTYLED*/
	var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([\n \t]+([^\n]+))?$/;
	/*JSSTYLED*/
	var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/ \t\n]+[=]*)(.*)$/;
	
	function read(buf, options) {
		if (typeof (buf) !== 'string') {
			assert.buffer(buf, 'buf');
			buf = buf.toString('ascii');
		}
	
		var trimmed = buf.trim().replace(/[\\\r]/g, '');
		var m = trimmed.match(SSHKEY_RE);
		if (!m)
			m = trimmed.match(SSHKEY_RE2);
		assert.ok(m, 'key must match regex');
	
		var type = rfc4253.algToKeyType(m[1]);
		var kbuf = new Buffer(m[2], 'base64');
	
		/*
		 * This is a bit tricky. If we managed to parse the key and locate the
		 * key comment with the regex, then do a non-partial read and assert
		 * that we have consumed all bytes. If we couldn't locate the key
		 * comment, though, there may be whitespace shenanigans going on that
		 * have conjoined the comment to the rest of the key. We do a partial
		 * read in this case to try to make the best out of a sorry situation.
		 */
		var key;
		var ret = {};
		if (m[4]) {
			try {
				key = rfc4253.read(kbuf);
	
			} catch (e) {
				m = trimmed.match(SSHKEY_RE2);
				assert.ok(m, 'key must match regex');
				kbuf = new Buffer(m[2], 'base64');
				key = rfc4253.readInternal(ret, 'public', kbuf);
			}
		} else {
			key = rfc4253.readInternal(ret, 'public', kbuf);
		}
	
		assert.strictEqual(type, key.type);
	
		if (m[4] && m[4].length > 0) {
			key.comment = m[4];
	
		} else if (ret.consumed) {
			/*
			 * Now the magic: trying to recover the key comment when it's
			 * gotten conjoined to the key or otherwise shenanigan'd.
			 *
			 * Work out how much base64 we used, then drop all non-base64
			 * chars from the beginning up to this point in the the string.
			 * Then offset in this and try to make up for missing = chars.
			 */
			var data = m[2] + m[3];
			var realOffset = Math.ceil(ret.consumed / 3) * 4;
			data = data.slice(0, realOffset - 2). /*JSSTYLED*/
			    replace(/[^a-zA-Z0-9+\/=]/g, '') +
			    data.slice(realOffset - 2);
	
			var padding = ret.consumed % 3;
			if (padding > 0 &&
			    data.slice(realOffset - 1, realOffset) !== '=')
				realOffset--;
			while (data.slice(realOffset, realOffset + 1) === '=')
				realOffset++;
	
			/* Finally, grab what we think is the comment & clean it up. */
			var trailer = data.slice(realOffset);
			trailer = trailer.replace(/[\r\n]/g, ' ').
			    replace(/^\s+/, '');
			if (trailer.match(/^[a-zA-Z0-9]/))
				key.comment = trailer;
		}
	
		return (key);
	}
	
	function write(key, options) {
		assert.object(key);
		if (!Key.isKey(key))
			throw (new Error('Must be a public key'));
	
		var parts = [];
		var alg = rfc4253.keyTypeToAlg(key);
		parts.push(alg);
	
		var buf = rfc4253.write(key);
		parts.push(buf.toString('base64'));
	
		if (key.comment)
			parts.push(key.comment);
	
		return (new Buffer(parts.join(' ')));
	}


/***/ },
/* 661 */
/*!*******************************!*\
  !*** ./~/jodid25519/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	/*
	 * Copyright (c) 2014 Mega Limited
	 * under the MIT License.
	 * 
	 * Authors: Guy K. Kloss
	 * 
	 * You should have received a copy of the license along with this program.
	 */
	
	var dh = __webpack_require__(/*! ./lib/dh */ 662);
	var eddsa = __webpack_require__(/*! ./lib/eddsa */ 666);
	var curve255 = __webpack_require__(/*! ./lib/curve255 */ 665);
	var utils = __webpack_require__(/*! ./lib/utils */ 664);
	    
	    /**
	     * @exports jodid25519
	     * Curve 25519-based cryptography collection.
	     *
	     * @description
	     * EC Diffie-Hellman (ECDH) based on Curve25519 and digital signatures
	     * (EdDSA) based on Ed25519.
	     */
	    var ns = {};
	    
	    /** Module version indicator as string (format: [major.minor.patch]). */
	    ns.VERSION = '0.7.1';
	
	    ns.dh = dh;
	    ns.eddsa = eddsa;
	    ns.curve255 = curve255;
	    ns.utils = utils;
	
	module.exports = ns;


/***/ },
/* 662 */
/*!********************************!*\
  !*** ./~/jodid25519/lib/dh.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileOverview
	 * EC Diffie-Hellman operations on Curve25519.
	 */
	
	/*
	 * Copyright (c) 2014 Mega Limited
	 * under the MIT License.
	 *
	 * Authors: Guy K. Kloss
	 *
	 * You should have received a copy of the license along with this program.
	 */
	
	var core = __webpack_require__(/*! ./core */ 663);
	var utils = __webpack_require__(/*! ./utils */ 664);
	var curve255 = __webpack_require__(/*! ./curve255 */ 665);
	
	
	    /**
	     * @exports jodid25519/dh
	     * EC Diffie-Hellman operations on Curve25519.
	     *
	     * @description
	     * EC Diffie-Hellman operations on Curve25519.
	     */
	    var ns = {};
	
	
	    function _toString(vector) {
	        var u = new Uint16Array(vector);
	        return (new Buffer(new Uint8Array(u.buffer)));
	    }
	
	    function _fromString(vector) {
	        if (Buffer.isBuffer(vector)) {
	            var u = new Uint8Array(vector);
	            return (new Uint16Array(u.buffer));
	        }
	
	        var result = new Array(16);
	        for (var i = 0, l = 0; i < vector.length; i += 2) {
	            result[l] = (vector.charCodeAt(i + 1) << 8) | vector.charCodeAt(i);
	            l++;
	        }
	        return result;
	    }
	
	
	    /**
	     * Computes a key through scalar multiplication of a point on the curve 25519.
	     *
	     * This function is used for the DH key-exchange protocol. It computes a
	     * key based on a secret key with a public component (opponent's public key
	     * or curve base point if not given) by using scalar multiplication.
	     *
	     * Before multiplication, some bit operations are applied to the
	     * private key to ensure it is a valid Curve25519 secret key.
	     * It is the user's responsibility to make sure that the private
	     * key is a uniformly random, secret value.
	     *
	     * @function
	     * @param privateComponent {string}
	     *     Private point as byte string on the curve.
	     * @param publicComponent {string}
	     *     Public point as byte string on the curve. If not given, the curve's
	     *     base point is used.
	     * @returns {string}
	     *     Key point as byte string resulting from scalar product.
	     */
	    ns.computeKey = function(privateComponent, publicComponent) {
	        if (publicComponent) {
	            return _toString(curve255.curve25519(_fromString(privateComponent),
	                                                 _fromString(publicComponent)));
	        } else {
	            return _toString(curve255.curve25519(_fromString(privateComponent)));
	        }
	    };
	
	    /**
	     * Computes the public key to a private key on the curve 25519.
	     *
	     * Before multiplication, some bit operations are applied to the
	     * private key to ensure it is a valid Curve25519 secret key.
	     * It is the user's responsibility to make sure that the private
	     * key is a uniformly random, secret value.
	     *
	     * @function
	     * @param privateKey {string}
	     *     Private point as byte string on the curve.
	     * @returns {string}
	     *     Public key point as byte string resulting from scalar product.
	     */
	    ns.publicKey = function(privateKey) {
	        return _toString(curve255.curve25519(_fromString(privateKey)));
	    };
	
	
	    /**
	     * Generates a new random private key of 32 bytes length (256 bit).
	     *
	     * @function
	     * @returns {string}
	     *     Byte string containing a new random private key seed.
	     */
	    ns.generateKey = function() {
	        return core.generateKey(true);
	    };
	
	module.exports = ns;


/***/ },
/* 663 */
/*!**********************************!*\
  !*** ./~/jodid25519/lib/core.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileOverview
	 * Core operations on curve 25519 required for the higher level modules.
	 */
	
	/*
	 * Copyright (c) 2007, 2013, 2014 Michele Bini
	 * Copyright (c) 2014 Mega Limited
	 * under the MIT License.
	 *
	 * Authors: Guy K. Kloss, Michele Bini
	 *
	 * You should have received a copy of the license along with this program.
	 */
	
	var crypto = __webpack_require__(/*! crypto */ 601);
	
	    /**
	     * @exports jodid25519/core
	     * Core operations on curve 25519 required for the higher level modules.
	     *
	     * @description
	     * Core operations on curve 25519 required for the higher level modules.
	     *
	     * <p>
	     * This core code is extracted from Michele Bini's curve255.js implementation,
	     * which is used as a base for Curve25519 ECDH and Ed25519 EdDSA operations.
	     * </p>
	     */
	    var ns = {};
	
	    function _setbit(n, c, v) {
	        var i = c >> 4;
	        var a = n[i];
	        a = a + (1 << (c & 0xf)) * v;
	        n[i] = a;
	    }
	
	    function _getbit(n, c) {
	        return (n[c >> 4] >> (c & 0xf)) & 1;
	    }
	
	    function _ZERO() {
	        return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	    }
	
	    function _ONE() {
	        return [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	    }
	
	    // Basepoint.
	    function _BASE() {
	        return [9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	    }
	
	    // return -1, 0, +1 when a is less than, equal, or greater than b
	    function _bigintcmp(a, b) {
	        // The following code is a bit tricky to avoid code branching
	        var c, abs_r, mask;
	        var r = 0;
	        for (c = 15; c >= 0; c--) {
	            var x = a[c];
	            var y = b[c];
	            r = r + (x - y) * (1 - r * r);
	            // http://graphics.stanford.edu/~seander/bithacks.html#IntegerAbs
	            // correct for [-294967295, 294967295]
	            mask = r >> 31;
	            abs_r = (r + mask) ^ mask;
	            // http://stackoverflow.com/questions/596467/how-do-i-convert-a-number-to-an-integer-in-javascript
	            // this rounds towards zero
	            r = ~~((r << 1) / (abs_r + 1));
	        }
	        return r;
	    }
	
	    function _bigintadd(a, b) {
	        var r = [];
	        var v;
	        r[0] = (v = a[0] + b[0]) & 0xffff;
	        r[1] = (v = (v >>> 16) + a[1] + b[1]) & 0xffff;
	        r[2] = (v = (v >>> 16) + a[2] + b[2]) & 0xffff;
	        r[3] = (v = (v >>> 16) + a[3] + b[3]) & 0xffff;
	        r[4] = (v = (v >>> 16) + a[4] + b[4]) & 0xffff;
	        r[5] = (v = (v >>> 16) + a[5] + b[5]) & 0xffff;
	        r[6] = (v = (v >>> 16) + a[6] + b[6]) & 0xffff;
	        r[7] = (v = (v >>> 16) + a[7] + b[7]) & 0xffff;
	        r[8] = (v = (v >>> 16) + a[8] + b[8]) & 0xffff;
	        r[9] = (v = (v >>> 16) + a[9] + b[9]) & 0xffff;
	        r[10] = (v = (v >>> 16) + a[10] + b[10]) & 0xffff;
	        r[11] = (v = (v >>> 16) + a[11] + b[11]) & 0xffff;
	        r[12] = (v = (v >>> 16) + a[12] + b[12]) & 0xffff;
	        r[13] = (v = (v >>> 16) + a[13] + b[13]) & 0xffff;
	        r[14] = (v = (v >>> 16) + a[14] + b[14]) & 0xffff;
	        r[15] = (v >>> 16) + a[15] + b[15];
	        return r;
	    }
	
	    function _bigintsub(a, b) {
	        var r = [];
	        var v;
	        r[0] = (v = 0x80000 + a[0] - b[0]) & 0xffff;
	        r[1] = (v = (v >>> 16) + 0x7fff8 + a[1] - b[1]) & 0xffff;
	        r[2] = (v = (v >>> 16) + 0x7fff8 + a[2] - b[2]) & 0xffff;
	        r[3] = (v = (v >>> 16) + 0x7fff8 + a[3] - b[3]) & 0xffff;
	        r[4] = (v = (v >>> 16) + 0x7fff8 + a[4] - b[4]) & 0xffff;
	        r[5] = (v = (v >>> 16) + 0x7fff8 + a[5] - b[5]) & 0xffff;
	        r[6] = (v = (v >>> 16) + 0x7fff8 + a[6] - b[6]) & 0xffff;
	        r[7] = (v = (v >>> 16) + 0x7fff8 + a[7] - b[7]) & 0xffff;
	        r[8] = (v = (v >>> 16) + 0x7fff8 + a[8] - b[8]) & 0xffff;
	        r[9] = (v = (v >>> 16) + 0x7fff8 + a[9] - b[9]) & 0xffff;
	        r[10] = (v = (v >>> 16) + 0x7fff8 + a[10] - b[10]) & 0xffff;
	        r[11] = (v = (v >>> 16) + 0x7fff8 + a[11] - b[11]) & 0xffff;
	        r[12] = (v = (v >>> 16) + 0x7fff8 + a[12] - b[12]) & 0xffff;
	        r[13] = (v = (v >>> 16) + 0x7fff8 + a[13] - b[13]) & 0xffff;
	        r[14] = (v = (v >>> 16) + 0x7fff8 + a[14] - b[14]) & 0xffff;
	        r[15] = (v >>> 16) - 8 + a[15] - b[15];
	        return r;
	    }
	
	    function _sqr8h(a7, a6, a5, a4, a3, a2, a1, a0) {
	        // 'division by 0x10000' can not be replaced by '>> 16' because
	        // more than 32 bits of precision are needed similarly
	        // 'multiplication by 2' cannot be replaced by '<< 1'
	        var r = [];
	        var v;
	        r[0] = (v = a0 * a0) & 0xffff;
	        r[1] = (v = (0 | (v / 0x10000)) + 2 * a0 * a1) & 0xffff;
	        r[2] = (v = (0 | (v / 0x10000)) + 2 * a0 * a2 + a1 * a1) & 0xffff;
	        r[3] = (v = (0 | (v / 0x10000)) + 2 * a0 * a3 + 2 * a1 * a2) & 0xffff;
	        r[4] = (v = (0 | (v / 0x10000)) + 2 * a0 * a4 + 2 * a1 * a3 + a2
	                    * a2) & 0xffff;
	        r[5] = (v = (0 | (v / 0x10000)) + 2 * a0 * a5 + 2 * a1 * a4 + 2
	                    * a2 * a3) & 0xffff;
	        r[6] = (v = (0 | (v / 0x10000)) + 2 * a0 * a6 + 2 * a1 * a5 + 2
	                    * a2 * a4 + a3 * a3) & 0xffff;
	        r[7] = (v = (0 | (v / 0x10000)) + 2 * a0 * a7 + 2 * a1 * a6 + 2
	                    * a2 * a5 + 2 * a3 * a4) & 0xffff;
	        r[8] = (v = (0 | (v / 0x10000)) + 2 * a1 * a7 + 2 * a2 * a6 + 2
	                    * a3 * a5 + a4 * a4) & 0xffff;
	        r[9] = (v = (0 | (v / 0x10000)) + 2 * a2 * a7 + 2 * a3 * a6 + 2
	                    * a4 * a5) & 0xffff;
	        r[10] = (v = (0 | (v / 0x10000)) + 2 * a3 * a7 + 2 * a4 * a6
	                     + a5 * a5) & 0xffff;
	        r[11] = (v = (0 | (v / 0x10000)) + 2 * a4 * a7 + 2 * a5 * a6) & 0xffff;
	        r[12] = (v = (0 | (v / 0x10000)) + 2 * a5 * a7 + a6 * a6) & 0xffff;
	        r[13] = (v = (0 | (v / 0x10000)) + 2 * a6 * a7) & 0xffff;
	        r[14] = (v = (0 | (v / 0x10000)) + a7 * a7) & 0xffff;
	        r[15] = 0 | (v / 0x10000);
	        return r;
	    }
	
	    function _sqrmodp(a) {
	        var x = _sqr8h(a[15], a[14], a[13], a[12], a[11], a[10], a[9],
	                       a[8]);
	        var z = _sqr8h(a[7], a[6], a[5], a[4], a[3], a[2], a[1], a[0]);
	        var y = _sqr8h(a[15] + a[7], a[14] + a[6], a[13] + a[5], a[12]
	                                                                 + a[4],
	                       a[11] + a[3], a[10] + a[2], a[9] + a[1], a[8]
	                                                                + a[0]);
	        var r = [];
	        var v;
	        r[0] = (v = 0x800000 + z[0] + (y[8] - x[8] - z[8] + x[0] - 0x80)
	                    * 38) & 0xffff;
	        r[1] = (v = 0x7fff80 + (v >>> 16) + z[1]
	                    + (y[9] - x[9] - z[9] + x[1]) * 38) & 0xffff;
	        r[2] = (v = 0x7fff80 + (v >>> 16) + z[2]
	                    + (y[10] - x[10] - z[10] + x[2]) * 38) & 0xffff;
	        r[3] = (v = 0x7fff80 + (v >>> 16) + z[3]
	                    + (y[11] - x[11] - z[11] + x[3]) * 38) & 0xffff;
	        r[4] = (v = 0x7fff80 + (v >>> 16) + z[4]
	                    + (y[12] - x[12] - z[12] + x[4]) * 38) & 0xffff;
	        r[5] = (v = 0x7fff80 + (v >>> 16) + z[5]
	                    + (y[13] - x[13] - z[13] + x[5]) * 38) & 0xffff;
	        r[6] = (v = 0x7fff80 + (v >>> 16) + z[6]
	                    + (y[14] - x[14] - z[14] + x[6]) * 38) & 0xffff;
	        r[7] = (v = 0x7fff80 + (v >>> 16) + z[7]
	                    + (y[15] - x[15] - z[15] + x[7]) * 38) & 0xffff;
	        r[8] = (v = 0x7fff80 + (v >>> 16) + z[8] + y[0] - x[0] - z[0]
	                    + x[8] * 38) & 0xffff;
	        r[9] = (v = 0x7fff80 + (v >>> 16) + z[9] + y[1] - x[1] - z[1]
	                    + x[9] * 38) & 0xffff;
	        r[10] = (v = 0x7fff80 + (v >>> 16) + z[10] + y[2] - x[2] - z[2]
	                     + x[10] * 38) & 0xffff;
	        r[11] = (v = 0x7fff80 + (v >>> 16) + z[11] + y[3] - x[3] - z[3]
	                     + x[11] * 38) & 0xffff;
	        r[12] = (v = 0x7fff80 + (v >>> 16) + z[12] + y[4] - x[4] - z[4]
	                     + x[12] * 38) & 0xffff;
	        r[13] = (v = 0x7fff80 + (v >>> 16) + z[13] + y[5] - x[5] - z[5]
	                     + x[13] * 38) & 0xffff;
	        r[14] = (v = 0x7fff80 + (v >>> 16) + z[14] + y[6] - x[6] - z[6]
	                     + x[14] * 38) & 0xffff;
	        r[15] = 0x7fff80 + (v >>> 16) + z[15] + y[7] - x[7] - z[7]
	                + x[15] * 38;
	        _reduce(r);
	        return r;
	    }
	
	    function _mul8h(a7, a6, a5, a4, a3, a2, a1, a0, b7, b6, b5, b4, b3,
	                    b2, b1, b0) {
	        // 'division by 0x10000' can not be replaced by '>> 16' because
	        // more than 32 bits of precision are needed
	        var r = [];
	        var v;
	        r[0] = (v = a0 * b0) & 0xffff;
	        r[1] = (v = (0 | (v / 0x10000)) + a0 * b1 + a1 * b0) & 0xffff;
	        r[2] = (v = (0 | (v / 0x10000)) + a0 * b2 + a1 * b1 + a2 * b0) & 0xffff;
	        r[3] = (v = (0 | (v / 0x10000)) + a0 * b3 + a1 * b2 + a2 * b1
	                    + a3 * b0) & 0xffff;
	        r[4] = (v = (0 | (v / 0x10000)) + a0 * b4 + a1 * b3 + a2 * b2
	                    + a3 * b1 + a4 * b0) & 0xffff;
	        r[5] = (v = (0 | (v / 0x10000)) + a0 * b5 + a1 * b4 + a2 * b3
	                    + a3 * b2 + a4 * b1 + a5 * b0) & 0xffff;
	        r[6] = (v = (0 | (v / 0x10000)) + a0 * b6 + a1 * b5 + a2 * b4
	                    + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0) & 0xffff;
	        r[7] = (v = (0 | (v / 0x10000)) + a0 * b7 + a1 * b6 + a2 * b5
	                    + a3 * b4 + a4 * b3 + a5 * b2 + a6 * b1 + a7 * b0) & 0xffff;
	        r[8] = (v = (0 | (v / 0x10000)) + a1 * b7 + a2 * b6 + a3 * b5
	                    + a4 * b4 + a5 * b3 + a6 * b2 + a7 * b1) & 0xffff;
	        r[9] = (v = (0 | (v / 0x10000)) + a2 * b7 + a3 * b6 + a4 * b5
	                    + a5 * b4 + a6 * b3 + a7 * b2) & 0xffff;
	        r[10] = (v = (0 | (v / 0x10000)) + a3 * b7 + a4 * b6 + a5 * b5
	                     + a6 * b4 + a7 * b3) & 0xffff;
	        r[11] = (v = (0 | (v / 0x10000)) + a4 * b7 + a5 * b6 + a6 * b5
	                     + a7 * b4) & 0xffff;
	        r[12] = (v = (0 | (v / 0x10000)) + a5 * b7 + a6 * b6 + a7 * b5) & 0xffff;
	        r[13] = (v = (0 | (v / 0x10000)) + a6 * b7 + a7 * b6) & 0xffff;
	        r[14] = (v = (0 | (v / 0x10000)) + a7 * b7) & 0xffff;
	        r[15] = (0 | (v / 0x10000));
	        return r;
	    }
	
	    function _mulmodp(a, b) {
	        // Karatsuba multiplication scheme: x*y = (b^2+b)*x1*y1 -
	        // b*(x1-x0)*(y1-y0) + (b+1)*x0*y0
	        var x = _mul8h(a[15], a[14], a[13], a[12], a[11], a[10], a[9],
	                       a[8], b[15], b[14], b[13], b[12], b[11], b[10],
	                       b[9], b[8]);
	        var z = _mul8h(a[7], a[6], a[5], a[4], a[3], a[2], a[1], a[0],
	                       b[7], b[6], b[5], b[4], b[3], b[2], b[1], b[0]);
	        var y = _mul8h(a[15] + a[7], a[14] + a[6], a[13] + a[5], a[12]
	                                                                 + a[4],
	                       a[11] + a[3], a[10] + a[2], a[9] + a[1], a[8]
	                                                                + a[0],
	                       b[15] + b[7], b[14] + b[6], b[13] + b[5], b[12]
	                                                                 + b[4],
	                       b[11] + b[3], b[10] + b[2], b[9] + b[1], b[8]
	                                                                + b[0]);
	        var r = [];
	        var v;
	        r[0] = (v = 0x800000 + z[0] + (y[8] - x[8] - z[8] + x[0] - 0x80)
	                    * 38) & 0xffff;
	        r[1] = (v = 0x7fff80 + (v >>> 16) + z[1]
	                    + (y[9] - x[9] - z[9] + x[1]) * 38) & 0xffff;
	        r[2] = (v = 0x7fff80 + (v >>> 16) + z[2]
	                    + (y[10] - x[10] - z[10] + x[2]) * 38) & 0xffff;
	        r[3] = (v = 0x7fff80 + (v >>> 16) + z[3]
	                    + (y[11] - x[11] - z[11] + x[3]) * 38) & 0xffff;
	        r[4] = (v = 0x7fff80 + (v >>> 16) + z[4]
	                    + (y[12] - x[12] - z[12] + x[4]) * 38) & 0xffff;
	        r[5] = (v = 0x7fff80 + (v >>> 16) + z[5]
	                    + (y[13] - x[13] - z[13] + x[5]) * 38) & 0xffff;
	        r[6] = (v = 0x7fff80 + (v >>> 16) + z[6]
	                    + (y[14] - x[14] - z[14] + x[6]) * 38) & 0xffff;
	        r[7] = (v = 0x7fff80 + (v >>> 16) + z[7]
	                    + (y[15] - x[15] - z[15] + x[7]) * 38) & 0xffff;
	        r[8] = (v = 0x7fff80 + (v >>> 16) + z[8] + y[0] - x[0] - z[0]
	                    + x[8] * 38) & 0xffff;
	        r[9] = (v = 0x7fff80 + (v >>> 16) + z[9] + y[1] - x[1] - z[1]
	                    + x[9] * 38) & 0xffff;
	        r[10] = (v = 0x7fff80 + (v >>> 16) + z[10] + y[2] - x[2] - z[2]
	                     + x[10] * 38) & 0xffff;
	        r[11] = (v = 0x7fff80 + (v >>> 16) + z[11] + y[3] - x[3] - z[3]
	                     + x[11] * 38) & 0xffff;
	        r[12] = (v = 0x7fff80 + (v >>> 16) + z[12] + y[4] - x[4] - z[4]
	                     + x[12] * 38) & 0xffff;
	        r[13] = (v = 0x7fff80 + (v >>> 16) + z[13] + y[5] - x[5] - z[5]
	                     + x[13] * 38) & 0xffff;
	        r[14] = (v = 0x7fff80 + (v >>> 16) + z[14] + y[6] - x[6] - z[6]
	                     + x[14] * 38) & 0xffff;
	        r[15] = 0x7fff80 + (v >>> 16) + z[15] + y[7] - x[7] - z[7]
	                + x[15] * 38;
	        _reduce(r);
	        return r;
	    }
	
	    function _reduce(arr) {
	        var aCopy = arr.slice(0);
	        var choice = [arr, aCopy];
	        var v = arr[15];
	        // Use the dummy copy instead of just returning to be more constant time.
	        var a = choice[(v < 0x8000) & 1];
	        a[15] = v & 0x7fff;
	        // >32-bits of precision are required here so '/ 0x8000' can not be
	        // replaced by the arithmetic equivalent '>>> 15'
	        v = (0 | (v / 0x8000)) * 19;
	        a[0] = (v += a[0]) & 0xffff;
	        v = v >>> 16;
	        a[1] = (v += a[1]) & 0xffff;
	        v = v >>> 16;
	        a[2] = (v += a[2]) & 0xffff;
	        v = v >>> 16;
	        a[3] = (v += a[3]) & 0xffff;
	        v = v >>> 16;
	        a[4] = (v += a[4]) & 0xffff;
	        v = v >>> 16;
	        a[5] = (v += a[5]) & 0xffff;
	        v = v >>> 16;
	        a[6] = (v += a[6]) & 0xffff;
	        v = v >>> 16;
	        a[7] = (v += a[7]) & 0xffff;
	        v = v >>> 16;
	        a[8] = (v += a[8]) & 0xffff;
	        v = v >>> 16;
	        a[9] = (v += a[9]) & 0xffff;
	        v = v >>> 16;
	        a[10] = (v += a[10]) & 0xffff;
	        v = v >>> 16;
	        a[11] = (v += a[11]) & 0xffff;
	        v = v >>> 16;
	        a[12] = (v += a[12]) & 0xffff;
	        v = v >>> 16;
	        a[13] = (v += a[13]) & 0xffff;
	        v = v >>> 16;
	        a[14] = (v += a[14]) & 0xffff;
	        v = v >>> 16;
	        a[15] += v;
	    }
	
	    function _addmodp(a, b) {
	        var r = [];
	        var v;
	        r[0] = (v = ((0 | (a[15] >>> 15)) + (0 | (b[15] >>> 15))) * 19
	                    + a[0] + b[0]) & 0xffff;
	        r[1] = (v = (v >>> 16) + a[1] + b[1]) & 0xffff;
	        r[2] = (v = (v >>> 16) + a[2] + b[2]) & 0xffff;
	        r[3] = (v = (v >>> 16) + a[3] + b[3]) & 0xffff;
	        r[4] = (v = (v >>> 16) + a[4] + b[4]) & 0xffff;
	        r[5] = (v = (v >>> 16) + a[5] + b[5]) & 0xffff;
	        r[6] = (v = (v >>> 16) + a[6] + b[6]) & 0xffff;
	        r[7] = (v = (v >>> 16) + a[7] + b[7]) & 0xffff;
	        r[8] = (v = (v >>> 16) + a[8] + b[8]) & 0xffff;
	        r[9] = (v = (v >>> 16) + a[9] + b[9]) & 0xffff;
	        r[10] = (v = (v >>> 16) + a[10] + b[10]) & 0xffff;
	        r[11] = (v = (v >>> 16) + a[11] + b[11]) & 0xffff;
	        r[12] = (v = (v >>> 16) + a[12] + b[12]) & 0xffff;
	        r[13] = (v = (v >>> 16) + a[13] + b[13]) & 0xffff;
	        r[14] = (v = (v >>> 16) + a[14] + b[14]) & 0xffff;
	        r[15] = (v >>> 16) + (a[15] & 0x7fff) + (b[15] & 0x7fff);
	        return r;
	    }
	
	    function _submodp(a, b) {
	        var r = [];
	        var v;
	        r[0] = (v = 0x80000
	                    + ((0 | (a[15] >>> 15)) - (0 | (b[15] >>> 15)) - 1)
	                    * 19 + a[0] - b[0]) & 0xffff;
	        r[1] = (v = (v >>> 16) + 0x7fff8 + a[1] - b[1]) & 0xffff;
	        r[2] = (v = (v >>> 16) + 0x7fff8 + a[2] - b[2]) & 0xffff;
	        r[3] = (v = (v >>> 16) + 0x7fff8 + a[3] - b[3]) & 0xffff;
	        r[4] = (v = (v >>> 16) + 0x7fff8 + a[4] - b[4]) & 0xffff;
	        r[5] = (v = (v >>> 16) + 0x7fff8 + a[5] - b[5]) & 0xffff;
	        r[6] = (v = (v >>> 16) + 0x7fff8 + a[6] - b[6]) & 0xffff;
	        r[7] = (v = (v >>> 16) + 0x7fff8 + a[7] - b[7]) & 0xffff;
	        r[8] = (v = (v >>> 16) + 0x7fff8 + a[8] - b[8]) & 0xffff;
	        r[9] = (v = (v >>> 16) + 0x7fff8 + a[9] - b[9]) & 0xffff;
	        r[10] = (v = (v >>> 16) + 0x7fff8 + a[10] - b[10]) & 0xffff;
	        r[11] = (v = (v >>> 16) + 0x7fff8 + a[11] - b[11]) & 0xffff;
	        r[12] = (v = (v >>> 16) + 0x7fff8 + a[12] - b[12]) & 0xffff;
	        r[13] = (v = (v >>> 16) + 0x7fff8 + a[13] - b[13]) & 0xffff;
	        r[14] = (v = (v >>> 16) + 0x7fff8 + a[14] - b[14]) & 0xffff;
	        r[15] = (v >>> 16) + 0x7ff8 + (a[15] & 0x7fff)
	                - (b[15] & 0x7fff);
	        return r;
	    }
	
	    function _invmodp(a) {
	        var c = a;
	        var i = 250;
	        while (--i) {
	            a = _sqrmodp(a);
	            a = _mulmodp(a, c);
	        }
	        a = _sqrmodp(a);
	        a = _sqrmodp(a);
	        a = _mulmodp(a, c);
	        a = _sqrmodp(a);
	        a = _sqrmodp(a);
	        a = _mulmodp(a, c);
	        a = _sqrmodp(a);
	        a = _mulmodp(a, c);
	        return a;
	    }
	
	    function _mulasmall(a) {
	        // 'division by 0x10000' can not be replaced by '>> 16' because
	        // more than 32 bits of precision are needed
	        var m = 121665;
	        var r = [];
	        var v;
	        r[0] = (v = a[0] * m) & 0xffff;
	        r[1] = (v = (0 | (v / 0x10000)) + a[1] * m) & 0xffff;
	        r[2] = (v = (0 | (v / 0x10000)) + a[2] * m) & 0xffff;
	        r[3] = (v = (0 | (v / 0x10000)) + a[3] * m) & 0xffff;
	        r[4] = (v = (0 | (v / 0x10000)) + a[4] * m) & 0xffff;
	        r[5] = (v = (0 | (v / 0x10000)) + a[5] * m) & 0xffff;
	        r[6] = (v = (0 | (v / 0x10000)) + a[6] * m) & 0xffff;
	        r[7] = (v = (0 | (v / 0x10000)) + a[7] * m) & 0xffff;
	        r[8] = (v = (0 | (v / 0x10000)) + a[8] * m) & 0xffff;
	        r[9] = (v = (0 | (v / 0x10000)) + a[9] * m) & 0xffff;
	        r[10] = (v = (0 | (v / 0x10000)) + a[10] * m) & 0xffff;
	        r[11] = (v = (0 | (v / 0x10000)) + a[11] * m) & 0xffff;
	        r[12] = (v = (0 | (v / 0x10000)) + a[12] * m) & 0xffff;
	        r[13] = (v = (0 | (v / 0x10000)) + a[13] * m) & 0xffff;
	        r[14] = (v = (0 | (v / 0x10000)) + a[14] * m) & 0xffff;
	        r[15] = (0 | (v / 0x10000)) + a[15] * m;
	        _reduce(r);
	        return r;
	    }
	
	    function _dbl(x, z) {
	        var x_2, z_2, m, n, o;
	        m = _sqrmodp(_addmodp(x, z));
	        n = _sqrmodp(_submodp(x, z));
	        o = _submodp(m, n);
	        x_2 = _mulmodp(n, m);
	        z_2 = _mulmodp(_addmodp(_mulasmall(o), m), o);
	        return [x_2, z_2];
	    }
	
	    function _sum(x, z, x_p, z_p, x_1) {
	        var x_3, z_3, p, q;
	        p = _mulmodp(_submodp(x, z), _addmodp(x_p, z_p));
	        q = _mulmodp(_addmodp(x, z), _submodp(x_p, z_p));
	        x_3 = _sqrmodp(_addmodp(p, q));
	        z_3 = _mulmodp(_sqrmodp(_submodp(p, q)), x_1);
	        return [x_3, z_3];
	    }
	
	    function _generateKey(curve25519) {
	        var buffer = crypto.randomBytes(32);
	
	        // For Curve25519 DH keys, we need to apply some bit mask on generated
	        // keys:
	        // * clear bit 0, 1, 2 of first byte
	        // * clear bit 7 of last byte
	        // * set bit 6 of last byte
	        if (curve25519 === true) {
	            buffer[0] &= 0xf8;
	            buffer[31] = (buffer[31] & 0x7f) | 0x40;
	        }
	        var result = [];
	        for (var i = 0; i < buffer.length; i++) {
	            result.push(String.fromCharCode(buffer[i]));
	        }
	        return result.join('');
	    }
	
	    // Expose some functions to the outside through this name space.
	    // Note: This is not part of the public API.
	    ns.getbit = _getbit;
	    ns.setbit = _setbit;
	    ns.addmodp = _addmodp;
	    ns.invmodp = _invmodp;
	    ns.mulmodp = _mulmodp;
	    ns.reduce = _reduce;
	    ns.dbl = _dbl;
	    ns.sum = _sum;
	    ns.ZERO = _ZERO;
	    ns.ONE = _ONE;
	    ns.BASE = _BASE;
	    ns.bigintadd = _bigintadd;
	    ns.bigintsub = _bigintsub;
	    ns.bigintcmp = _bigintcmp;
	    ns.mulmodp = _mulmodp;
	    ns.sqrmodp = _sqrmodp;
	    ns.generateKey = _generateKey;
	
	
	module.exports = ns;


/***/ },
/* 664 */
/*!***********************************!*\
  !*** ./~/jodid25519/lib/utils.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileOverview
	 * A collection of general utility functions..
	 */
	
	/*
	 * Copyright (c) 2011, 2012, 2014 Ron Garret
	 * Copyright (c) 2007, 2013, 2014 Michele Bini
	 * Copyright (c) 2014 Mega Limited
	 * under the MIT License.
	 *
	 * Authors: Guy K. Kloss, Michele Bini, Ron Garret
	 *
	 * You should have received a copy of the license along with this program.
	 */
	
	var core = __webpack_require__(/*! ./core */ 663);
	
	    /**
	     * @exports jodid25519/utils
	     * A collection of general utility functions..
	     *
	     * @description
	     * A collection of general utility functions..
	     */
	    var ns = {};
	
	    var _HEXCHARS = "0123456789abcdef";
	
	    function _hexencode(vector) {
	        var result = [];
	        for (var i = vector.length - 1; i >= 0; i--) {
	            var value = vector[i];
	            result.push(_HEXCHARS.substr((value >>> 12) & 0x0f, 1));
	            result.push(_HEXCHARS.substr((value >>> 8) & 0x0f, 1));
	            result.push(_HEXCHARS.substr((value >>> 4) & 0x0f, 1));
	            result.push(_HEXCHARS.substr(value & 0x0f, 1));
	        }
	        return result.join('');
	    }
	
	    function _hexdecode(vector) {
	        var result = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	        for (var i = vector.length - 1, l = 0; i >= 0; i -= 4) {
	            result[l] = (_HEXCHARS.indexOf(vector.charAt(i)))
	                      | (_HEXCHARS.indexOf(vector.charAt(i - 1)) << 4)
	                      | (_HEXCHARS.indexOf(vector.charAt(i - 2)) << 8)
	                      | (_HEXCHARS.indexOf(vector.charAt(i - 3)) << 12);
	            l++;
	        }
	        return result;
	    }
	
	    var _BASE32CHARS = "abcdefghijklmnopqrstuvwxyz234567";
	
	    var _BASE32VALUES = (function () {
	        var result = {};
	        for (var i = 0; i < _BASE32CHARS.length; i++) {
	            result[_BASE32CHARS.charAt(i)] = i;
	        }
	        return result;
	    })();
	
	    function _base32encode(n) {
	        var c;
	        var r = "";
	        for (c = 0; c < 255; c += 5) {
	            r = _BASE32CHARS.substr(core.getbit(n, c)
	                                    + (core.getbit(n, c + 1) << 1)
	                                    + (core.getbit(n, c + 2) << 2)
	                                    + (core.getbit(n, c + 3) << 3)
	                                    + (core.getbit(n, c + 4) << 4), 1)
	                                    + r;
	        }
	        return r;
	    }
	
	    function _base32decode(n) {
	        var c = 0;
	        var r = core.ZERO();
	        var l = n.length;
	        for (c = 0; (l > 0) && (c < 255); c += 5) {
	            l--;
	            var v = _BASE32VALUES[n.substr(l, 1)];
	            core.setbit(r, c, v & 1);
	            v >>= 1;
	            core.setbit(r, c + 1, v & 1);
	            v >>= 1;
	            core.setbit(r, c + 2, v & 1);
	            v >>= 1;
	            core.setbit(r, c + 3, v & 1);
	            v >>= 1;
	            core.setbit(r, c + 4, v & 1);
	           }
	        return r;
	    }
	
	    function _map(f, l) {
	        var result = new Array(l.length);
	        for (var i = 0; i < l.length; i++) {
	            result[i] = f(l[i]);
	        }
	        return result;
	    }
	
	    function _chr(n) {
	        return String.fromCharCode(n);
	    }
	
	    function _ord(c) {
	        return c.charCodeAt(0);
	    }
	
	    function _bytes2string(bytes) {
	        return _map(_chr, bytes).join('');
	    }
	
	    function _string2bytes(s) {
	        return _map(_ord, s);
	    }
	
	
	    // Expose some functions to the outside through this name space.
	
	    /**
	     * Encodes an array of unsigned 8-bit integers to a hex string.
	     *
	     * @function
	     * @param vector {array}
	     *     Array containing the byte values.
	     * @returns {string}
	     *     String containing vector in a hexadecimal representation.
	     */
	    ns.hexEncode = _hexencode;
	
	
	    /**
	     * Decodes a hex string to an array of unsigned 8-bit integers.
	     *
	     * @function
	     * @param vector {string}
	     *     String containing vector in a hexadecimal representation.
	     * @returns {array}
	     *     Array containing the byte values.
	     */
	    ns.hexDecode = _hexdecode;
	
	
	    /**
	     * Encodes an array of unsigned 8-bit integers using base32 encoding.
	     *
	     * @function
	     * @param vector {array}
	     *     Array containing the byte values.
	     * @returns {string}
	     *     String containing vector in a hexadecimal representation.
	     */
	    ns.base32encode = _base32encode;
	
	
	    /**
	     * Decodes a base32 encoded string to an array of unsigned 8-bit integers.
	     *
	     * @function
	     * @param vector {string}
	     *     String containing vector in a hexadecimal representation.
	     * @returns {array}
	     *     Array containing the byte values.
	     */
	    ns.base32decode = _base32decode;
	
	
	    /**
	     * Converts an unsigned 8-bit integer array representation to a byte string.
	     *
	     * @function
	     * @param vector {array}
	     *     Array containing the byte values.
	     * @returns {string}
	     *     Byte string representation of vector.
	     */
	    ns.bytes2string = _bytes2string;
	
	
	    /**
	     * Converts a byte string representation to an array of unsigned
	     * 8-bit integers.
	     *
	     * @function
	     * @param vector {array}
	     *     Array containing the byte values.
	     * @returns {string}
	     *     Byte string representation of vector.
	     */
	    ns.string2bytes = _string2bytes;
	
	module.exports = ns;


/***/ },
/* 665 */
/*!**************************************!*\
  !*** ./~/jodid25519/lib/curve255.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileOverview
	 * Core operations on curve 25519 required for the higher level modules.
	 */
	
	/*
	 * Copyright (c) 2007, 2013, 2014 Michele Bini
	 * Copyright (c) 2014 Mega Limited
	 * under the MIT License.
	 *
	 * Authors: Guy K. Kloss, Michele Bini
	 *
	 * You should have received a copy of the license along with this program.
	 */
	
	var core = __webpack_require__(/*! ./core */ 663);
	var utils = __webpack_require__(/*! ./utils */ 664);
	
	    /**
	     * @exports jodid25519/curve255
	     * Legacy compatibility module for Michele Bini's previous curve255.js.
	     *
	     * @description
	     * Legacy compatibility module for Michele Bini's previous curve255.js.
	     *
	     * <p>
	     * This code presents an API with all key formats as previously available
	     * from Michele Bini's curve255.js implementation.
	     * </p>
	     */
	    var ns = {};
	
	    function curve25519_raw(f, c) {
	        var a, x_1, q;
	
	        x_1 = c;
	        a = core.dbl(x_1, core.ONE());
	        q = [x_1, core.ONE()];
	
	        var n = 255;
	
	        while (core.getbit(f, n) == 0) {
	            n--;
	            // For correct constant-time operation, bit 255 should always be
	            // set to 1 so the following 'while' loop is never entered.
	            if (n < 0) {
	                return core.ZERO();
	            }
	        }
	        n--;
	
	        var aq = [a, q];
	
	        while (n >= 0) {
	            var r, s;
	            var b = core.getbit(f, n);
	            r = core.sum(aq[0][0], aq[0][1], aq[1][0], aq[1][1], x_1);
	            s = core.dbl(aq[1 - b][0], aq[1 - b][1]);
	            aq[1 - b] = s;
	            aq[b] = r;
	            n--;
	        }
	        q = aq[1];
	
	        q[1] = core.invmodp(q[1]);
	        q[0] = core.mulmodp(q[0], q[1]);
	        core.reduce(q[0]);
	        return q[0];
	    }
	
	    function curve25519b32(a, b) {
	        return _base32encode(curve25519(_base32decode(a),
	                                        _base32decode(b)));
	    }
	
	    function curve25519(f, c) {
	        if (!c) {
	            c = core.BASE();
	        }
	        f[0] &= 0xFFF8;
	        f[15] = (f[15] & 0x7FFF) | 0x4000;
	        return curve25519_raw(f, c);
	    }
	
	    function _hexEncodeVector(k) {
	        var hexKey = utils.hexEncode(k);
	        // Pad with '0' at the front.
	        hexKey = new Array(64 + 1 - hexKey.length).join('0') + hexKey;
	        // Invert bytes.
	        return hexKey.split(/(..)/).reverse().join('');
	    }
	
	    function _hexDecodeVector(v) {
	        // assert(length(x) == 64);
	        // Invert bytes.
	        var hexKey = v.split(/(..)/).reverse().join('');
	        return utils.hexDecode(hexKey);
	    }
	
	
	    // Expose some functions to the outside through this name space.
	
	    /**
	     * Computes the scalar product of a point on the curve 25519.
	     *
	     * This function is used for the DH key-exchange protocol.
	     *
	     * Before multiplication, some bit operations are applied to the
	     * private key to ensure it is a valid Curve25519 secret key.
	     * It is the user's responsibility to make sure that the private
	     * key is a uniformly random, secret value.
	     *
	     * @function
	     * @param f {array}
	     *     Private key.
	     * @param c {array}
	     *     Public point on the curve. If not given, the curve's base point is used.
	     * @returns {array}
	     *     Key point resulting from scalar product.
	     */
	    ns.curve25519 = curve25519;
	
	    /**
	     * Computes the scalar product of a point on the curve 25519.
	     *
	     * This variant does not make sure that the private key is valid.
	     * The user has the responsibility to ensure the private key is
	     * valid or that this results in a safe protocol.  Unless you know
	     * exactly what you are doing, you should not use this variant,
	     * please use 'curve25519' instead.
	     *
	     * @function
	     * @param f {array}
	     *     Private key.
	     * @param c {array}
	     *     Public point on the curve. If not given, the curve's base point is used.
	     * @returns {array}
	     *     Key point resulting from scalar product.
	     */
	    ns.curve25519_raw = curve25519_raw;
	
	    /**
	     * Encodes the internal representation of a key to a canonical hex
	     * representation.
	     *
	     * This is the format commonly used in other libraries and for
	     * test vectors, and is equivalent to the hex dump of the key in
	     * little-endian binary format.
	     *
	     * @function
	     * @param n {array}
	     *     Array representation of key.
	     * @returns {string}
	     *     Hexadecimal string representation of key.
	     */
	    ns.hexEncodeVector = _hexEncodeVector;
	
	    /**
	     * Decodes a canonical hex representation of a key
	     * to an internally compatible array representation.
	     *
	     * @function
	     * @param n {string}
	     *     Hexadecimal string representation of key.
	     * @returns {array}
	     *     Array representation of key.
	     */
	    ns.hexDecodeVector = _hexDecodeVector;
	
	    /**
	     * Encodes the internal representation of a key into a
	     * hexadecimal representation.
	     *
	     * This is a strict positional notation, most significant digit first.
	     *
	     * @function
	     * @param n {array}
	     *     Array representation of key.
	     * @returns {string}
	     *     Hexadecimal string representation of key.
	     */
	    ns.hexencode = utils.hexEncode;
	
	    /**
	     * Decodes a hex representation of a key to an internally
	     * compatible array representation.
	     *
	     * @function
	     * @param n {string}
	     *     Hexadecimal string representation of key.
	     * @returns {array}
	     *     Array representation of key.
	     */
	    ns.hexdecode = utils.hexDecode;
	
	    /**
	     * Encodes the internal representation of a key to a base32
	     * representation.
	     *
	     * @function
	     * @param n {array}
	     *     Array representation of key.
	     * @returns {string}
	     *     Base32 string representation of key.
	     */
	    ns.base32encode = utils.base32encode;
	
	    /**
	     * Decodes a base32 representation of a key to an internally
	     * compatible array representation.
	     *
	     * @function
	     * @param n {string}
	     *     Base32 string representation of key.
	     * @returns {array}
	     *     Array representation of key.
	     */
	    ns.base32decode = utils.base32decode;
	
	module.exports = ns;


/***/ },
/* 666 */
/*!***********************************!*\
  !*** ./~/jodid25519/lib/eddsa.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * @fileOverview
	 * Digital signature scheme based on Curve25519 (Ed25519 or EdDSA).
	 */
	
	/*
	 * Copyright (c) 2011, 2012, 2014 Ron Garret
	 * Copyright (c) 2014 Mega Limited
	 * under the MIT License.
	 *
	 * Authors: Guy K. Kloss, Ron Garret
	 *
	 * You should have received a copy of the license along with this program.
	 */
	
	var core = __webpack_require__(/*! ./core */ 663);
	var curve255 = __webpack_require__(/*! ./curve255 */ 665);
	var utils = __webpack_require__(/*! ./utils */ 664);
	var BigInteger = __webpack_require__(/*! jsbn */ 667).BigInteger;
	var crypto = __webpack_require__(/*! crypto */ 601);
	
	    /**
	     * @exports jodid25519/eddsa
	     * Digital signature scheme based on Curve25519 (Ed25519 or EdDSA).
	     *
	     * @description
	     * Digital signature scheme based on Curve25519 (Ed25519 or EdDSA).
	     *
	     * <p>
	     * This code is adapted from fast-djbec.js, a faster but more complicated
	     * version of the Ed25519 encryption scheme (as compared to djbec.js).
	     * It uses two different representations for big integers: The jsbn
	     * BigInteger class, which can represent arbitrary-length numbers, and a
	     * special fixed-length representation optimised for 256-bit integers.
	     * The reason both are needed is that the Ed25519 algorithm requires some
	     * 512-bit numbers.</p>
	    */
	    var ns = {};
	
	    function _bi255(value) {
	        if (!(this instanceof _bi255)) {
	            return new _bi255(value);
	        }
	        if (typeof value === 'undefined') {
	            return _ZERO;
	        }
	        var c = value.constructor;
	        if ((c === Array || c === Uint16Array || c === Uint32Array) && (value.length === 16)) {
	            this.n = value;
	        } else if ((c === Array) && (value.length === 32)) {
	            this.n = _bytes2bi255(value).n;
	        } else if (c === String) {
	            this.n = utils.hexDecode(value);
	        } else if (c === Number) {
	            this.n = [value & 0xffff,
	                      value >> 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	        } else if (value instanceof _bi255) {
	            this.n = value.n.slice(0); // Copy constructor
	        } else {
	            throw "Bad argument for bignum: " + value;
	        }
	    }
	
	   _bi255.prototype = {
	        'toString' : function() {
	            return utils.hexEncode(this.n);
	        },
	        'toSource' : function() {
	            return '_' + utils.hexEncode(this.n);
	        },
	        'plus' : function(n1) {
	            return _bi255(core.bigintadd(this.n, n1.n));
	        },
	        'minus' : function(n1) {
	            return _bi255(core.bigintsub(this.n, n1.n)).modq();
	        },
	        'times' : function(n1) {
	            return _bi255(core.mulmodp(this.n, n1.n));
	        },
	        'divide' : function(n1) {
	            return this.times(n1.inv());
	        },
	        'sqr' : function() {
	            return _bi255(core.sqrmodp(this.n));
	        },
	        'cmp' : function(n1) {
	            return core.bigintcmp(this.n, n1.n);
	        },
	        'equals' : function(n1) {
	            return this.cmp(n1) === 0;
	        },
	        'isOdd' : function() {
	            return (this.n[0] & 1) === 1;
	        },
	        'shiftLeft' : function(cnt) {
	            _shiftL(this.n, cnt);
	            return this;
	        },
	        'shiftRight' : function(cnt) {
	            _shiftR(this.n, cnt);
	            return this;
	        },
	        'inv' : function() {
	            return _bi255(core.invmodp(this.n));
	        },
	        'pow' : function(e) {
	            return _bi255(_pow(this.n, e.n));
	        },
	        'modq' : function() {
	            return _modq(this);
	        },
	        'bytes' : function() {
	            return _bi255_bytes(this);
	        }
	    };
	
	    function _shiftL(n, cnt) {
	        var lastcarry = 0;
	        for (var i = 0; i < 16; i++) {
	            var carry = n[i] >> (16 - cnt);
	            n[i] = (n[i] << cnt) & 0xffff | lastcarry;
	            lastcarry = carry;
	        }
	        return n;
	    }
	
	    function _shiftR(n, cnt) {
	        var lastcarry = 0;
	        for (var i = 15; i >= 0; i--) {
	            var carry = n[i] << (16 - cnt) & 0xffff;
	            n[i] = (n[i] >> cnt) | lastcarry;
	            lastcarry = carry;
	        }
	        return n;
	    }
	
	    function _bi255_bytes(n) {
	        n = _bi255(n); // Make a copy because shiftRight is destructive
	        var a = new Array(32);
	        for (var i = 31; i >= 0; i--) {
	            a[i] = n.n[0] & 0xff;
	            n.shiftRight(8);
	        }
	        return a;
	    }
	
	    function _bytes2bi255(a) {
	        var n = _ZERO;
	        for (var i = 0; i < 32; i++) {
	            n.shiftLeft(8);
	            n = n.plus(_bi255(a[i]));
	        }
	        return n;
	    }
	
	    function _pow(n, e) {
	        var result = core.ONE();
	        for (var i = 0; i < 256; i++) {
	            if (core.getbit(e, i) === 1) {
	                result = core.mulmodp(result, n);
	            }
	            n = core.sqrmodp(n);
	        }
	        return result;
	    }
	
	    var _ZERO = _bi255(0);
	    var _ONE = _bi255(1);
	    var _TWO = _bi255(2);
	    // This is the core prime.
	    var _Q = _bi255([0xffff - 18, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	                     0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
	                     0xffff, 0xffff, 0x7fff]);
	
	    function _modq(n) {
	        core.reduce(n.n);
	        if (n.cmp(_Q) >= 0) {
	            return _modq(n.minus(_Q));
	        }
	        if (n.cmp(_ZERO) === -1) {
	            return _modq(n.plus(_Q));
	        } else {
	            return n;
	        }
	    }
	
	    // _RECOVERY_EXPONENT = _Q.plus(_bi255(3)).divide(_bi255(8));
	    var _RECOVERY_EXPONENT = _bi255('0ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe');
	    // _D = _Q.minus(_bi255(121665)).divide(_bi255(121666));
	    var _D = _bi255('52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3');
	    // _I = _TWO.pow(_Q.minus(_ONE).divide(_bi255(4)));
	    var _I = _bi255('2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0');
	    // _L = _TWO.pow(_bi255(252)).plus(_bi255('14def9dea2f79cd65812631a5cf5d3ed'));
	    var _L = _bi255('1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed');
	    var _L_BI = _bi('1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed', 16);
	
	
	    // ////////////////////////////////////////////////////////////
	
	    function _isoncurve(p) {
	        var x = p[0];
	        var y = p[1];
	        var xsqr = x.sqr();
	        var ysqr = y.sqr();
	        var v = _D.times(xsqr).times(ysqr);
	        return ysqr.minus(xsqr).minus(_ONE).minus(v).modq().equals(_ZERO);
	    }
	
	    function _xrecover(y) {
	        var ysquared = y.sqr();
	        var xx = ysquared.minus(_ONE).divide(_ONE.plus(_D.times(ysquared)));
	        var x = xx.pow(_RECOVERY_EXPONENT);
	        if (!(x.times(x).minus(xx).equals(_ZERO))) {
	            x = x.times(_I);
	        }
	        if (x.isOdd()) {
	            x = _Q.minus(x);
	        }
	        return x;
	    }
	
	    function _x_pt_add(pt1, pt2) {
	        var x1 = pt1[0];
	        var y1 = pt1[1];
	        var z1 = pt1[2];
	        var t1 = pt1[3];
	        var x2 = pt2[0];
	        var y2 = pt2[1];
	        var z2 = pt2[2];
	        var t2 = pt2[3];
	        var A = y1.minus(x1).times(y2.plus(x2));
	        var B = y1.plus(x1).times(y2.minus(x2));
	        var C = z1.times(_TWO).times(t2);
	        var D = t1.times(_TWO).times(z2);
	        var E = D.plus(C);
	        var F = B.minus(A);
	        var G = B.plus(A);
	        var H = D.minus(C);
	        return [E.times(F), G.times(H), F.times(G), E.times(H)];
	    }
	
	    function _xpt_double(pt1) {
	        var x1 = pt1[0];
	        var y1 = pt1[1];
	        var z1 = pt1[2];
	        var A = x1.times(x1);
	        var B = y1.times(y1);
	        var C = _TWO.times(z1).times(z1);
	        var D = _Q.minus(A);
	        var J = x1.plus(y1);
	        var E = J.times(J).minus(A).minus(B);
	        var G = D.plus(B);
	        var F = G.minus(C);
	        var H = D.minus(B);
	        return [E.times(F), G.times(H), F.times(G), E.times(H)];
	    }
	
	    function _xpt_mult(pt, n) {
	        if (n.equals(_ZERO)) {
	            return [_ZERO, _ONE, _ONE, _ZERO];
	        }
	        var odd = n.isOdd();
	        n.shiftRight(1);
	        var value = _xpt_double(_xpt_mult(pt, n));
	        return odd ? _x_pt_add(value, pt) : value;
	    }
	
	    function _pt_xform(pt) {
	        var x = pt[0];
	        var y = pt[1];
	        return [x, y, _ONE, x.times(y)];
	    }
	
	    function _pt_unxform(pt) {
	        var x = pt[0];
	        var y = pt[1];
	        var z = pt[2];
	        var invz = z.inv();
	        return [x.times(invz), y.times(invz)];
	    }
	
	    function _scalarmult(pt, n) {
	        return _pt_unxform(_xpt_mult(_pt_xform(pt), n));
	    }
	
	    function _bytesgetbit(bytes, n) {
	        return (bytes[bytes.length - (n >>> 3) - 1] >> (n & 7)) & 1;
	    }
	
	    function _xpt_mult_bytes(pt, bytes) {
	        var r = [_ZERO, _ONE, _ONE, _ZERO];
	        for (var i = (bytes.length << 3) - 1; i >= 0; i--) {
	            r = _xpt_double(r);
	            if (_bytesgetbit(bytes, i) === 1) {
	                r = _x_pt_add(r, pt);
	            }
	        }
	        return r;
	    }
	
	    function _scalarmultBytes(pt, bytes) {
	        return _pt_unxform(_xpt_mult_bytes(_pt_xform(pt), bytes));
	    }
	
	    var _by = _bi255(4).divide(_bi255(5));
	    var _bx = _xrecover(_by);
	    var _bp = [_bx, _by];
	
	    function _encodeint(n) {
	        return n.bytes(32).reverse();
	    }
	    function _decodeint(b) {
	        return _bi255(b.slice(0).reverse());
	    }
	
	    function _encodepoint(p) {
	        var v = _encodeint(p[1]);
	        if (p[0].isOdd()) {
	            v[31] |= 0x80;
	        }
	        return v;
	    }
	
	    function _decodepoint(v) {
	        v = v.slice(0);
	        var signbit = v[31] >> 7;
	        v[31] &= 127;
	        var y = _decodeint(v);
	        var x = _xrecover(y);
	        if ((x.n[0] & 1) !== signbit) {
	            x = _Q.minus(x);
	        }
	        var p = [x, y];
	        if (!_isoncurve(p)) {
	            throw ('Point is not on curve');
	        }
	        return p;
	    }
	
	    // //////////////////////////////////////////////////
	
	    /**
	     * Factory function to create a suitable BigInteger.
	     *
	     * @param value
	     *     The value for the big integer.
	     * @param base {integer}
	     *     Base of the conversion of elements in ``value``.
	     * @returns
	     *     A BigInteger object.
	     */
	    function _bi(value, base) {
	        if (base !== undefined) {
	            if (base === 256) {
	                return _bi(utils.string2bytes(value));
	            }
	            return new BigInteger(value, base);
	        } else if (typeof value === 'string') {
	            return new BigInteger(value, 10);
	        } else if ((value instanceof Array) || (value instanceof Uint8Array)
	          || Buffer.isBuffer(value)) {
	            return new BigInteger(value);
	        } else if (typeof value === 'number') {
	            return new BigInteger(value.toString(), 10);
	        } else {
	            throw "Can't convert " + value + " to BigInteger";
	        }
	    }
	
	    function _bi2bytes(n, cnt) {
	        if (cnt === undefined) {
	            cnt = (n.bitLength() + 7) >>> 3;
	        }
	        var bytes = new Array(cnt);
	        for (var i = cnt - 1; i >= 0; i--) {
	            bytes[i] = n[0] & 255; // n.and(0xff);
	            n = n.shiftRight(8);
	        }
	        return bytes;
	    }
	
	    BigInteger.prototype.bytes = function(n) {
	        return _bi2bytes(this, n);
	    };
	
	    // /////////////////////////////////////////////////////////
	
	    function _bytehash(s) {
	        var sha = crypto.createHash('sha512').update(s).digest();
	        return _bi2bytes(_bi(sha), 64).reverse();
	    }
	
	    function _stringhash(s) {
	        var sha = crypto.createHash('sha512').update(s).digest();
	        return _map(_chr, _bi2bytes(_bi(sha), 64)).join('');
	    }
	
	    function _inthash(s) {
	        // Need a leading 0 to prevent sign extension
	        return _bi([0].concat(_bytehash(s)));
	    }
	
	    function _inthash_lo(s) {
	        return _bi255(_bytehash(s).slice(32, 64));
	    }
	
	    function _inthash_mod_l(s) {
	        return _inthash(s).mod(_L_BI);
	    }
	
	    function _get_a(sk) {
	        var a = _inthash_lo(sk);
	        a.n[0] &= 0xfff8;
	        a.n[15] &= 0x3fff;
	        a.n[15] |= 0x4000;
	        return a;
	    }
	
	    function _publickey(sk) {
	        return _encodepoint(_scalarmult(_bp, _get_a(sk)));
	    }
	
	    function _map(f, l) {
	        var result = new Array(l.length);
	        for (var i = 0; i < l.length; i++) {
	            result[i] = f(l[i]);
	        }
	        return result;
	    }
	
	    function _chr(n) {
	        return String.fromCharCode(n);
	    }
	
	    function _ord(c) {
	        return c.charCodeAt(0);
	    }
	
	    function _pt_add(p1, p2) {
	        return _pt_unxform(_x_pt_add(_pt_xform(p1), _pt_xform(p2)));
	    }
	
	
	    // Exports for the API.
	
	    /**
	     * Checks whether a point is on the curve.
	     *
	     * @function
	     * @param point {string}
	     *     The point to check for in a byte string representation.
	     * @returns {boolean}
	     *     true if the point is on the curve, false otherwise.
	     */
	    ns.isOnCurve = function(point) {
	        try {
	            _isoncurve(_decodepoint(utils.string2bytes(point)));
	        } catch(e) {
	            if (e === 'Point is not on curve') {
	                return false;
	            } else {
	                throw e;
	            }
	        }
	        return true;
	    };
	
	
	    /**
	     * Computes the EdDSA public key.
	     *
	     * <p>Note: Seeds should be a byte string, not a unicode string containing
	     * multi-byte characters.</p>
	     *
	     * @function
	     * @param keySeed {string}
	     *     Private key seed in the form of a byte string.
	     * @returns {string}
	     *     Public key as byte string computed from the private key seed
	     *     (32 bytes).
	     */
	    ns.publicKey = function(keySeed) {
	        return utils.bytes2string(_publickey(keySeed));
	    };
	
	
	    /**
	     * Computes an EdDSA signature of a message.
	     *
	     * <p>Notes:</p>
	     *
	     * <ul>
	     *   <li>Unicode messages need to be converted to a byte representation
	     *   (e. g. UTF-8).</li>
	     *   <li>If `publicKey` is given, and it is *not* a point of the curve,
	     *   the signature will be faulty, but no error will be thrown.</li>
	     * </ul>
	     *
	     * @function
	     * @param message {string}
	     *     Message in the form of a byte string.
	     * @param keySeed {string}
	     *     Private key seed in the form of a byte string.
	     * @param publicKey {string}
	     *     Public key as byte string (if not present, it will be computed from
	     *     the private key seed).
	     * @returns {string}
	     *     Detached message signature in the form of a byte string (64 bytes).
	     */
	    ns.sign = function(message, keySeed, publicKey) {
	        if (publicKey === undefined) {
	            publicKey = _publickey(keySeed);
	        } else {
	            publicKey = utils.string2bytes(publicKey);
	        }
	        var a = _bi(_get_a(keySeed).toString(), 16);
	        var hs = _stringhash(keySeed);
	        var r = _bytehash(hs.slice(32, 64) + message);
	        var rp = _scalarmultBytes(_bp, r);
	        var erp = _encodepoint(rp);
	        r = _bi(r).mod(_bi(1, 10).shiftLeft(512));
	        var s = _map(_chr, erp).join('') + _map(_chr, publicKey).join('') + message;
	        s = _inthash_mod_l(s).multiply(a).add(r).mod(_L_BI);
	        return utils.bytes2string(erp.concat(_encodeint(s)));
	    };
	
	
	    /**
	     * Verifies an EdDSA signature of a message with the public key.
	     *
	     * <p>Note: Unicode messages need to be converted to a byte representation
	     * (e. g. UTF-8).</p>
	     *
	     * @function
	     * @param signature {string}
	     *     Message signature in the form of a byte string. Can be detached
	     *     (64 bytes), or attached to be sliced off.
	     * @param message {string}
	     *     Message in the form of a byte string.
	     * @param publicKey {string}
	     *     Public key as byte string (if not present, it will be computed from
	     *     the private key seed).
	     * @returns {boolean}
	     *     true, if the signature verifies.
	     */
	    ns.verify = function(signature, message, publicKey) {
	        signature = utils.string2bytes(signature.slice(0, 64));
	        publicKey = utils.string2bytes(publicKey);
	        var rpe = signature.slice(0, 32);
	        var rp = _decodepoint(rpe);
	        var a = _decodepoint(publicKey);
	        var s = _decodeint(signature.slice(32, 64));
	        var h = _inthash(utils.bytes2string(rpe.concat(publicKey)) + message);
	        var v1 = _scalarmult(_bp, s);
	        var value = _scalarmultBytes(a, _bi2bytes(h));
	        var v2 = _pt_add(rp, value);
	        return v1[0].equals(v2[0]) && v1[1].equals(v2[1]);
	    };
	
	
	    /**
	     * Generates a new random private key seed of 32 bytes length (256 bit).
	     *
	     * @function
	     * @returns {string}
	     *     Byte string containing a new random private key seed.
	     */
	    ns.generateKeySeed = function() {
	        return core.generateKey(false);
	    };
	
	module.exports = ns;


/***/ },
/* 667 */
/*!*************************!*\
  !*** ./~/jsbn/index.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	(function(){
	
	    // Copyright (c) 2005  Tom Wu
	    // All Rights Reserved.
	    // See "LICENSE" for details.
	
	    // Basic JavaScript BN library - subset useful for RSA encryption.
	
	    // Bits per digit
	    var dbits;
	
	    // JavaScript engine analysis
	    var canary = 0xdeadbeefcafe;
	    var j_lm = ((canary&0xffffff)==0xefcafe);
	
	    // (public) Constructor
	    function BigInteger(a,b,c) {
	      if(a != null)
	        if("number" == typeof a) this.fromNumber(a,b,c);
	        else if(b == null && "string" != typeof a) this.fromString(a,256);
	        else this.fromString(a,b);
	    }
	
	    // return new, unset BigInteger
	    function nbi() { return new BigInteger(null); }
	
	    // am: Compute w_j += (x*this_i), propagate carries,
	    // c is initial carry, returns final carry.
	    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
	    // We need to select the fastest one that works in this environment.
	
	    // am1: use a single mult and divide to get the high bits,
	    // max digit bits should be 26 because
	    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
	    function am1(i,x,w,j,c,n) {
	      while(--n >= 0) {
	        var v = x*this[i++]+w[j]+c;
	        c = Math.floor(v/0x4000000);
	        w[j++] = v&0x3ffffff;
	      }
	      return c;
	    }
	    // am2 avoids a big mult-and-extract completely.
	    // Max digit bits should be <= 30 because we do bitwise ops
	    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
	    function am2(i,x,w,j,c,n) {
	      var xl = x&0x7fff, xh = x>>15;
	      while(--n >= 0) {
	        var l = this[i]&0x7fff;
	        var h = this[i++]>>15;
	        var m = xh*l+h*xl;
	        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
	        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
	        w[j++] = l&0x3fffffff;
	      }
	      return c;
	    }
	    // Alternately, set max digit bits to 28 since some
	    // browsers slow down when dealing with 32-bit numbers.
	    function am3(i,x,w,j,c,n) {
	      var xl = x&0x3fff, xh = x>>14;
	      while(--n >= 0) {
	        var l = this[i]&0x3fff;
	        var h = this[i++]>>14;
	        var m = xh*l+h*xl;
	        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
	        c = (l>>28)+(m>>14)+xh*h;
	        w[j++] = l&0xfffffff;
	      }
	      return c;
	    }
	    var inBrowser = typeof navigator !== "undefined";
	    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
	      BigInteger.prototype.am = am2;
	      dbits = 30;
	    }
	    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
	      BigInteger.prototype.am = am1;
	      dbits = 26;
	    }
	    else { // Mozilla/Netscape seems to prefer am3
	      BigInteger.prototype.am = am3;
	      dbits = 28;
	    }
	
	    BigInteger.prototype.DB = dbits;
	    BigInteger.prototype.DM = ((1<<dbits)-1);
	    BigInteger.prototype.DV = (1<<dbits);
	
	    var BI_FP = 52;
	    BigInteger.prototype.FV = Math.pow(2,BI_FP);
	    BigInteger.prototype.F1 = BI_FP-dbits;
	    BigInteger.prototype.F2 = 2*dbits-BI_FP;
	
	    // Digit conversions
	    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	    var BI_RC = new Array();
	    var rr,vv;
	    rr = "0".charCodeAt(0);
	    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	    rr = "a".charCodeAt(0);
	    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	    rr = "A".charCodeAt(0);
	    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	
	    function int2char(n) { return BI_RM.charAt(n); }
	    function intAt(s,i) {
	      var c = BI_RC[s.charCodeAt(i)];
	      return (c==null)?-1:c;
	    }
	
	    // (protected) copy this to r
	    function bnpCopyTo(r) {
	      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
	      r.t = this.t;
	      r.s = this.s;
	    }
	
	    // (protected) set from integer value x, -DV <= x < DV
	    function bnpFromInt(x) {
	      this.t = 1;
	      this.s = (x<0)?-1:0;
	      if(x > 0) this[0] = x;
	      else if(x < -1) this[0] = x+this.DV;
	      else this.t = 0;
	    }
	
	    // return bigint initialized to value
	    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }
	
	    // (protected) set from string and radix
	    function bnpFromString(s,b) {
	      var k;
	      if(b == 16) k = 4;
	      else if(b == 8) k = 3;
	      else if(b == 256) k = 8; // byte array
	      else if(b == 2) k = 1;
	      else if(b == 32) k = 5;
	      else if(b == 4) k = 2;
	      else { this.fromRadix(s,b); return; }
	      this.t = 0;
	      this.s = 0;
	      var i = s.length, mi = false, sh = 0;
	      while(--i >= 0) {
	        var x = (k==8)?s[i]&0xff:intAt(s,i);
	        if(x < 0) {
	          if(s.charAt(i) == "-") mi = true;
	          continue;
	        }
	        mi = false;
	        if(sh == 0)
	          this[this.t++] = x;
	        else if(sh+k > this.DB) {
	          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
	          this[this.t++] = (x>>(this.DB-sh));
	        }
	        else
	          this[this.t-1] |= x<<sh;
	        sh += k;
	        if(sh >= this.DB) sh -= this.DB;
	      }
	      if(k == 8 && (s[0]&0x80) != 0) {
	        this.s = -1;
	        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
	      }
	      this.clamp();
	      if(mi) BigInteger.ZERO.subTo(this,this);
	    }
	
	    // (protected) clamp off excess high words
	    function bnpClamp() {
	      var c = this.s&this.DM;
	      while(this.t > 0 && this[this.t-1] == c) --this.t;
	    }
	
	    // (public) return string representation in given radix
	    function bnToString(b) {
	      if(this.s < 0) return "-"+this.negate().toString(b);
	      var k;
	      if(b == 16) k = 4;
	      else if(b == 8) k = 3;
	      else if(b == 2) k = 1;
	      else if(b == 32) k = 5;
	      else if(b == 4) k = 2;
	      else return this.toRadix(b);
	      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
	      var p = this.DB-(i*this.DB)%k;
	      if(i-- > 0) {
	        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
	        while(i >= 0) {
	          if(p < k) {
	            d = (this[i]&((1<<p)-1))<<(k-p);
	            d |= this[--i]>>(p+=this.DB-k);
	          }
	          else {
	            d = (this[i]>>(p-=k))&km;
	            if(p <= 0) { p += this.DB; --i; }
	          }
	          if(d > 0) m = true;
	          if(m) r += int2char(d);
	        }
	      }
	      return m?r:"0";
	    }
	
	    // (public) -this
	    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }
	
	    // (public) |this|
	    function bnAbs() { return (this.s<0)?this.negate():this; }
	
	    // (public) return + if this > a, - if this < a, 0 if equal
	    function bnCompareTo(a) {
	      var r = this.s-a.s;
	      if(r != 0) return r;
	      var i = this.t;
	      r = i-a.t;
	      if(r != 0) return (this.s<0)?-r:r;
	      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
	      return 0;
	    }
	
	    // returns bit length of the integer x
	    function nbits(x) {
	      var r = 1, t;
	      if((t=x>>>16) != 0) { x = t; r += 16; }
	      if((t=x>>8) != 0) { x = t; r += 8; }
	      if((t=x>>4) != 0) { x = t; r += 4; }
	      if((t=x>>2) != 0) { x = t; r += 2; }
	      if((t=x>>1) != 0) { x = t; r += 1; }
	      return r;
	    }
	
	    // (public) return the number of bits in "this"
	    function bnBitLength() {
	      if(this.t <= 0) return 0;
	      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
	    }
	
	    // (protected) r = this << n*DB
	    function bnpDLShiftTo(n,r) {
	      var i;
	      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
	      for(i = n-1; i >= 0; --i) r[i] = 0;
	      r.t = this.t+n;
	      r.s = this.s;
	    }
	
	    // (protected) r = this >> n*DB
	    function bnpDRShiftTo(n,r) {
	      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
	      r.t = Math.max(this.t-n,0);
	      r.s = this.s;
	    }
	
	    // (protected) r = this << n
	    function bnpLShiftTo(n,r) {
	      var bs = n%this.DB;
	      var cbs = this.DB-bs;
	      var bm = (1<<cbs)-1;
	      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
	      for(i = this.t-1; i >= 0; --i) {
	        r[i+ds+1] = (this[i]>>cbs)|c;
	        c = (this[i]&bm)<<bs;
	      }
	      for(i = ds-1; i >= 0; --i) r[i] = 0;
	      r[ds] = c;
	      r.t = this.t+ds+1;
	      r.s = this.s;
	      r.clamp();
	    }
	
	    // (protected) r = this >> n
	    function bnpRShiftTo(n,r) {
	      r.s = this.s;
	      var ds = Math.floor(n/this.DB);
	      if(ds >= this.t) { r.t = 0; return; }
	      var bs = n%this.DB;
	      var cbs = this.DB-bs;
	      var bm = (1<<bs)-1;
	      r[0] = this[ds]>>bs;
	      for(var i = ds+1; i < this.t; ++i) {
	        r[i-ds-1] |= (this[i]&bm)<<cbs;
	        r[i-ds] = this[i]>>bs;
	      }
	      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
	      r.t = this.t-ds;
	      r.clamp();
	    }
	
	    // (protected) r = this - a
	    function bnpSubTo(a,r) {
	      var i = 0, c = 0, m = Math.min(a.t,this.t);
	      while(i < m) {
	        c += this[i]-a[i];
	        r[i++] = c&this.DM;
	        c >>= this.DB;
	      }
	      if(a.t < this.t) {
	        c -= a.s;
	        while(i < this.t) {
	          c += this[i];
	          r[i++] = c&this.DM;
	          c >>= this.DB;
	        }
	        c += this.s;
	      }
	      else {
	        c += this.s;
	        while(i < a.t) {
	          c -= a[i];
	          r[i++] = c&this.DM;
	          c >>= this.DB;
	        }
	        c -= a.s;
	      }
	      r.s = (c<0)?-1:0;
	      if(c < -1) r[i++] = this.DV+c;
	      else if(c > 0) r[i++] = c;
	      r.t = i;
	      r.clamp();
	    }
	
	    // (protected) r = this * a, r != this,a (HAC 14.12)
	    // "this" should be the larger one if appropriate.
	    function bnpMultiplyTo(a,r) {
	      var x = this.abs(), y = a.abs();
	      var i = x.t;
	      r.t = i+y.t;
	      while(--i >= 0) r[i] = 0;
	      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
	      r.s = 0;
	      r.clamp();
	      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
	    }
	
	    // (protected) r = this^2, r != this (HAC 14.16)
	    function bnpSquareTo(r) {
	      var x = this.abs();
	      var i = r.t = 2*x.t;
	      while(--i >= 0) r[i] = 0;
	      for(i = 0; i < x.t-1; ++i) {
	        var c = x.am(i,x[i],r,2*i,0,1);
	        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
	          r[i+x.t] -= x.DV;
	          r[i+x.t+1] = 1;
	        }
	      }
	      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
	      r.s = 0;
	      r.clamp();
	    }
	
	    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
	    // r != q, this != m.  q or r may be null.
	    function bnpDivRemTo(m,q,r) {
	      var pm = m.abs();
	      if(pm.t <= 0) return;
	      var pt = this.abs();
	      if(pt.t < pm.t) {
	        if(q != null) q.fromInt(0);
	        if(r != null) this.copyTo(r);
	        return;
	      }
	      if(r == null) r = nbi();
	      var y = nbi(), ts = this.s, ms = m.s;
	      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
	      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
	      else { pm.copyTo(y); pt.copyTo(r); }
	      var ys = y.t;
	      var y0 = y[ys-1];
	      if(y0 == 0) return;
	      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
	      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
	      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
	      y.dlShiftTo(j,t);
	      if(r.compareTo(t) >= 0) {
	        r[r.t++] = 1;
	        r.subTo(t,r);
	      }
	      BigInteger.ONE.dlShiftTo(ys,t);
	      t.subTo(y,y);  // "negative" y so we can replace sub with am later
	      while(y.t < ys) y[y.t++] = 0;
	      while(--j >= 0) {
	        // Estimate quotient digit
	        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
	        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
	          y.dlShiftTo(j,t);
	          r.subTo(t,r);
	          while(r[i] < --qd) r.subTo(t,r);
	        }
	      }
	      if(q != null) {
	        r.drShiftTo(ys,q);
	        if(ts != ms) BigInteger.ZERO.subTo(q,q);
	      }
	      r.t = ys;
	      r.clamp();
	      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
	      if(ts < 0) BigInteger.ZERO.subTo(r,r);
	    }
	
	    // (public) this mod a
	    function bnMod(a) {
	      var r = nbi();
	      this.abs().divRemTo(a,null,r);
	      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
	      return r;
	    }
	
	    // Modular reduction using "classic" algorithm
	    function Classic(m) { this.m = m; }
	    function cConvert(x) {
	      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
	      else return x;
	    }
	    function cRevert(x) { return x; }
	    function cReduce(x) { x.divRemTo(this.m,null,x); }
	    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
	    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
	
	    Classic.prototype.convert = cConvert;
	    Classic.prototype.revert = cRevert;
	    Classic.prototype.reduce = cReduce;
	    Classic.prototype.mulTo = cMulTo;
	    Classic.prototype.sqrTo = cSqrTo;
	
	    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
	    // justification:
	    //         xy == 1 (mod m)
	    //         xy =  1+km
	    //   xy(2-xy) = (1+km)(1-km)
	    // x[y(2-xy)] = 1-k^2m^2
	    // x[y(2-xy)] == 1 (mod m^2)
	    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
	    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
	    // JS multiply "overflows" differently from C/C++, so care is needed here.
	    function bnpInvDigit() {
	      if(this.t < 1) return 0;
	      var x = this[0];
	      if((x&1) == 0) return 0;
	      var y = x&3;       // y == 1/x mod 2^2
	      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
	      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
	      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
	      // last step - calculate inverse mod DV directly;
	      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
	      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
	      // we really want the negative inverse, and -DV < y < DV
	      return (y>0)?this.DV-y:-y;
	    }
	
	    // Montgomery reduction
	    function Montgomery(m) {
	      this.m = m;
	      this.mp = m.invDigit();
	      this.mpl = this.mp&0x7fff;
	      this.mph = this.mp>>15;
	      this.um = (1<<(m.DB-15))-1;
	      this.mt2 = 2*m.t;
	    }
	
	    // xR mod m
	    function montConvert(x) {
	      var r = nbi();
	      x.abs().dlShiftTo(this.m.t,r);
	      r.divRemTo(this.m,null,r);
	      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
	      return r;
	    }
	
	    // x/R mod m
	    function montRevert(x) {
	      var r = nbi();
	      x.copyTo(r);
	      this.reduce(r);
	      return r;
	    }
	
	    // x = x/R mod m (HAC 14.32)
	    function montReduce(x) {
	      while(x.t <= this.mt2) // pad x so am has enough room later
	        x[x.t++] = 0;
	      for(var i = 0; i < this.m.t; ++i) {
	        // faster way of calculating u0 = x[i]*mp mod DV
	        var j = x[i]&0x7fff;
	        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
	        // use am to combine the multiply-shift-add into one call
	        j = i+this.m.t;
	        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
	        // propagate carry
	        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
	      }
	      x.clamp();
	      x.drShiftTo(this.m.t,x);
	      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
	    }
	
	    // r = "x^2/R mod m"; x != r
	    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
	
	    // r = "xy/R mod m"; x,y != r
	    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
	
	    Montgomery.prototype.convert = montConvert;
	    Montgomery.prototype.revert = montRevert;
	    Montgomery.prototype.reduce = montReduce;
	    Montgomery.prototype.mulTo = montMulTo;
	    Montgomery.prototype.sqrTo = montSqrTo;
	
	    // (protected) true iff this is even
	    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }
	
	    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
	    function bnpExp(e,z) {
	      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
	      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
	      g.copyTo(r);
	      while(--i >= 0) {
	        z.sqrTo(r,r2);
	        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
	        else { var t = r; r = r2; r2 = t; }
	      }
	      return z.revert(r);
	    }
	
	    // (public) this^e % m, 0 <= e < 2^32
	    function bnModPowInt(e,m) {
	      var z;
	      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
	      return this.exp(e,z);
	    }
	
	    // protected
	    BigInteger.prototype.copyTo = bnpCopyTo;
	    BigInteger.prototype.fromInt = bnpFromInt;
	    BigInteger.prototype.fromString = bnpFromString;
	    BigInteger.prototype.clamp = bnpClamp;
	    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	    BigInteger.prototype.lShiftTo = bnpLShiftTo;
	    BigInteger.prototype.rShiftTo = bnpRShiftTo;
	    BigInteger.prototype.subTo = bnpSubTo;
	    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	    BigInteger.prototype.squareTo = bnpSquareTo;
	    BigInteger.prototype.divRemTo = bnpDivRemTo;
	    BigInteger.prototype.invDigit = bnpInvDigit;
	    BigInteger.prototype.isEven = bnpIsEven;
	    BigInteger.prototype.exp = bnpExp;
	
	    // public
	    BigInteger.prototype.toString = bnToString;
	    BigInteger.prototype.negate = bnNegate;
	    BigInteger.prototype.abs = bnAbs;
	    BigInteger.prototype.compareTo = bnCompareTo;
	    BigInteger.prototype.bitLength = bnBitLength;
	    BigInteger.prototype.mod = bnMod;
	    BigInteger.prototype.modPowInt = bnModPowInt;
	
	    // "constants"
	    BigInteger.ZERO = nbv(0);
	    BigInteger.ONE = nbv(1);
	
	    // Copyright (c) 2005-2009  Tom Wu
	    // All Rights Reserved.
	    // See "LICENSE" for details.
	
	    // Extended JavaScript BN functions, required for RSA private ops.
	
	    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
	    // Version 1.2: square() API, isProbablePrime fix
	
	    // (public)
	    function bnClone() { var r = nbi(); this.copyTo(r); return r; }
	
	    // (public) return value as integer
	    function bnIntValue() {
	      if(this.s < 0) {
	        if(this.t == 1) return this[0]-this.DV;
	        else if(this.t == 0) return -1;
	      }
	      else if(this.t == 1) return this[0];
	      else if(this.t == 0) return 0;
	      // assumes 16 < DB < 32
	      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
	    }
	
	    // (public) return value as byte
	    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }
	
	    // (public) return value as short (assumes DB>=16)
	    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }
	
	    // (protected) return x s.t. r^x < DV
	    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }
	
	    // (public) 0 if this == 0, 1 if this > 0
	    function bnSigNum() {
	      if(this.s < 0) return -1;
	      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
	      else return 1;
	    }
	
	    // (protected) convert to radix string
	    function bnpToRadix(b) {
	      if(b == null) b = 10;
	      if(this.signum() == 0 || b < 2 || b > 36) return "0";
	      var cs = this.chunkSize(b);
	      var a = Math.pow(b,cs);
	      var d = nbv(a), y = nbi(), z = nbi(), r = "";
	      this.divRemTo(d,y,z);
	      while(y.signum() > 0) {
	        r = (a+z.intValue()).toString(b).substr(1) + r;
	        y.divRemTo(d,y,z);
	      }
	      return z.intValue().toString(b) + r;
	    }
	
	    // (protected) convert from radix string
	    function bnpFromRadix(s,b) {
	      this.fromInt(0);
	      if(b == null) b = 10;
	      var cs = this.chunkSize(b);
	      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
	      for(var i = 0; i < s.length; ++i) {
	        var x = intAt(s,i);
	        if(x < 0) {
	          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
	          continue;
	        }
	        w = b*w+x;
	        if(++j >= cs) {
	          this.dMultiply(d);
	          this.dAddOffset(w,0);
	          j = 0;
	          w = 0;
	        }
	      }
	      if(j > 0) {
	        this.dMultiply(Math.pow(b,j));
	        this.dAddOffset(w,0);
	      }
	      if(mi) BigInteger.ZERO.subTo(this,this);
	    }
	
	    // (protected) alternate constructor
	    function bnpFromNumber(a,b,c) {
	      if("number" == typeof b) {
	        // new BigInteger(int,int,RNG)
	        if(a < 2) this.fromInt(1);
	        else {
	          this.fromNumber(a,c);
	          if(!this.testBit(a-1))	// force MSB set
	            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
	          if(this.isEven()) this.dAddOffset(1,0); // force odd
	          while(!this.isProbablePrime(b)) {
	            this.dAddOffset(2,0);
	            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
	          }
	        }
	      }
	      else {
	        // new BigInteger(int,RNG)
	        var x = new Array(), t = a&7;
	        x.length = (a>>3)+1;
	        b.nextBytes(x);
	        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
	        this.fromString(x,256);
	      }
	    }
	
	    // (public) convert to bigendian byte array
	    function bnToByteArray() {
	      var i = this.t, r = new Array();
	      r[0] = this.s;
	      var p = this.DB-(i*this.DB)%8, d, k = 0;
	      if(i-- > 0) {
	        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
	          r[k++] = d|(this.s<<(this.DB-p));
	        while(i >= 0) {
	          if(p < 8) {
	            d = (this[i]&((1<<p)-1))<<(8-p);
	            d |= this[--i]>>(p+=this.DB-8);
	          }
	          else {
	            d = (this[i]>>(p-=8))&0xff;
	            if(p <= 0) { p += this.DB; --i; }
	          }
	          if((d&0x80) != 0) d |= -256;
	          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
	          if(k > 0 || d != this.s) r[k++] = d;
	        }
	      }
	      return r;
	    }
	
	    function bnEquals(a) { return(this.compareTo(a)==0); }
	    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
	    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }
	
	    // (protected) r = this op a (bitwise)
	    function bnpBitwiseTo(a,op,r) {
	      var i, f, m = Math.min(a.t,this.t);
	      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
	      if(a.t < this.t) {
	        f = a.s&this.DM;
	        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
	        r.t = this.t;
	      }
	      else {
	        f = this.s&this.DM;
	        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
	        r.t = a.t;
	      }
	      r.s = op(this.s,a.s);
	      r.clamp();
	    }
	
	    // (public) this & a
	    function op_and(x,y) { return x&y; }
	    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }
	
	    // (public) this | a
	    function op_or(x,y) { return x|y; }
	    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }
	
	    // (public) this ^ a
	    function op_xor(x,y) { return x^y; }
	    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }
	
	    // (public) this & ~a
	    function op_andnot(x,y) { return x&~y; }
	    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }
	
	    // (public) ~this
	    function bnNot() {
	      var r = nbi();
	      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
	      r.t = this.t;
	      r.s = ~this.s;
	      return r;
	    }
	
	    // (public) this << n
	    function bnShiftLeft(n) {
	      var r = nbi();
	      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
	      return r;
	    }
	
	    // (public) this >> n
	    function bnShiftRight(n) {
	      var r = nbi();
	      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
	      return r;
	    }
	
	    // return index of lowest 1-bit in x, x < 2^31
	    function lbit(x) {
	      if(x == 0) return -1;
	      var r = 0;
	      if((x&0xffff) == 0) { x >>= 16; r += 16; }
	      if((x&0xff) == 0) { x >>= 8; r += 8; }
	      if((x&0xf) == 0) { x >>= 4; r += 4; }
	      if((x&3) == 0) { x >>= 2; r += 2; }
	      if((x&1) == 0) ++r;
	      return r;
	    }
	
	    // (public) returns index of lowest 1-bit (or -1 if none)
	    function bnGetLowestSetBit() {
	      for(var i = 0; i < this.t; ++i)
	        if(this[i] != 0) return i*this.DB+lbit(this[i]);
	      if(this.s < 0) return this.t*this.DB;
	      return -1;
	    }
	
	    // return number of 1 bits in x
	    function cbit(x) {
	      var r = 0;
	      while(x != 0) { x &= x-1; ++r; }
	      return r;
	    }
	
	    // (public) return number of set bits
	    function bnBitCount() {
	      var r = 0, x = this.s&this.DM;
	      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
	      return r;
	    }
	
	    // (public) true iff nth bit is set
	    function bnTestBit(n) {
	      var j = Math.floor(n/this.DB);
	      if(j >= this.t) return(this.s!=0);
	      return((this[j]&(1<<(n%this.DB)))!=0);
	    }
	
	    // (protected) this op (1<<n)
	    function bnpChangeBit(n,op) {
	      var r = BigInteger.ONE.shiftLeft(n);
	      this.bitwiseTo(r,op,r);
	      return r;
	    }
	
	    // (public) this | (1<<n)
	    function bnSetBit(n) { return this.changeBit(n,op_or); }
	
	    // (public) this & ~(1<<n)
	    function bnClearBit(n) { return this.changeBit(n,op_andnot); }
	
	    // (public) this ^ (1<<n)
	    function bnFlipBit(n) { return this.changeBit(n,op_xor); }
	
	    // (protected) r = this + a
	    function bnpAddTo(a,r) {
	      var i = 0, c = 0, m = Math.min(a.t,this.t);
	      while(i < m) {
	        c += this[i]+a[i];
	        r[i++] = c&this.DM;
	        c >>= this.DB;
	      }
	      if(a.t < this.t) {
	        c += a.s;
	        while(i < this.t) {
	          c += this[i];
	          r[i++] = c&this.DM;
	          c >>= this.DB;
	        }
	        c += this.s;
	      }
	      else {
	        c += this.s;
	        while(i < a.t) {
	          c += a[i];
	          r[i++] = c&this.DM;
	          c >>= this.DB;
	        }
	        c += a.s;
	      }
	      r.s = (c<0)?-1:0;
	      if(c > 0) r[i++] = c;
	      else if(c < -1) r[i++] = this.DV+c;
	      r.t = i;
	      r.clamp();
	    }
	
	    // (public) this + a
	    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }
	
	    // (public) this - a
	    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }
	
	    // (public) this * a
	    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }
	
	    // (public) this^2
	    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }
	
	    // (public) this / a
	    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }
	
	    // (public) this % a
	    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }
	
	    // (public) [this/a,this%a]
	    function bnDivideAndRemainder(a) {
	      var q = nbi(), r = nbi();
	      this.divRemTo(a,q,r);
	      return new Array(q,r);
	    }
	
	    // (protected) this *= n, this >= 0, 1 < n < DV
	    function bnpDMultiply(n) {
	      this[this.t] = this.am(0,n-1,this,0,0,this.t);
	      ++this.t;
	      this.clamp();
	    }
	
	    // (protected) this += n << w words, this >= 0
	    function bnpDAddOffset(n,w) {
	      if(n == 0) return;
	      while(this.t <= w) this[this.t++] = 0;
	      this[w] += n;
	      while(this[w] >= this.DV) {
	        this[w] -= this.DV;
	        if(++w >= this.t) this[this.t++] = 0;
	        ++this[w];
	      }
	    }
	
	    // A "null" reducer
	    function NullExp() {}
	    function nNop(x) { return x; }
	    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
	    function nSqrTo(x,r) { x.squareTo(r); }
	
	    NullExp.prototype.convert = nNop;
	    NullExp.prototype.revert = nNop;
	    NullExp.prototype.mulTo = nMulTo;
	    NullExp.prototype.sqrTo = nSqrTo;
	
	    // (public) this^e
	    function bnPow(e) { return this.exp(e,new NullExp()); }
	
	    // (protected) r = lower n words of "this * a", a.t <= n
	    // "this" should be the larger one if appropriate.
	    function bnpMultiplyLowerTo(a,n,r) {
	      var i = Math.min(this.t+a.t,n);
	      r.s = 0; // assumes a,this >= 0
	      r.t = i;
	      while(i > 0) r[--i] = 0;
	      var j;
	      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
	      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
	      r.clamp();
	    }
	
	    // (protected) r = "this * a" without lower n words, n > 0
	    // "this" should be the larger one if appropriate.
	    function bnpMultiplyUpperTo(a,n,r) {
	      --n;
	      var i = r.t = this.t+a.t-n;
	      r.s = 0; // assumes a,this >= 0
	      while(--i >= 0) r[i] = 0;
	      for(i = Math.max(n-this.t,0); i < a.t; ++i)
	        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
	      r.clamp();
	      r.drShiftTo(1,r);
	    }
	
	    // Barrett modular reduction
	    function Barrett(m) {
	      // setup Barrett
	      this.r2 = nbi();
	      this.q3 = nbi();
	      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
	      this.mu = this.r2.divide(m);
	      this.m = m;
	    }
	
	    function barrettConvert(x) {
	      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
	      else if(x.compareTo(this.m) < 0) return x;
	      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
	    }
	
	    function barrettRevert(x) { return x; }
	
	    // x = x mod m (HAC 14.42)
	    function barrettReduce(x) {
	      x.drShiftTo(this.m.t-1,this.r2);
	      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
	      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
	      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
	      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
	      x.subTo(this.r2,x);
	      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
	    }
	
	    // r = x^2 mod m; x != r
	    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
	
	    // r = x*y mod m; x,y != r
	    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
	
	    Barrett.prototype.convert = barrettConvert;
	    Barrett.prototype.revert = barrettRevert;
	    Barrett.prototype.reduce = barrettReduce;
	    Barrett.prototype.mulTo = barrettMulTo;
	    Barrett.prototype.sqrTo = barrettSqrTo;
	
	    // (public) this^e % m (HAC 14.85)
	    function bnModPow(e,m) {
	      var i = e.bitLength(), k, r = nbv(1), z;
	      if(i <= 0) return r;
	      else if(i < 18) k = 1;
	      else if(i < 48) k = 3;
	      else if(i < 144) k = 4;
	      else if(i < 768) k = 5;
	      else k = 6;
	      if(i < 8)
	        z = new Classic(m);
	      else if(m.isEven())
	        z = new Barrett(m);
	      else
	        z = new Montgomery(m);
	
	      // precomputation
	      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
	      g[1] = z.convert(this);
	      if(k > 1) {
	        var g2 = nbi();
	        z.sqrTo(g[1],g2);
	        while(n <= km) {
	          g[n] = nbi();
	          z.mulTo(g2,g[n-2],g[n]);
	          n += 2;
	        }
	      }
	
	      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
	      i = nbits(e[j])-1;
	      while(j >= 0) {
	        if(i >= k1) w = (e[j]>>(i-k1))&km;
	        else {
	          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
	          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
	        }
	
	        n = k;
	        while((w&1) == 0) { w >>= 1; --n; }
	        if((i -= n) < 0) { i += this.DB; --j; }
	        if(is1) {	// ret == 1, don't bother squaring or multiplying it
	          g[w].copyTo(r);
	          is1 = false;
	        }
	        else {
	          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
	          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
	          z.mulTo(r2,g[w],r);
	        }
	
	        while(j >= 0 && (e[j]&(1<<i)) == 0) {
	          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
	          if(--i < 0) { i = this.DB-1; --j; }
	        }
	      }
	      return z.revert(r);
	    }
	
	    // (public) gcd(this,a) (HAC 14.54)
	    function bnGCD(a) {
	      var x = (this.s<0)?this.negate():this.clone();
	      var y = (a.s<0)?a.negate():a.clone();
	      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
	      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
	      if(g < 0) return x;
	      if(i < g) g = i;
	      if(g > 0) {
	        x.rShiftTo(g,x);
	        y.rShiftTo(g,y);
	      }
	      while(x.signum() > 0) {
	        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
	        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
	        if(x.compareTo(y) >= 0) {
	          x.subTo(y,x);
	          x.rShiftTo(1,x);
	        }
	        else {
	          y.subTo(x,y);
	          y.rShiftTo(1,y);
	        }
	      }
	      if(g > 0) y.lShiftTo(g,y);
	      return y;
	    }
	
	    // (protected) this % n, n < 2^26
	    function bnpModInt(n) {
	      if(n <= 0) return 0;
	      var d = this.DV%n, r = (this.s<0)?n-1:0;
	      if(this.t > 0)
	        if(d == 0) r = this[0]%n;
	        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
	      return r;
	    }
	
	    // (public) 1/this % m (HAC 14.61)
	    function bnModInverse(m) {
	      var ac = m.isEven();
	      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
	      var u = m.clone(), v = this.clone();
	      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
	      while(u.signum() != 0) {
	        while(u.isEven()) {
	          u.rShiftTo(1,u);
	          if(ac) {
	            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
	            a.rShiftTo(1,a);
	          }
	          else if(!b.isEven()) b.subTo(m,b);
	          b.rShiftTo(1,b);
	        }
	        while(v.isEven()) {
	          v.rShiftTo(1,v);
	          if(ac) {
	            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
	            c.rShiftTo(1,c);
	          }
	          else if(!d.isEven()) d.subTo(m,d);
	          d.rShiftTo(1,d);
	        }
	        if(u.compareTo(v) >= 0) {
	          u.subTo(v,u);
	          if(ac) a.subTo(c,a);
	          b.subTo(d,b);
	        }
	        else {
	          v.subTo(u,v);
	          if(ac) c.subTo(a,c);
	          d.subTo(b,d);
	        }
	      }
	      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
	      if(d.compareTo(m) >= 0) return d.subtract(m);
	      if(d.signum() < 0) d.addTo(m,d); else return d;
	      if(d.signum() < 0) return d.add(m); else return d;
	    }
	
	    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
	    var lplim = (1<<26)/lowprimes[lowprimes.length-1];
	
	    // (public) test primality with certainty >= 1-.5^t
	    function bnIsProbablePrime(t) {
	      var i, x = this.abs();
	      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
	        for(i = 0; i < lowprimes.length; ++i)
	          if(x[0] == lowprimes[i]) return true;
	        return false;
	      }
	      if(x.isEven()) return false;
	      i = 1;
	      while(i < lowprimes.length) {
	        var m = lowprimes[i], j = i+1;
	        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
	        m = x.modInt(m);
	        while(i < j) if(m%lowprimes[i++] == 0) return false;
	      }
	      return x.millerRabin(t);
	    }
	
	    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
	    function bnpMillerRabin(t) {
	      var n1 = this.subtract(BigInteger.ONE);
	      var k = n1.getLowestSetBit();
	      if(k <= 0) return false;
	      var r = n1.shiftRight(k);
	      t = (t+1)>>1;
	      if(t > lowprimes.length) t = lowprimes.length;
	      var a = nbi();
	      for(var i = 0; i < t; ++i) {
	        //Pick bases at random, instead of starting at 2
	        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
	        var y = a.modPow(r,this);
	        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
	          var j = 1;
	          while(j++ < k && y.compareTo(n1) != 0) {
	            y = y.modPowInt(2,this);
	            if(y.compareTo(BigInteger.ONE) == 0) return false;
	          }
	          if(y.compareTo(n1) != 0) return false;
	        }
	      }
	      return true;
	    }
	
	    // protected
	    BigInteger.prototype.chunkSize = bnpChunkSize;
	    BigInteger.prototype.toRadix = bnpToRadix;
	    BigInteger.prototype.fromRadix = bnpFromRadix;
	    BigInteger.prototype.fromNumber = bnpFromNumber;
	    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	    BigInteger.prototype.changeBit = bnpChangeBit;
	    BigInteger.prototype.addTo = bnpAddTo;
	    BigInteger.prototype.dMultiply = bnpDMultiply;
	    BigInteger.prototype.dAddOffset = bnpDAddOffset;
	    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	    BigInteger.prototype.modInt = bnpModInt;
	    BigInteger.prototype.millerRabin = bnpMillerRabin;
	
	    // public
	    BigInteger.prototype.clone = bnClone;
	    BigInteger.prototype.intValue = bnIntValue;
	    BigInteger.prototype.byteValue = bnByteValue;
	    BigInteger.prototype.shortValue = bnShortValue;
	    BigInteger.prototype.signum = bnSigNum;
	    BigInteger.prototype.toByteArray = bnToByteArray;
	    BigInteger.prototype.equals = bnEquals;
	    BigInteger.prototype.min = bnMin;
	    BigInteger.prototype.max = bnMax;
	    BigInteger.prototype.and = bnAnd;
	    BigInteger.prototype.or = bnOr;
	    BigInteger.prototype.xor = bnXor;
	    BigInteger.prototype.andNot = bnAndNot;
	    BigInteger.prototype.not = bnNot;
	    BigInteger.prototype.shiftLeft = bnShiftLeft;
	    BigInteger.prototype.shiftRight = bnShiftRight;
	    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	    BigInteger.prototype.bitCount = bnBitCount;
	    BigInteger.prototype.testBit = bnTestBit;
	    BigInteger.prototype.setBit = bnSetBit;
	    BigInteger.prototype.clearBit = bnClearBit;
	    BigInteger.prototype.flipBit = bnFlipBit;
	    BigInteger.prototype.add = bnAdd;
	    BigInteger.prototype.subtract = bnSubtract;
	    BigInteger.prototype.multiply = bnMultiply;
	    BigInteger.prototype.divide = bnDivide;
	    BigInteger.prototype.remainder = bnRemainder;
	    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	    BigInteger.prototype.modPow = bnModPow;
	    BigInteger.prototype.modInverse = bnModInverse;
	    BigInteger.prototype.pow = bnPow;
	    BigInteger.prototype.gcd = bnGCD;
	    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
	
	    // JSBN-specific extension
	    BigInteger.prototype.square = bnSquare;
	
	    // Expose the Barrett function
	    BigInteger.prototype.Barrett = Barrett
	
	    // BigInteger interfaces not implemented in jsbn:
	
	    // BigInteger(int signum, byte[] magnitude)
	    // double doubleValue()
	    // float floatValue()
	    // int hashCode()
	    // long longValue()
	    // static BigInteger valueOf(long val)
	
		// Random number generator - requires a PRNG backend, e.g. prng4.js
	
		// For best results, put code like
		// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
		// in your main HTML document.
	
		var rng_state;
		var rng_pool;
		var rng_pptr;
	
		// Mix in a 32-bit integer into the pool
		function rng_seed_int(x) {
		  rng_pool[rng_pptr++] ^= x & 255;
		  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
		  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
		  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
		  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
		}
	
		// Mix in the current time (w/milliseconds) into the pool
		function rng_seed_time() {
		  rng_seed_int(new Date().getTime());
		}
	
		// Initialize the pool with junk if needed.
		if(rng_pool == null) {
		  rng_pool = new Array();
		  rng_pptr = 0;
		  var t;
		  if(typeof window !== "undefined" && window.crypto) {
			if (window.crypto.getRandomValues) {
			  // Use webcrypto if available
			  var ua = new Uint8Array(32);
			  window.crypto.getRandomValues(ua);
			  for(t = 0; t < 32; ++t)
				rng_pool[rng_pptr++] = ua[t];
			}
			else if(navigator.appName == "Netscape" && navigator.appVersion < "5") {
			  // Extract entropy (256 bits) from NS4 RNG if available
			  var z = window.crypto.random(32);
			  for(t = 0; t < z.length; ++t)
				rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
			}
		  }
		  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
			t = Math.floor(65536 * Math.random());
			rng_pool[rng_pptr++] = t >>> 8;
			rng_pool[rng_pptr++] = t & 255;
		  }
		  rng_pptr = 0;
		  rng_seed_time();
		  //rng_seed_int(window.screenX);
		  //rng_seed_int(window.screenY);
		}
	
		function rng_get_byte() {
		  if(rng_state == null) {
			rng_seed_time();
			rng_state = prng_newstate();
			rng_state.init(rng_pool);
			for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
			  rng_pool[rng_pptr] = 0;
			rng_pptr = 0;
			//rng_pool = null;
		  }
		  // TODO: allow reseeding after first request
		  return rng_state.next();
		}
	
		function rng_get_bytes(ba) {
		  var i;
		  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
		}
	
		function SecureRandom() {}
	
		SecureRandom.prototype.nextBytes = rng_get_bytes;
	
		// prng4.js - uses Arcfour as a PRNG
	
		function Arcfour() {
		  this.i = 0;
		  this.j = 0;
		  this.S = new Array();
		}
	
		// Initialize arcfour context from key, an array of ints, each from [0..255]
		function ARC4init(key) {
		  var i, j, t;
		  for(i = 0; i < 256; ++i)
			this.S[i] = i;
		  j = 0;
		  for(i = 0; i < 256; ++i) {
			j = (j + this.S[i] + key[i % key.length]) & 255;
			t = this.S[i];
			this.S[i] = this.S[j];
			this.S[j] = t;
		  }
		  this.i = 0;
		  this.j = 0;
		}
	
		function ARC4next() {
		  var t;
		  this.i = (this.i + 1) & 255;
		  this.j = (this.j + this.S[this.i]) & 255;
		  t = this.S[this.i];
		  this.S[this.i] = this.S[this.j];
		  this.S[this.j] = t;
		  return this.S[(t + this.S[this.i]) & 255];
		}
	
		Arcfour.prototype.init = ARC4init;
		Arcfour.prototype.next = ARC4next;
	
		// Plug in your RNG constructor here
		function prng_newstate() {
		  return new Arcfour();
		}
	
		// Pool size must be a multiple of 4 and greater than 32.
		// An array of bytes the size of the pool will be passed to init()
		var rng_psize = 256;
	
	    if (true) {
	        exports = module.exports = {
				BigInteger: BigInteger,
				SecureRandom: SecureRandom,
			};
	    } else {
	        this.BigInteger = BigInteger;
	        this.SecureRandom = SecureRandom;
	    }
	
	}).call(this);


/***/ },
/* 668 */
/*!****************************!*\
  !*** ./~/sshpk/lib/dhe.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	module.exports = DiffieHellman;
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var algs = __webpack_require__(/*! ./algs */ 639);
	var utils = __webpack_require__(/*! ./utils */ 642);
	var ed;
	
	var Key = __webpack_require__(/*! ./key */ 638);
	var PrivateKey = __webpack_require__(/*! ./private-key */ 643);
	
	var CRYPTO_HAVE_ECDH = (crypto.createECDH !== undefined);
	
	var ecdh, ec, jsbn;
	
	function DiffieHellman(key) {
		utils.assertCompatible(key, Key, [1, 4], 'key');
		this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
		this._algo = key.type;
		this._curve = key.curve;
		this._key = key;
		if (key.type === 'dsa') {
			if (!CRYPTO_HAVE_ECDH) {
				throw (new Error('Due to bugs in the node 0.10 ' +
				    'crypto API, node 0.12.x or later is required ' +
				    'to use DH'));
			}
			this._dh = crypto.createDiffieHellman(
			    key.part.p.data, undefined,
			    key.part.g.data, undefined);
			this._p = key.part.p;
			this._g = key.part.g;
			if (this._isPriv)
				this._dh.setPrivateKey(key.part.x.data);
			this._dh.setPublicKey(key.part.y.data);
	
		} else if (key.type === 'ecdsa') {
			if (!CRYPTO_HAVE_ECDH) {
				if (ecdh === undefined)
					ecdh = __webpack_require__(/*! ecc-jsbn */ 669);
				if (ec === undefined)
					ec = __webpack_require__(/*! ecc-jsbn/lib/ec */ 670);
				if (jsbn === undefined)
					jsbn = __webpack_require__(/*! jsbn */ 667).BigInteger;
	
				this._ecParams = new X9ECParameters(this._curve);
	
				if (this._isPriv) {
					this._priv = new ECPrivate(
					    this._ecParams, key.part.d.data);
				}
				return;
			}
	
			var curve = {
				'nistp256': 'prime256v1',
				'nistp384': 'secp384r1',
				'nistp521': 'secp521r1'
			}[key.curve];
			this._dh = crypto.createECDH(curve);
			if (typeof (this._dh) !== 'object' ||
			    typeof (this._dh.setPrivateKey) !== 'function') {
				CRYPTO_HAVE_ECDH = false;
				DiffieHellman.call(this, key);
				return;
			}
			if (this._isPriv)
				this._dh.setPrivateKey(key.part.d.data);
			this._dh.setPublicKey(key.part.Q.data);
	
		} else if (key.type === 'curve25519') {
			if (ed === undefined)
				ed = __webpack_require__(/*! jodid25519 */ 661);
	
			if (this._isPriv) {
				this._priv = key.part.r.data;
				if (this._priv[0] === 0x00)
					this._priv = this._priv.slice(1);
				this._priv = this._priv.slice(0, 32);
			}
	
		} else {
			throw (new Error('DH not supported for ' + key.type + ' keys'));
		}
	}
	
	DiffieHellman.prototype.getPublicKey = function () {
		if (this._isPriv)
			return (this._key.toPublic());
		return (this._key);
	};
	
	DiffieHellman.prototype.getPrivateKey = function () {
		if (this._isPriv)
			return (this._key);
		else
			return (undefined);
	};
	DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
	
	DiffieHellman.prototype._keyCheck = function (pk, isPub) {
		assert.object(pk, 'key');
		if (!isPub)
			utils.assertCompatible(pk, PrivateKey, [1, 3], 'key');
		utils.assertCompatible(pk, Key, [1, 4], 'key');
	
		if (pk.type !== this._algo) {
			throw (new Error('A ' + pk.type + ' key cannot be used in ' +
			    this._algo + ' Diffie-Hellman'));
		}
	
		if (pk.curve !== this._curve) {
			throw (new Error('A key from the ' + pk.curve + ' curve ' +
			    'cannot be used with a ' + this._curve +
			    ' Diffie-Hellman'));
		}
	
		if (pk.type === 'dsa') {
			assert.deepEqual(pk.part.p, this._p,
			    'DSA key prime does not match');
			assert.deepEqual(pk.part.g, this._g,
			    'DSA key generator does not match');
		}
	};
	
	DiffieHellman.prototype.setKey = function (pk) {
		this._keyCheck(pk);
	
		if (pk.type === 'dsa') {
			this._dh.setPrivateKey(pk.part.x.data);
			this._dh.setPublicKey(pk.part.y.data);
	
		} else if (pk.type === 'ecdsa') {
			if (CRYPTO_HAVE_ECDH) {
				this._dh.setPrivateKey(pk.part.d.data);
				this._dh.setPublicKey(pk.part.Q.data);
			} else {
				this._priv = new ECPrivate(
				    this._ecParams, pk.part.d.data);
			}
	
		} else if (pk.type === 'curve25519') {
			this._priv = pk.part.r.data;
			if (this._priv[0] === 0x00)
				this._priv = this._priv.slice(1);
			this._priv = this._priv.slice(0, 32);
		}
		this._key = pk;
		this._isPriv = true;
	};
	DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
	
	DiffieHellman.prototype.computeSecret = function (otherpk) {
		this._keyCheck(otherpk, true);
		if (!this._isPriv)
			throw (new Error('DH exchange has not been initialized with ' +
			    'a private key yet'));
	
		var pub;
		if (this._algo === 'dsa') {
			return (this._dh.computeSecret(
			    otherpk.part.y.data));
	
		} else if (this._algo === 'ecdsa') {
			if (CRYPTO_HAVE_ECDH) {
				return (this._dh.computeSecret(
				    otherpk.part.Q.data));
			} else {
				pub = new ECPublic(
				    this._ecParams, otherpk.part.Q.data);
				return (this._priv.deriveSharedSecret(pub));
			}
	
		} else if (this._algo === 'curve25519') {
			pub = otherpk.part.R.data;
			if (pub[0] === 0x00)
				pub = pub.slice(1);
	
			var secret = ed.dh.computeKey(
			    this._priv.toString('binary'),
			    pub.toString('binary'));
	
			return (new Buffer(secret, 'binary'));
		}
	
		throw (new Error('Invalid algorithm: ' + this._algo));
	};
	
	DiffieHellman.prototype.generateKey = function () {
		var parts = [];
		var priv, pub;
		if (this._algo === 'dsa') {
			this._dh.generateKeys();
	
			parts.push({name: 'p', data: this._p.data});
			parts.push({name: 'q', data: this._key.part.q.data});
			parts.push({name: 'g', data: this._g.data});
			parts.push({name: 'y', data: this._dh.getPublicKey()});
			parts.push({name: 'x', data: this._dh.getPrivateKey()});
			this._key = new PrivateKey({
				type: 'dsa',
				parts: parts
			});
			this._isPriv = true;
			return (this._key);
	
		} else if (this._algo === 'ecdsa') {
			if (CRYPTO_HAVE_ECDH) {
				this._dh.generateKeys();
	
				parts.push({name: 'curve',
				    data: new Buffer(this._curve)});
				parts.push({name: 'Q', data: this._dh.getPublicKey()});
				parts.push({name: 'd', data: this._dh.getPrivateKey()});
				this._key = new PrivateKey({
					type: 'ecdsa',
					curve: this._curve,
					parts: parts
				});
				this._isPriv = true;
				return (this._key);
	
			} else {
				var n = this._ecParams.getN();
				var r = new jsbn(crypto.randomBytes(n.bitLength()));
				var n1 = n.subtract(jsbn.ONE);
				priv = r.mod(n1).add(jsbn.ONE);
				pub = this._ecParams.getG().multiply(priv);
	
				priv = new Buffer(priv.toByteArray());
				pub = new Buffer(this._ecParams.getCurve().
				    encodePointHex(pub), 'hex');
	
				this._priv = new ECPrivate(this._ecParams, priv);
	
				parts.push({name: 'curve',
				    data: new Buffer(this._curve)});
				parts.push({name: 'Q', data: pub});
				parts.push({name: 'd', data: priv});
	
				this._key = new PrivateKey({
					type: 'ecdsa',
					curve: this._curve,
					parts: parts
				});
				this._isPriv = true;
				return (this._key);
			}
	
		} else if (this._algo === 'curve25519') {
			priv = ed.dh.generateKey();
			pub = ed.dh.publicKey(priv);
			this._priv = priv = new Buffer(priv, 'binary');
			pub = new Buffer(pub, 'binary');
	
			parts.push({name: 'R', data: pub});
			parts.push({name: 'r', data: Buffer.concat([priv, pub])});
			this._key = new PrivateKey({
				type: 'curve25519',
				parts: parts
			});
			this._isPriv = true;
			return (this._key);
		}
	
		throw (new Error('Invalid algorithm: ' + this._algo));
	};
	DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
	
	/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */
	
	function X9ECParameters(name) {
		var params = algs.curves[name];
		assert.object(params);
	
		var p = new jsbn(params.p);
		var a = new jsbn(params.a);
		var b = new jsbn(params.b);
		var n = new jsbn(params.n);
		var h = jsbn.ONE;
		var curve = new ec.ECCurveFp(p, a, b);
		var G = curve.decodePointHex(params.G.toString('hex'));
	
		this.curve = curve;
		this.g = G;
		this.n = n;
		this.h = h;
	}
	X9ECParameters.prototype.getCurve = function () { return (this.curve); };
	X9ECParameters.prototype.getG = function () { return (this.g); };
	X9ECParameters.prototype.getN = function () { return (this.n); };
	X9ECParameters.prototype.getH = function () { return (this.h); };
	
	function ECPublic(params, buffer) {
		this._params = params;
		if (buffer[0] === 0x00)
			buffer = buffer.slice(1);
		this._pub = params.getCurve().decodePointHex(buffer.toString('hex'));
	}
	
	function ECPrivate(params, buffer) {
		this._params = params;
		this._priv = new jsbn(utils.mpNormalize(buffer));
	}
	ECPrivate.prototype.deriveSharedSecret = function (pubKey) {
		assert.ok(pubKey instanceof ECPublic);
		var S = pubKey._pub.multiply(this._priv);
		return (new Buffer(S.getX().toBigInteger().toByteArray()));
	};


/***/ },
/* 669 */
/*!*****************************!*\
  !*** ./~/ecc-jsbn/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(/*! crypto */ 601);
	var BigInteger = __webpack_require__(/*! jsbn */ 667).BigInteger;
	var ECPointFp = __webpack_require__(/*! ./lib/ec.js */ 670).ECPointFp;
	exports.ECCurves = __webpack_require__(/*! ./lib/sec.js */ 671);
	
	// zero prepad
	function unstupid(hex,len)
	{
		return (hex.length >= len) ? hex : unstupid("0"+hex,len);
	}
	
	exports.ECKey = function(curve, key, isPublic)
	{
	  var priv;
		var c = curve();
		var n = c.getN();
	  var bytes = Math.floor(n.bitLength()/8);
	
	  if(key)
	  {
	    if(isPublic)
	    {
	      var curve = c.getCurve();
	//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format
	//      var y = key.slice(bytes+1);
	//      this.P = new ECPointFp(curve,
	//        curve.fromBigInteger(new BigInteger(x.toString("hex"), 16)),
	//        curve.fromBigInteger(new BigInteger(y.toString("hex"), 16)));      
	      this.P = curve.decodePointHex(key.toString("hex"));
	    }else{
	      if(key.length != bytes) return false;
	      priv = new BigInteger(key.toString("hex"), 16);      
	    }
	  }else{
	    var n1 = n.subtract(BigInteger.ONE);
	    var r = new BigInteger(crypto.randomBytes(n.bitLength()));
	    priv = r.mod(n1).add(BigInteger.ONE);
	    this.P = c.getG().multiply(priv);
	  }
	  if(this.P)
	  {
	//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);
	//  this.PublicKey = new Buffer("04"+pubhex,"hex");
	    this.PublicKey = new Buffer(c.getCurve().encodeCompressedPointHex(this.P),"hex");
	  }
	  if(priv)
	  {
	    this.PrivateKey = new Buffer(unstupid(priv.toString(16),bytes*2),"hex");
	    this.deriveSharedSecret = function(key)
	    {
	      if(!key || !key.P) return false;
	      var S = key.P.multiply(priv);
	      return new Buffer(unstupid(S.getX().toBigInteger().toString(16),bytes*2),"hex");
	   }     
	  }
	}
	


/***/ },
/* 670 */
/*!******************************!*\
  !*** ./~/ecc-jsbn/lib/ec.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// Basic Javascript Elliptic Curve implementation
	// Ported loosely from BouncyCastle's Java EC code
	// Only Fp curves implemented for now
	
	// Requires jsbn.js and jsbn2.js
	var BigInteger = __webpack_require__(/*! jsbn */ 667).BigInteger
	var Barrett = BigInteger.prototype.Barrett
	
	// ----------------
	// ECFieldElementFp
	
	// constructor
	function ECFieldElementFp(q,x) {
	    this.x = x;
	    // TODO if(x.compareTo(q) >= 0) error
	    this.q = q;
	}
	
	function feFpEquals(other) {
	    if(other == this) return true;
	    return (this.q.equals(other.q) && this.x.equals(other.x));
	}
	
	function feFpToBigInteger() {
	    return this.x;
	}
	
	function feFpNegate() {
	    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
	}
	
	function feFpAdd(b) {
	    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
	}
	
	function feFpSubtract(b) {
	    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
	}
	
	function feFpMultiply(b) {
	    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
	}
	
	function feFpSquare() {
	    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
	}
	
	function feFpDivide(b) {
	    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
	}
	
	ECFieldElementFp.prototype.equals = feFpEquals;
	ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
	ECFieldElementFp.prototype.negate = feFpNegate;
	ECFieldElementFp.prototype.add = feFpAdd;
	ECFieldElementFp.prototype.subtract = feFpSubtract;
	ECFieldElementFp.prototype.multiply = feFpMultiply;
	ECFieldElementFp.prototype.square = feFpSquare;
	ECFieldElementFp.prototype.divide = feFpDivide;
	
	// ----------------
	// ECPointFp
	
	// constructor
	function ECPointFp(curve,x,y,z) {
	    this.curve = curve;
	    this.x = x;
	    this.y = y;
	    // Projective coordinates: either zinv == null or z * zinv == 1
	    // z and zinv are just BigIntegers, not fieldElements
	    if(z == null) {
	      this.z = BigInteger.ONE;
	    }
	    else {
	      this.z = z;
	    }
	    this.zinv = null;
	    //TODO: compression flag
	}
	
	function pointFpGetX() {
	    if(this.zinv == null) {
	      this.zinv = this.z.modInverse(this.curve.q);
	    }
	    var r = this.x.toBigInteger().multiply(this.zinv);
	    this.curve.reduce(r);
	    return this.curve.fromBigInteger(r);
	}
	
	function pointFpGetY() {
	    if(this.zinv == null) {
	      this.zinv = this.z.modInverse(this.curve.q);
	    }
	    var r = this.y.toBigInteger().multiply(this.zinv);
	    this.curve.reduce(r);
	    return this.curve.fromBigInteger(r);
	}
	
	function pointFpEquals(other) {
	    if(other == this) return true;
	    if(this.isInfinity()) return other.isInfinity();
	    if(other.isInfinity()) return this.isInfinity();
	    var u, v;
	    // u = Y2 * Z1 - Y1 * Z2
	    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
	    if(!u.equals(BigInteger.ZERO)) return false;
	    // v = X2 * Z1 - X1 * Z2
	    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
	    return v.equals(BigInteger.ZERO);
	}
	
	function pointFpIsInfinity() {
	    if((this.x == null) && (this.y == null)) return true;
	    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
	}
	
	function pointFpNegate() {
	    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
	}
	
	function pointFpAdd(b) {
	    if(this.isInfinity()) return b;
	    if(b.isInfinity()) return this;
	
	    // u = Y2 * Z1 - Y1 * Z2
	    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
	    // v = X2 * Z1 - X1 * Z2
	    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
	
	    if(BigInteger.ZERO.equals(v)) {
	        if(BigInteger.ZERO.equals(u)) {
	            return this.twice(); // this == b, so double
	        }
		return this.curve.getInfinity(); // this = -b, so infinity
	    }
	
	    var THREE = new BigInteger("3");
	    var x1 = this.x.toBigInteger();
	    var y1 = this.y.toBigInteger();
	    var x2 = b.x.toBigInteger();
	    var y2 = b.y.toBigInteger();
	
	    var v2 = v.square();
	    var v3 = v2.multiply(v);
	    var x1v2 = x1.multiply(v2);
	    var zu2 = u.square().multiply(this.z);
	
	    // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
	    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
	    // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
	    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
	    // z3 = v^3 * z1 * z2
	    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
	
	    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
	}
	
	function pointFpTwice() {
	    if(this.isInfinity()) return this;
	    if(this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();
	
	    // TODO: optimized handling of constants
	    var THREE = new BigInteger("3");
	    var x1 = this.x.toBigInteger();
	    var y1 = this.y.toBigInteger();
	
	    var y1z1 = y1.multiply(this.z);
	    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
	    var a = this.curve.a.toBigInteger();
	
	    // w = 3 * x1^2 + a * z1^2
	    var w = x1.square().multiply(THREE);
	    if(!BigInteger.ZERO.equals(a)) {
	      w = w.add(this.z.square().multiply(a));
	    }
	    w = w.mod(this.curve.q);
	    //this.curve.reduce(w);
	    // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
	    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
	    // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
	    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
	    // z3 = 8 * (y1 * z1)^3
	    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
	
	    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
	}
	
	// Simple NAF (Non-Adjacent Form) multiplication algorithm
	// TODO: modularize the multiplication algorithm
	function pointFpMultiply(k) {
	    if(this.isInfinity()) return this;
	    if(k.signum() == 0) return this.curve.getInfinity();
	
	    var e = k;
	    var h = e.multiply(new BigInteger("3"));
	
	    var neg = this.negate();
	    var R = this;
	
	    var i;
	    for(i = h.bitLength() - 2; i > 0; --i) {
		R = R.twice();
	
		var hBit = h.testBit(i);
		var eBit = e.testBit(i);
	
		if (hBit != eBit) {
		    R = R.add(hBit ? this : neg);
		}
	    }
	
	    return R;
	}
	
	// Compute this*j + x*k (simultaneous multiplication)
	function pointFpMultiplyTwo(j,x,k) {
	  var i;
	  if(j.bitLength() > k.bitLength())
	    i = j.bitLength() - 1;
	  else
	    i = k.bitLength() - 1;
	
	  var R = this.curve.getInfinity();
	  var both = this.add(x);
	  while(i >= 0) {
	    R = R.twice();
	    if(j.testBit(i)) {
	      if(k.testBit(i)) {
	        R = R.add(both);
	      }
	      else {
	        R = R.add(this);
	      }
	    }
	    else {
	      if(k.testBit(i)) {
	        R = R.add(x);
	      }
	    }
	    --i;
	  }
	
	  return R;
	}
	
	ECPointFp.prototype.getX = pointFpGetX;
	ECPointFp.prototype.getY = pointFpGetY;
	ECPointFp.prototype.equals = pointFpEquals;
	ECPointFp.prototype.isInfinity = pointFpIsInfinity;
	ECPointFp.prototype.negate = pointFpNegate;
	ECPointFp.prototype.add = pointFpAdd;
	ECPointFp.prototype.twice = pointFpTwice;
	ECPointFp.prototype.multiply = pointFpMultiply;
	ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
	
	// ----------------
	// ECCurveFp
	
	// constructor
	function ECCurveFp(q,a,b) {
	    this.q = q;
	    this.a = this.fromBigInteger(a);
	    this.b = this.fromBigInteger(b);
	    this.infinity = new ECPointFp(this, null, null);
	    this.reducer = new Barrett(this.q);
	}
	
	function curveFpGetQ() {
	    return this.q;
	}
	
	function curveFpGetA() {
	    return this.a;
	}
	
	function curveFpGetB() {
	    return this.b;
	}
	
	function curveFpEquals(other) {
	    if(other == this) return true;
	    return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
	}
	
	function curveFpGetInfinity() {
	    return this.infinity;
	}
	
	function curveFpFromBigInteger(x) {
	    return new ECFieldElementFp(this.q, x);
	}
	
	function curveReduce(x) {
	    this.reducer.reduce(x);
	}
	
	// for now, work with hex strings because they're easier in JS
	function curveFpDecodePointHex(s) {
	    switch(parseInt(s.substr(0,2), 16)) { // first byte
	    case 0:
		return this.infinity;
	    case 2:
	    case 3:
		// point compression not supported yet
		return null;
	    case 4:
	    case 6:
	    case 7:
		var len = (s.length - 2) / 2;
		var xHex = s.substr(2, len);
		var yHex = s.substr(len+2, len);
	
		return new ECPointFp(this,
				     this.fromBigInteger(new BigInteger(xHex, 16)),
				     this.fromBigInteger(new BigInteger(yHex, 16)));
	
	    default: // unsupported
		return null;
	    }
	}
	
	function curveFpEncodePointHex(p) {
		if (p.isInfinity()) return "00";
		var xHex = p.getX().toBigInteger().toString(16);
		var yHex = p.getY().toBigInteger().toString(16);
		var oLen = this.getQ().toString(16).length;
		if ((oLen % 2) != 0) oLen++;
		while (xHex.length < oLen) {
			xHex = "0" + xHex;
		}
		while (yHex.length < oLen) {
			yHex = "0" + yHex;
		}
		return "04" + xHex + yHex;
	}
	
	ECCurveFp.prototype.getQ = curveFpGetQ;
	ECCurveFp.prototype.getA = curveFpGetA;
	ECCurveFp.prototype.getB = curveFpGetB;
	ECCurveFp.prototype.equals = curveFpEquals;
	ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
	ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
	ECCurveFp.prototype.reduce = curveReduce;
	//ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
	ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
	
	// from: https://github.com/kaielvin/jsbn-ec-point-compression
	ECCurveFp.prototype.decodePointHex = function(s)
	{
		var yIsEven;
	    switch(parseInt(s.substr(0,2), 16)) { // first byte
	    case 0:
		return this.infinity;
	    case 2:
		yIsEven = false;
	    case 3:
		if(yIsEven == undefined) yIsEven = true;
		var len = s.length - 2;
		var xHex = s.substr(2, len);
		var x = this.fromBigInteger(new BigInteger(xHex,16));
		var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
		var beta = alpha.sqrt();
	
	    if (beta == null) throw "Invalid point compression";
	
	    var betaValue = beta.toBigInteger();
	    if (betaValue.testBit(0) != yIsEven)
	    {
	        // Use the other root
	        beta = this.fromBigInteger(this.getQ().subtract(betaValue));
	    }
	    return new ECPointFp(this,x,beta);
	    case 4:
	    case 6:
	    case 7:
		var len = (s.length - 2) / 2;
		var xHex = s.substr(2, len);
		var yHex = s.substr(len+2, len);
	
		return new ECPointFp(this,
				     this.fromBigInteger(new BigInteger(xHex, 16)),
				     this.fromBigInteger(new BigInteger(yHex, 16)));
	
	    default: // unsupported
		return null;
	    }
	}
	ECCurveFp.prototype.encodeCompressedPointHex = function(p)
	{
		if (p.isInfinity()) return "00";
		var xHex = p.getX().toBigInteger().toString(16);
		var oLen = this.getQ().toString(16).length;
		if ((oLen % 2) != 0) oLen++;
		while (xHex.length < oLen)
			xHex = "0" + xHex;
		var yPrefix;
		if(p.getY().toBigInteger().isEven()) yPrefix = "02";
		else                                 yPrefix = "03";
	
		return yPrefix + xHex;
	}
	
	
	ECFieldElementFp.prototype.getR = function()
	{
		if(this.r != undefined) return this.r;
	
	    this.r = null;
	    var bitLength = this.q.bitLength();
	    if (bitLength > 128)
	    {
	        var firstWord = this.q.shiftRight(bitLength - 64);
	        if (firstWord.intValue() == -1)
	        {
	            this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
	        }
	    }
	    return this.r;
	}
	ECFieldElementFp.prototype.modMult = function(x1,x2)
	{
	    return this.modReduce(x1.multiply(x2));
	}
	ECFieldElementFp.prototype.modReduce = function(x)
	{
	    if (this.getR() != null)
	    {
	        var qLen = q.bitLength();
	        while (x.bitLength() > (qLen + 1))
	        {
	            var u = x.shiftRight(qLen);
	            var v = x.subtract(u.shiftLeft(qLen));
	            if (!this.getR().equals(BigInteger.ONE))
	            {
	                u = u.multiply(this.getR());
	            }
	            x = u.add(v); 
	        }
	        while (x.compareTo(q) >= 0)
	        {
	            x = x.subtract(q);
	        }
	    }
	    else
	    {
	        x = x.mod(q);
	    }
	    return x;
	}
	ECFieldElementFp.prototype.sqrt = function()
	{
	    if (!this.q.testBit(0)) throw "unsupported";
	
	    // p mod 4 == 3
	    if (this.q.testBit(1))
	    {
	    	var z = new ECFieldElementFp(this.q,this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE),this.q));
	    	return z.square().equals(this) ? z : null;
	    }
	
	    // p mod 4 == 1
	    var qMinusOne = this.q.subtract(BigInteger.ONE);
	
	    var legendreExponent = qMinusOne.shiftRight(1);
	    if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)))
	    {
	        return null;
	    }
	
	    var u = qMinusOne.shiftRight(2);
	    var k = u.shiftLeft(1).add(BigInteger.ONE);
	
	    var Q = this.x;
	    var fourQ = modDouble(modDouble(Q));
	
	    var U, V;
	    do
	    {
	        var P;
	        do
	        {
	            P = new BigInteger(this.q.bitLength(), new SecureRandom());
	        }
	        while (P.compareTo(this.q) >= 0
	            || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));
	
	        var result = this.lucasSequence(P, Q, k);
	        U = result[0];
	        V = result[1];
	
	        if (this.modMult(V, V).equals(fourQ))
	        {
	            // Integer division by 2, mod q
	            if (V.testBit(0))
	            {
	                V = V.add(q);
	            }
	
	            V = V.shiftRight(1);
	
	            return new ECFieldElementFp(q,V);
	        }
	    }
	    while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
	
	    return null;
	}
	ECFieldElementFp.prototype.lucasSequence = function(P,Q,k)
	{
	    var n = k.bitLength();
	    var s = k.getLowestSetBit();
	
	    var Uh = BigInteger.ONE;
	    var Vl = BigInteger.TWO;
	    var Vh = P;
	    var Ql = BigInteger.ONE;
	    var Qh = BigInteger.ONE;
	
	    for (var j = n - 1; j >= s + 1; --j)
	    {
	        Ql = this.modMult(Ql, Qh);
	
	        if (k.testBit(j))
	        {
	            Qh = this.modMult(Ql, Q);
	            Uh = this.modMult(Uh, Vh);
	            Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
	            Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
	        }
	        else
	        {
	            Qh = Ql;
	            Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
	            Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
	            Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
	        }
	    }
	
	    Ql = this.modMult(Ql, Qh);
	    Qh = this.modMult(Ql, Q);
	    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
	    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
	    Ql = this.modMult(Ql, Qh);
	
	    for (var j = 1; j <= s; ++j)
	    {
	        Uh = this.modMult(Uh, Vl);
	        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
	        Ql = this.modMult(Ql, Ql);
	    }
	
	    return [ Uh, Vl ];
	}
	
	var exports = {
	  ECCurveFp: ECCurveFp,
	  ECPointFp: ECPointFp,
	  ECFieldElementFp: ECFieldElementFp
	}
	
	module.exports = exports


/***/ },
/* 671 */
/*!*******************************!*\
  !*** ./~/ecc-jsbn/lib/sec.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	// Named EC curves
	
	// Requires ec.js, jsbn.js, and jsbn2.js
	var BigInteger = __webpack_require__(/*! jsbn */ 667).BigInteger
	var ECCurveFp = __webpack_require__(/*! ./ec.js */ 670).ECCurveFp
	
	
	// ----------------
	// X9ECParameters
	
	// constructor
	function X9ECParameters(curve,g,n,h) {
	    this.curve = curve;
	    this.g = g;
	    this.n = n;
	    this.h = h;
	}
	
	function x9getCurve() {
	    return this.curve;
	}
	
	function x9getG() {
	    return this.g;
	}
	
	function x9getN() {
	    return this.n;
	}
	
	function x9getH() {
	    return this.h;
	}
	
	X9ECParameters.prototype.getCurve = x9getCurve;
	X9ECParameters.prototype.getG = x9getG;
	X9ECParameters.prototype.getN = x9getN;
	X9ECParameters.prototype.getH = x9getH;
	
	// ----------------
	// SECNamedCurves
	
	function fromHex(s) { return new BigInteger(s, 16); }
	
	function secp128r1() {
	    // p = 2^128 - 2^97 - 1
	    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
	    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
	    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
	    //byte[] S = Hex.decode("000E0D4D696E6768756151750CC03A4473D03679");
	    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "161FF7528B899B2D0C28607CA52C5B86"
			+ "CF5AC8395BAFEB13C02DA292DDED7A83");
	    return new X9ECParameters(curve, G, n, h);
	}
	
	function secp160k1() {
	    // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
	    var a = BigInteger.ZERO;
	    var b = fromHex("7");
	    //byte[] S = null;
	    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"
	                + "938CF935318FDCED6BC28286531733C3F03C4FEE");
	    return new X9ECParameters(curve, G, n, h);
	}
	
	function secp160r1() {
	    // p = 2^160 - 2^31 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
	    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
	    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
	    //byte[] S = Hex.decode("1053CDE42C14D696E67687561517533BF3F83345");
	    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
			+ "4A96B5688EF573284664698968C38BB913CBFC82"
			+ "23A628553168947D59DCC912042351377AC5FB32");
	    return new X9ECParameters(curve, G, n, h);
	}
	
	function secp192k1() {
	    // p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
	    var a = BigInteger.ZERO;
	    var b = fromHex("3");
	    //byte[] S = null;
	    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"
	                + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
	    return new X9ECParameters(curve, G, n, h);
	}
	
	function secp192r1() {
	    // p = 2^192 - 2^64 - 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
	    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
	    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
	    //byte[] S = Hex.decode("3045AE6FC8422F64ED579528D38120EAE12196D5");
	    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"
	                + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
	    return new X9ECParameters(curve, G, n, h);
	}
	
	function secp224r1() {
	    // p = 2^224 - 2^96 + 1
	    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
	    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
	    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
	    //byte[] S = Hex.decode("BD71344799D5C7FCDC45B59FA3B9AB8F6A948BC5");
	    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"
	                + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
	    return new X9ECParameters(curve, G, n, h);
	}
	
	function secp256r1() {
	    // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
	    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
	    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
	    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
	    //byte[] S = Hex.decode("C49D360886E704936A6678E1139D26B7819F7E90");
	    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
	    var h = BigInteger.ONE;
	    var curve = new ECCurveFp(p, a, b);
	    var G = curve.decodePointHex("04"
	                + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"
			+ "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
	    return new X9ECParameters(curve, G, n, h);
	}
	
	// TODO: make this into a proper hashtable
	function getSECCurveByName(name) {
	    if(name == "secp128r1") return secp128r1();
	    if(name == "secp160k1") return secp160k1();
	    if(name == "secp160r1") return secp160r1();
	    if(name == "secp192k1") return secp192k1();
	    if(name == "secp192r1") return secp192r1();
	    if(name == "secp224r1") return secp224r1();
	    if(name == "secp256r1") return secp256r1();
	    return null;
	}
	
	module.exports = {
	  "secp128r1":secp128r1,
	  "secp160k1":secp160k1,
	  "secp160r1":secp160r1,
	  "secp192k1":secp192k1,
	  "secp192r1":secp192r1,
	  "secp224r1":secp224r1,
	  "secp256r1":secp256r1
	}


/***/ },
/* 672 */
/*!****************************************!*\
  !*** ./~/http-signature/lib/signer.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Joyent, Inc.  All rights reserved.
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var http = __webpack_require__(/*! http */ 533);
	var util = __webpack_require__(/*! util */ 597);
	var sshpk = __webpack_require__(/*! sshpk */ 637);
	var jsprim = __webpack_require__(/*! jsprim */ 673);
	var utils = __webpack_require__(/*! ./utils */ 636);
	
	var sprintf = __webpack_require__(/*! util */ 597).format;
	
	var HASH_ALGOS = utils.HASH_ALGOS;
	var PK_ALGOS = utils.PK_ALGOS;
	var InvalidAlgorithmError = utils.InvalidAlgorithmError;
	var HttpSignatureError = utils.HttpSignatureError;
	var validateAlgorithm = utils.validateAlgorithm;
	
	///--- Globals
	
	var AUTHZ_FMT =
	  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
	
	///--- Specific Errors
	
	function MissingHeaderError(message) {
	  HttpSignatureError.call(this, message, MissingHeaderError);
	}
	util.inherits(MissingHeaderError, HttpSignatureError);
	
	function StrictParsingError(message) {
	  HttpSignatureError.call(this, message, StrictParsingError);
	}
	util.inherits(StrictParsingError, HttpSignatureError);
	
	/* See createSigner() */
	function RequestSigner(options) {
	  assert.object(options, 'options');
	
	  var alg = [];
	  if (options.algorithm !== undefined) {
	    assert.string(options.algorithm, 'options.algorithm');
	    alg = validateAlgorithm(options.algorithm);
	  }
	  this.rs_alg = alg;
	
	  /*
	   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones
	   * with an rs_signer.
	   *
	   * rs_signFunc-based RequestSigners have to build up their entire signing
	   * string within the rs_lines array and give it to rs_signFunc as a single
	   * concat'd blob. rs_signer-based RequestSigners can add a line at a time to
	   * their signing state by using rs_signer.update(), thus only needing to
	   * buffer the hash function state and one line at a time.
	   */
	  if (options.sign !== undefined) {
	    assert.func(options.sign, 'options.sign');
	    this.rs_signFunc = options.sign;
	
	  } else if (alg[0] === 'hmac' && options.key !== undefined) {
	    assert.string(options.keyId, 'options.keyId');
	    this.rs_keyId = options.keyId;
	
	    if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
	      throw (new TypeError('options.key for HMAC must be a string or Buffer'));
	
	    /*
	     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their
	     * data in chunks rather than requiring it all to be given in one go
	     * at the end, so they are more similar to signers than signFuncs.
	     */
	    this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
	    this.rs_signer.sign = function () {
	      var digest = this.digest('base64');
	      return ({
	        hashAlgorithm: alg[1],
	        toString: function () { return (digest); }
	      });
	    };
	
	  } else if (options.key !== undefined) {
	    var key = options.key;
	    if (typeof (key) === 'string' || Buffer.isBuffer(key))
	      key = sshpk.parsePrivateKey(key);
	
	    assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
	      'options.key must be a sshpk.PrivateKey');
	    this.rs_key = key;
	
	    assert.string(options.keyId, 'options.keyId');
	    this.rs_keyId = options.keyId;
	
	    if (!PK_ALGOS[key.type]) {
	      throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
	        'keys are not supported'));
	    }
	
	    if (alg[0] !== undefined && key.type !== alg[0]) {
	      throw (new InvalidAlgorithmError('options.key must be a ' +
	        alg[0].toUpperCase() + ' key, was given a ' +
	        key.type.toUpperCase() + ' key instead'));
	    }
	
	    this.rs_signer = key.createSign(alg[1]);
	
	  } else {
	    throw (new TypeError('options.sign (func) or options.key is required'));
	  }
	
	  this.rs_headers = [];
	  this.rs_lines = [];
	}
	
	/**
	 * Adds a header to be signed, with its value, into this signer.
	 *
	 * @param {String} header
	 * @param {String} value
	 * @return {String} value written
	 */
	RequestSigner.prototype.writeHeader = function (header, value) {
	  assert.string(header, 'header');
	  header = header.toLowerCase();
	  assert.string(value, 'value');
	
	  this.rs_headers.push(header);
	
	  if (this.rs_signFunc) {
	    this.rs_lines.push(header + ': ' + value);
	
	  } else {
	    var line = header + ': ' + value;
	    if (this.rs_headers.length > 0)
	      line = '\n' + line;
	    this.rs_signer.update(line);
	  }
	
	  return (value);
	};
	
	/**
	 * Adds a default Date header, returning its value.
	 *
	 * @return {String}
	 */
	RequestSigner.prototype.writeDateHeader = function () {
	  return (this.writeHeader('date', jsprim.rfc1123(new Date())));
	};
	
	/**
	 * Adds the request target line to be signed.
	 *
	 * @param {String} method, HTTP method (e.g. 'get', 'post', 'put')
	 * @param {String} path
	 */
	RequestSigner.prototype.writeTarget = function (method, path) {
	  assert.string(method, 'method');
	  assert.string(path, 'path');
	  method = method.toLowerCase();
	  this.writeHeader('(request-target)', method + ' ' + path);
	};
	
	/**
	 * Calculate the value for the Authorization header on this request
	 * asynchronously.
	 *
	 * @param {Func} callback (err, authz)
	 */
	RequestSigner.prototype.sign = function (cb) {
	  assert.func(cb, 'callback');
	
	  if (this.rs_headers.length < 1)
	    throw (new Error('At least one header must be signed'));
	
	  var alg, authz;
	  if (this.rs_signFunc) {
	    var data = this.rs_lines.join('\n');
	    var self = this;
	    this.rs_signFunc(data, function (err, sig) {
	      if (err) {
	        cb(err);
	        return;
	      }
	      try {
	        assert.object(sig, 'signature');
	        assert.string(sig.keyId, 'signature.keyId');
	        assert.string(sig.algorithm, 'signature.algorithm');
	        assert.string(sig.signature, 'signature.signature');
	        alg = validateAlgorithm(sig.algorithm);
	
	        authz = sprintf(AUTHZ_FMT,
	          sig.keyId,
	          sig.algorithm,
	          self.rs_headers.join(' '),
	          sig.signature);
	      } catch (e) {
	        cb(e);
	        return;
	      }
	      cb(null, authz);
	    });
	
	  } else {
	    try {
	      var sigObj = this.rs_signer.sign();
	    } catch (e) {
	      cb(e);
	      return;
	    }
	    alg = (this.rs_alg[0] || this.rs_key.type) + '-' + sigObj.hashAlgorithm;
	    var signature = sigObj.toString();
	    authz = sprintf(AUTHZ_FMT,
	      this.rs_keyId,
	      alg,
	      this.rs_headers.join(' '),
	      signature);
	    cb(null, authz);
	  }
	};
	
	///--- Exported API
	
	module.exports = {
	  /**
	   * Identifies whether a given object is a request signer or not.
	   *
	   * @param {Object} object, the object to identify
	   * @returns {Boolean}
	   */
	  isSigner: function (obj) {
	    if (typeof (obj) === 'object' && obj instanceof RequestSigner)
	      return (true);
	    return (false);
	  },
	
	  /**
	   * Creates a request signer, used to asynchronously build a signature
	   * for a request (does not have to be an http.ClientRequest).
	   *
	   * @param {Object} options, either:
	   *                   - {String} keyId
	   *                   - {String|Buffer} key
	   *                   - {String} algorithm (optional, required for HMAC)
	   *                 or:
	   *                   - {Func} sign (data, cb)
	   * @return {RequestSigner}
	   */
	  createSigner: function createSigner(options) {
	    return (new RequestSigner(options));
	  },
	
	  /**
	   * Adds an 'Authorization' header to an http.ClientRequest object.
	   *
	   * Note that this API will add a Date header if it's not already set. Any
	   * other headers in the options.headers array MUST be present, or this
	   * will throw.
	   *
	   * You shouldn't need to check the return type; it's just there if you want
	   * to be pedantic.
	   *
	   * The optional flag indicates whether parsing should use strict enforcement
	   * of the version draft-cavage-http-signatures-04 of the spec or beyond.
	   * The default is to be loose and support
	   * older versions for compatibility.
	   *
	   * @param {Object} request an instance of http.ClientRequest.
	   * @param {Object} options signing parameters object:
	   *                   - {String} keyId required.
	   *                   - {String} key required (either a PEM or HMAC key).
	   *                   - {Array} headers optional; defaults to ['date'].
	   *                   - {String} algorithm optional (unless key is HMAC);
	   *                              default is the same as the sshpk default
	   *                              signing algorithm for the type of key given
	   *                   - {String} httpVersion optional; defaults to '1.1'.
	   *                   - {Boolean} strict optional; defaults to 'false'.
	   * @return {Boolean} true if Authorization (and optionally Date) were added.
	   * @throws {TypeError} on bad parameter types (input).
	   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with
	   *                                 the given key.
	   * @throws {sshpk.KeyParseError} if key was bad.
	   * @throws {MissingHeaderError} if a header to be signed was specified but
	   *                              was not present.
	   */
	  signRequest: function signRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(options, 'options');
	    assert.optionalString(options.algorithm, 'options.algorithm');
	    assert.string(options.keyId, 'options.keyId');
	    assert.optionalArrayOfString(options.headers, 'options.headers');
	    assert.optionalString(options.httpVersion, 'options.httpVersion');
	
	    if (!request.getHeader('Date'))
	      request.setHeader('Date', jsprim.rfc1123(new Date()));
	    if (!options.headers)
	      options.headers = ['date'];
	    if (!options.httpVersion)
	      options.httpVersion = '1.1';
	
	    var alg = [];
	    if (options.algorithm) {
	      options.algorithm = options.algorithm.toLowerCase();
	      alg = validateAlgorithm(options.algorithm);
	    }
	
	    var i;
	    var stringToSign = '';
	    for (i = 0; i < options.headers.length; i++) {
	      if (typeof (options.headers[i]) !== 'string')
	        throw new TypeError('options.headers must be an array of Strings');
	
	      var h = options.headers[i].toLowerCase();
	
	      if (h === 'request-line') {
	        if (!options.strict) {
	          /**
	           * We allow headers from the older spec drafts if strict parsing isn't
	           * specified in options.
	           */
	          stringToSign +=
	            request.method + ' ' + request.path + ' HTTP/' +
	            options.httpVersion;
	        } else {
	          /* Strict parsing doesn't allow older draft headers. */
	          throw (new StrictParsingError('request-line is not a valid header ' +
	            'with strict parsing enabled.'));
	        }
	      } else if (h === '(request-target)') {
	        stringToSign +=
	          '(request-target): ' + request.method.toLowerCase() + ' ' +
	          request.path;
	      } else {
	        var value = request.getHeader(h);
	        if (value === undefined || value === '') {
	          throw new MissingHeaderError(h + ' was not in the request');
	        }
	        stringToSign += h + ': ' + value;
	      }
	
	      if ((i + 1) < options.headers.length)
	        stringToSign += '\n';
	    }
	
	    /* This is just for unit tests. */
	    if (request.hasOwnProperty('_stringToSign')) {
	      request._stringToSign = stringToSign;
	    }
	
	    var signature;
	    if (alg[0] === 'hmac') {
	      if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
	        throw (new TypeError('options.key must be a string or Buffer'));
	
	      var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
	      hmac.update(stringToSign);
	      signature = hmac.digest('base64');
	
	    } else {
	      var key = options.key;
	      if (typeof (key) === 'string' || Buffer.isBuffer(key))
	        key = sshpk.parsePrivateKey(options.key);
	
	      assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
	        'options.key must be a sshpk.PrivateKey');
	
	      if (!PK_ALGOS[key.type]) {
	        throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
	          'keys are not supported'));
	      }
	
	      if (alg[0] !== undefined && key.type !== alg[0]) {
	        throw (new InvalidAlgorithmError('options.key must be a ' +
	          alg[0].toUpperCase() + ' key, was given a ' +
	          key.type.toUpperCase() + ' key instead'));
	      }
	
	      var signer = key.createSign(alg[1]);
	      signer.update(stringToSign);
	      var sigObj = signer.sign();
	      if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
	        throw (new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() +
	          ' is not a supported hash algorithm'));
	      }
	      options.algorithm = key.type + '-' + sigObj.hashAlgorithm;
	      signature = sigObj.toString();
	      assert.notStrictEqual(signature, '', 'empty signature produced');
	    }
	
	    request.setHeader('Authorization', sprintf(AUTHZ_FMT,
	                                               options.keyId,
	                                               options.algorithm,
	                                               options.headers.join(' '),
	                                               signature));
	
	    return true;
	  }
	
	};


/***/ },
/* 673 */
/*!********************************!*\
  !*** ./~/jsprim/lib/jsprim.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * lib/jsprim.js: utilities for primitive JavaScript types
	 */
	
	var mod_assert = __webpack_require__(/*! assert */ 635);
	var mod_util = __webpack_require__(/*! util */ 597);
	
	var mod_extsprintf = __webpack_require__(/*! extsprintf */ 674);
	var mod_verror = __webpack_require__(/*! verror */ 675);
	var mod_jsonschema = __webpack_require__(/*! json-schema */ 676);
	
	/*
	 * Public interface
	 */
	exports.deepCopy = deepCopy;
	exports.deepEqual = deepEqual;
	exports.isEmpty = isEmpty;
	exports.forEachKey = forEachKey;
	exports.pluck = pluck;
	exports.flattenObject = flattenObject;
	exports.flattenIter = flattenIter;
	exports.validateJsonObject = validateJsonObjectJS;
	exports.validateJsonObjectJS = validateJsonObjectJS;
	exports.randElt = randElt;
	exports.extraProperties = extraProperties;
	exports.mergeObjects = mergeObjects;
	
	exports.startsWith = startsWith;
	exports.endsWith = endsWith;
	
	exports.iso8601 = iso8601;
	exports.rfc1123 = rfc1123;
	exports.parseDateTime = parseDateTime;
	
	exports.hrtimediff = hrtimeDiff;
	exports.hrtimeDiff = hrtimeDiff;
	exports.hrtimeAccum = hrtimeAccum;
	exports.hrtimeAdd = hrtimeAdd;
	exports.hrtimeNanosec = hrtimeNanosec;
	exports.hrtimeMicrosec = hrtimeMicrosec;
	exports.hrtimeMillisec = hrtimeMillisec;
	
	
	/*
	 * Deep copy an acyclic *basic* Javascript object.  This only handles basic
	 * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects
	 * containing these.  This does *not* handle instances of other classes.
	 */
	function deepCopy(obj)
	{
		var ret, key;
		var marker = '__deepCopy';
	
		if (obj && obj[marker])
			throw (new Error('attempted deep copy of cyclic object'));
	
		if (obj && obj.constructor == Object) {
			ret = {};
			obj[marker] = true;
	
			for (key in obj) {
				if (key == marker)
					continue;
	
				ret[key] = deepCopy(obj[key]);
			}
	
			delete (obj[marker]);
			return (ret);
		}
	
		if (obj && obj.constructor == Array) {
			ret = [];
			obj[marker] = true;
	
			for (key = 0; key < obj.length; key++)
				ret.push(deepCopy(obj[key]));
	
			delete (obj[marker]);
			return (ret);
		}
	
		/*
		 * It must be a primitive type -- just return it.
		 */
		return (obj);
	}
	
	function deepEqual(obj1, obj2)
	{
		if (typeof (obj1) != typeof (obj2))
			return (false);
	
		if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
			return (obj1 === obj2);
	
		if (obj1.constructor != obj2.constructor)
			return (false);
	
		var k;
		for (k in obj1) {
			if (!obj2.hasOwnProperty(k))
				return (false);
	
			if (!deepEqual(obj1[k], obj2[k]))
				return (false);
		}
	
		for (k in obj2) {
			if (!obj1.hasOwnProperty(k))
				return (false);
		}
	
		return (true);
	}
	
	function isEmpty(obj)
	{
		var key;
		for (key in obj)
			return (false);
		return (true);
	}
	
	function forEachKey(obj, callback)
	{
		for (var key in obj)
			callback(key, obj[key]);
	}
	
	function pluck(obj, key)
	{
		mod_assert.equal(typeof (key), 'string');
		return (pluckv(obj, key));
	}
	
	function pluckv(obj, key)
	{
		if (obj === null || typeof (obj) !== 'object')
			return (undefined);
	
		if (obj.hasOwnProperty(key))
			return (obj[key]);
	
		var i = key.indexOf('.');
		if (i == -1)
			return (undefined);
	
		var key1 = key.substr(0, i);
		if (!obj.hasOwnProperty(key1))
			return (undefined);
	
		return (pluckv(obj[key1], key.substr(i + 1)));
	}
	
	/*
	 * Invoke callback(row) for each entry in the array that would be returned by
	 * flattenObject(data, depth).  This is just like flattenObject(data,
	 * depth).forEach(callback), except that the intermediate array is never
	 * created.
	 */
	function flattenIter(data, depth, callback)
	{
		doFlattenIter(data, depth, [], callback);
	}
	
	function doFlattenIter(data, depth, accum, callback)
	{
		var each;
		var key;
	
		if (depth === 0) {
			each = accum.slice(0);
			each.push(data);
			callback(each);
			return;
		}
	
		mod_assert.ok(data !== null);
		mod_assert.equal(typeof (data), 'object');
		mod_assert.equal(typeof (depth), 'number');
		mod_assert.ok(depth >= 0);
	
		for (key in data) {
			each = accum.slice(0);
			each.push(key);
			doFlattenIter(data[key], depth - 1, each, callback);
		}
	}
	
	function flattenObject(data, depth)
	{
		if (depth === 0)
			return ([ data ]);
	
		mod_assert.ok(data !== null);
		mod_assert.equal(typeof (data), 'object');
		mod_assert.equal(typeof (depth), 'number');
		mod_assert.ok(depth >= 0);
	
		var rv = [];
		var key;
	
		for (key in data) {
			flattenObject(data[key], depth - 1).forEach(function (p) {
				rv.push([ key ].concat(p));
			});
		}
	
		return (rv);
	}
	
	function startsWith(str, prefix)
	{
		return (str.substr(0, prefix.length) == prefix);
	}
	
	function endsWith(str, suffix)
	{
		return (str.substr(
		    str.length - suffix.length, suffix.length) == suffix);
	}
	
	function iso8601(d)
	{
		if (typeof (d) == 'number')
			d = new Date(d);
		mod_assert.ok(d.constructor === Date);
		return (mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
		    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
		    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
		    d.getUTCMilliseconds()));
	}
	
	var RFC1123_MONTHS = [
	    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
	    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	var RFC1123_DAYS = [
	    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	
	function rfc1123(date) {
		return (mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
		    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
		    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
		    date.getUTCHours(), date.getUTCMinutes(),
		    date.getUTCSeconds()));
	}
	
	/*
	 * Parses a date expressed as a string, as either a number of milliseconds since
	 * the epoch or any string format that Date accepts, giving preference to the
	 * former where these two sets overlap (e.g., small numbers).
	 */
	function parseDateTime(str)
	{
		/*
		 * This is irritatingly implicit, but significantly more concise than
		 * alternatives.  The "+str" will convert a string containing only a
		 * number directly to a Number, or NaN for other strings.  Thus, if the
		 * conversion succeeds, we use it (this is the milliseconds-since-epoch
		 * case).  Otherwise, we pass the string directly to the Date
		 * constructor to parse.
		 */
		var numeric = +str;
		if (!isNaN(numeric)) {
			return (new Date(numeric));
		} else {
			return (new Date(str));
		}
	}
	
	function validateJsonObjectJS(schema, input)
	{
		var report = mod_jsonschema.validate(input, schema);
	
		if (report.errors.length === 0)
			return (null);
	
		/* Currently, we only do anything useful with the first error. */
		var error = report.errors[0];
	
		/* The failed property is given by a URI with an irrelevant prefix. */
		var propname = error['property'];
		var reason = error['message'].toLowerCase();
		var i, j;
	
		/*
		 * There's at least one case where the property error message is
		 * confusing at best.  We work around this here.
		 */
		if ((i = reason.indexOf('the property ')) != -1 &&
		    (j = reason.indexOf(' is not defined in the schema and the ' +
		    'schema does not allow additional properties')) != -1) {
			i += 'the property '.length;
			if (propname === '')
				propname = reason.substr(i, j - i);
			else
				propname = propname + '.' + reason.substr(i, j - i);
	
			reason = 'unsupported property';
		}
	
		var rv = new mod_verror.VError('property "%s": %s', propname, reason);
		rv.jsv_details = error;
		return (rv);
	}
	
	function randElt(arr)
	{
		mod_assert.ok(Array.isArray(arr) && arr.length > 0,
		    'randElt argument must be a non-empty array');
	
		return (arr[Math.floor(Math.random() * arr.length)]);
	}
	
	function assertHrtime(a)
	{
		mod_assert.ok(a[0] >= 0 && a[1] >= 0,
		    'negative numbers not allowed in hrtimes');
		mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
	}
	
	/*
	 * Compute the time elapsed between hrtime readings A and B, where A is later
	 * than B.  hrtime readings come from Node's process.hrtime().  There is no
	 * defined way to represent negative deltas, so it's illegal to diff B from A
	 * where the time denoted by B is later than the time denoted by A.  If this
	 * becomes valuable, we can define a representation and extend the
	 * implementation to support it.
	 */
	function hrtimeDiff(a, b)
	{
		assertHrtime(a);
		assertHrtime(b);
		mod_assert.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
		    'negative differences not allowed');
	
		var rv = [ a[0] - b[0], 0 ];
	
		if (a[1] >= b[1]) {
			rv[1] = a[1] - b[1];
		} else {
			rv[0]--;
			rv[1] = 1e9 - (b[1] - a[1]);
		}
	
		return (rv);
	}
	
	/*
	 * Convert a hrtime reading from the array format returned by Node's
	 * process.hrtime() into a scalar number of nanoseconds.
	 */
	function hrtimeNanosec(a)
	{
		assertHrtime(a);
	
		return (Math.floor(a[0] * 1e9 + a[1]));
	}
	
	/*
	 * Convert a hrtime reading from the array format returned by Node's
	 * process.hrtime() into a scalar number of microseconds.
	 */
	function hrtimeMicrosec(a)
	{
		assertHrtime(a);
	
		return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
	}
	
	/*
	 * Convert a hrtime reading from the array format returned by Node's
	 * process.hrtime() into a scalar number of milliseconds.
	 */
	function hrtimeMillisec(a)
	{
		assertHrtime(a);
	
		return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
	}
	
	/*
	 * Add two hrtime readings A and B, overwriting A with the result of the
	 * addition.  This function is useful for accumulating several hrtime intervals
	 * into a counter.  Returns A.
	 */
	function hrtimeAccum(a, b)
	{
		assertHrtime(a);
		assertHrtime(b);
	
		/*
		 * Accumulate the nanosecond component.
		 */
		a[1] += b[1];
		if (a[1] >= 1e9) {
			/*
			 * The nanosecond component overflowed, so carry to the seconds
			 * field.
			 */
			a[0]++;
			a[1] -= 1e9;
		}
	
		/*
		 * Accumulate the seconds component.
		 */
		a[0] += b[0];
	
		return (a);
	}
	
	/*
	 * Add two hrtime readings A and B, returning the result as a new hrtime array.
	 * Does not modify either input argument.
	 */
	function hrtimeAdd(a, b)
	{
		assertHrtime(a);
	
		var rv = [ a[0], a[1] ];
	
		return (hrtimeAccum(rv, b));
	}
	
	
	/*
	 * Check an object for unexpected properties.  Accepts the object to check, and
	 * an array of allowed property names (strings).  Returns an array of key names
	 * that were found on the object, but did not appear in the list of allowed
	 * properties.  If no properties were found, the returned array will be of
	 * zero length.
	 */
	function extraProperties(obj, allowed)
	{
		mod_assert.ok(typeof (obj) === 'object' && obj !== null,
		    'obj argument must be a non-null object');
		mod_assert.ok(Array.isArray(allowed),
		    'allowed argument must be an array of strings');
		for (var i = 0; i < allowed.length; i++) {
			mod_assert.ok(typeof (allowed[i]) === 'string',
			    'allowed argument must be an array of strings');
		}
	
		return (Object.keys(obj).filter(function (key) {
			return (allowed.indexOf(key) === -1);
		}));
	}
	
	/*
	 * Given three sets of properties "provided" (may be undefined), "overrides"
	 * (required), and "defaults" (may be undefined), construct an object containing
	 * the union of these sets with "overrides" overriding "provided", and
	 * "provided" overriding "defaults".  None of the input objects are modified.
	 */
	function mergeObjects(provided, overrides, defaults)
	{
		var rv, k;
	
		rv = {};
		if (defaults) {
			for (k in defaults)
				rv[k] = defaults[k];
		}
	
		if (provided) {
			for (k in provided)
				rv[k] = provided[k];
		}
	
		if (overrides) {
			for (k in overrides)
				rv[k] = overrides[k];
		}
	
		return (rv);
	}


/***/ },
/* 674 */
/*!****************************************!*\
  !*** ./~/extsprintf/lib/extsprintf.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * extsprintf.js: extended POSIX-style sprintf
	 */
	
	var mod_assert = __webpack_require__(/*! assert */ 635);
	var mod_util = __webpack_require__(/*! util */ 597);
	
	/*
	 * Public interface
	 */
	exports.sprintf = jsSprintf;
	
	/*
	 * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
	 * exception when given a format string we don't understand, rather than
	 * ignoring it, so that we won't break existing programs if/when we go implement
	 * the rest of this.
	 *
	 * This implementation currently supports specifying
	 *	- field alignment ('-' flag),
	 * 	- zero-pad ('0' flag)
	 *	- always show numeric sign ('+' flag),
	 *	- field width
	 *	- conversions for strings, decimal integers, and floats (numbers).
	 *	- argument size specifiers.  These are all accepted but ignored, since
	 *	  Javascript has no notion of the physical size of an argument.
	 *
	 * Everything else is currently unsupported, most notably precision, unsigned
	 * numbers, non-decimal numbers, and characters.
	 */
	function jsSprintf(fmt)
	{
		var regex = [
		    '([^%]*)',				/* normal text */
		    '%',				/* start of format */
		    '([\'\\-+ #0]*?)',			/* flags (optional) */
		    '([1-9]\\d*)?',			/* width (optional) */
		    '(\\.([1-9]\\d*))?',		/* precision (optional) */
		    '[lhjztL]*?',			/* length mods (ignored) */
		    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
		].join('');
	
		var re = new RegExp(regex);
		var args = Array.prototype.slice.call(arguments, 1);
		var flags, width, precision, conversion;
		var left, pad, sign, arg, match;
		var ret = '';
		var argn = 1;
	
		mod_assert.equal('string', typeof (fmt));
	
		while ((match = re.exec(fmt)) !== null) {
			ret += match[1];
			fmt = fmt.substring(match[0].length);
	
			flags = match[2] || '';
			width = match[3] || 0;
			precision = match[4] || '';
			conversion = match[6];
			left = false;
			sign = false;
			pad = ' ';
	
			if (conversion == '%') {
				ret += '%';
				continue;
			}
	
			if (args.length === 0)
				throw (new Error('too few args to sprintf'));
	
			arg = args.shift();
			argn++;
	
			if (flags.match(/[\' #]/))
				throw (new Error(
				    'unsupported flags: ' + flags));
	
			if (precision.length > 0)
				throw (new Error(
				    'non-zero precision not supported'));
	
			if (flags.match(/-/))
				left = true;
	
			if (flags.match(/0/))
				pad = '0';
	
			if (flags.match(/\+/))
				sign = true;
	
			switch (conversion) {
			case 's':
				if (arg === undefined || arg === null)
					throw (new Error('argument ' + argn +
					    ': attempted to print undefined or null ' +
					    'as a string'));
				ret += doPad(pad, width, left, arg.toString());
				break;
	
			case 'd':
				arg = Math.floor(arg);
				/*jsl:fallthru*/
			case 'f':
				sign = sign && arg > 0 ? '+' : '';
				ret += sign + doPad(pad, width, left,
				    arg.toString());
				break;
	
			case 'j': /* non-standard */
				if (width === 0)
					width = 10;
				ret += mod_util.inspect(arg, false, width);
				break;
	
			case 'r': /* non-standard */
				ret += dumpException(arg);
				break;
	
			default:
				throw (new Error('unsupported conversion: ' +
				    conversion));
			}
		}
	
		ret += fmt;
		return (ret);
	}
	
	function doPad(chr, width, left, str)
	{
		var ret = str;
	
		while (ret.length < width) {
			if (left)
				ret += chr;
			else
				ret = chr + ret;
		}
	
		return (ret);
	}
	
	/*
	 * This function dumps long stack traces for exceptions having a cause() method.
	 * See node-verror for an example.
	 */
	function dumpException(ex)
	{
		var ret;
	
		if (!(ex instanceof Error))
			throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));
	
		/* Note that V8 prepends "ex.stack" with ex.toString(). */
		ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
	
		if (ex.cause && typeof (ex.cause) === 'function') {
			var cex = ex.cause();
			if (cex) {
				ret += '\nCaused by: ' + dumpException(cex);
			}
		}
	
		return (ret);
	}


/***/ },
/* 675 */
/*!********************************!*\
  !*** ./~/verror/lib/verror.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	/*
	 * verror.js: richer JavaScript errors
	 */
	
	var mod_assert = __webpack_require__(/*! assert */ 635);
	var mod_util = __webpack_require__(/*! util */ 597);
	
	var mod_extsprintf = __webpack_require__(/*! extsprintf */ 674);
	
	/*
	 * Public interface
	 */
	exports.VError = VError;
	exports.WError = WError;
	exports.MultiError = MultiError;
	
	/*
	 * Like JavaScript's built-in Error class, but supports a "cause" argument and a
	 * printf-style message.  The cause argument can be null.
	 */
	function VError(options)
	{
		var args, causedBy, ctor, tailmsg;
	
		if (options instanceof Error || typeof (options) === 'object') {
			args = Array.prototype.slice.call(arguments, 1);
		} else {
			args = Array.prototype.slice.call(arguments, 0);
			options = undefined;
		}
	
		tailmsg = args.length > 0 ?
		    mod_extsprintf.sprintf.apply(null, args) : '';
		this.jse_shortmsg = tailmsg;
		this.jse_summary = tailmsg;
	
		if (options) {
			causedBy = options.cause;
	
			if (!causedBy || !(options.cause instanceof Error))
				causedBy = options;
	
			if (causedBy && (causedBy instanceof Error)) {
				this.jse_cause = causedBy;
				this.jse_summary += ': ' + causedBy.message;
			}
		}
	
		this.message = this.jse_summary;
		Error.call(this, this.jse_summary);
	
		if (Error.captureStackTrace) {
			ctor = options ? options.constructorOpt : undefined;
			ctor = ctor || arguments.callee;
			Error.captureStackTrace(this, ctor);
		}
	}
	
	mod_util.inherits(VError, Error);
	VError.prototype.name = 'VError';
	
	VError.prototype.toString = function ve_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;
	
		return (str);
	};
	
	VError.prototype.cause = function ve_cause()
	{
		return (this.jse_cause);
	};
	
	
	/*
	 * Represents a collection of errors for the purpose of consumers that generally
	 * only deal with one error.  Callers can extract the individual errors
	 * contained in this object, but may also just treat it as a normal single
	 * error, in which case a summary message will be printed.
	 */
	function MultiError(errors)
	{
		mod_assert.ok(errors.length > 0);
		this.ase_errors = errors;
	
		VError.call(this, errors[0], 'first of %d error%s',
		    errors.length, errors.length == 1 ? '' : 's');
	}
	
	mod_util.inherits(MultiError, VError);
	
	
	
	/*
	 * Like JavaScript's built-in Error class, but supports a "cause" argument which
	 * is wrapped, not "folded in" as with VError.	Accepts a printf-style message.
	 * The cause argument can be null.
	 */
	function WError(options)
	{
		Error.call(this);
	
		var args, cause, ctor;
		if (typeof (options) === 'object') {
			args = Array.prototype.slice.call(arguments, 1);
		} else {
			args = Array.prototype.slice.call(arguments, 0);
			options = undefined;
		}
	
		if (args.length > 0) {
			this.message = mod_extsprintf.sprintf.apply(null, args);
		} else {
			this.message = '';
		}
	
		if (options) {
			if (options instanceof Error) {
				cause = options;
			} else {
				cause = options.cause;
				ctor = options.constructorOpt;
			}
		}
	
		Error.captureStackTrace(this, ctor || this.constructor);
		if (cause)
			this.cause(cause);
	
	}
	
	mod_util.inherits(WError, Error);
	WError.prototype.name = 'WError';
	
	
	WError.prototype.toString = function we_toString()
	{
		var str = (this.hasOwnProperty('name') && this.name ||
			this.constructor.name || this.constructor.prototype.name);
		if (this.message)
			str += ': ' + this.message;
		if (this.we_cause && this.we_cause.message)
			str += '; caused by ' + this.we_cause.toString();
	
		return (str);
	};
	
	WError.prototype.cause = function we_cause(c)
	{
		if (c instanceof Error)
			this.we_cause = c;
	
		return (this.we_cause);
	};


/***/ },
/* 676 */
/*!***************************************!*\
  !*** ./~/json-schema/lib/validate.js ***!
  \***************************************/
/***/ function(module, exports) {

	/**
	 * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
	 *	(http://www.json.com/json-schema-proposal/)
	 *
	 * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
	 * Licensed under the MIT (MIT-LICENSE.txt) license.
	To use the validator call the validate function with an instance object and an optional schema object.
	If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
	that schema will be used to validate and the schema parameter is not necessary (if both exist,
	both validations will occur).
	The validate method will return an array of validation errors. If there are no errors, then an
	empty list will be returned. A validation error will have two properties:
	"property" which indicates which property had the error
	"message" which indicates what the error was
	 */
	({define:typeof define!="undefined"?define:function(deps, factory){module.exports = factory();}}).
	define([], function(){
	var exports = validate;
	// setup primitive classes to be JSON Schema types
	exports.Integer = {type:"integer"};
	var primitiveConstructors = {
		String: String,
		Boolean: Boolean,
		Number: Number,
		Object: Object,
		Array: Array,
		Date: Date
	}
	exports.validate = validate;
	function validate(/*Any*/instance,/*Object*/schema) {
			// Summary:
			//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
			// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
			// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
			// 		both validations will occur).
			// 		The validate method will return an object with two properties:
			// 			valid: A boolean indicating if the instance is valid by the schema
			// 			errors: An array of validation errors. If there are no errors, then an
			// 					empty list will be returned. A validation error will have two properties:
			// 						property: which indicates which property had the error
			// 						message: which indicates what the error was
			//
			return validate(instance, schema, {changing: false});//, coerce: false, existingOnly: false});
		};
	exports.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/property) {
			// Summary:
			// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
			// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
			// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
			// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
			// 		information.
			//
			return validate(value, schema, {changing: property || "property"});
		};
	var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*Object*/options) {
	
		if (!options) options = {};
		var _changing = options.changing;
	
		function getType(schema){
			return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
		}
		var errors = [];
		// validate a value against a property definition
		function checkProp(value, schema, path,i){
	
			var l;
			path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
			function addError(message){
				errors.push({property:path,message:message});
			}
	
			if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
				if(typeof schema == 'function'){
					if(!(value instanceof schema)){
						addError("is not an instance of the class/constructor " + schema.name);
					}
				}else if(schema){
					addError("Invalid schema/property definition " + schema);
				}
				return null;
			}
			if(_changing && schema.readonly){
				addError("is a readonly field, it can not be changed");
			}
			if(schema['extends']){ // if it extends another schema, it must pass that schema as well
				checkProp(value,schema['extends'],path,i);
			}
			// validate a value against a type definition
			function checkType(type,value){
				if(type){
					if(typeof type == 'string' && type != 'any' &&
							(type == 'null' ? value !== null : typeof value != type) &&
							!(value instanceof Array && type == 'array') &&
							!(value instanceof Date && type == 'date') &&
							!(type == 'integer' && value%1===0)){
						return [{property:path,message:(typeof value) + " value found, but a " + type + " is required"}];
					}
					if(type instanceof Array){
						var unionErrors=[];
						for(var j = 0; j < type.length; j++){ // a union type
							if(!(unionErrors=checkType(type[j],value)).length){
								break;
							}
						}
						if(unionErrors.length){
							return unionErrors;
						}
					}else if(typeof type == 'object'){
						var priorErrors = errors;
						errors = [];
						checkProp(value,type,path);
						var theseErrors = errors;
						errors = priorErrors;
						return theseErrors;
					}
				}
				return [];
			}
			if(value === undefined){
				if(schema.required){
					addError("is missing and it is required");
				}
			}else{
				errors = errors.concat(checkType(getType(schema),value));
				if(schema.disallow && !checkType(schema.disallow,value).length){
					addError(" disallowed value was matched");
				}
				if(value !== null){
					if(value instanceof Array){
						if(schema.items){
							var itemsIsArray = schema.items instanceof Array;
							var propDef = schema.items;
							for (i = 0, l = value.length; i < l; i += 1) {
								if (itemsIsArray)
									propDef = schema.items[i];
								if (options.coerce)
									value[i] = options.coerce(value[i], propDef);
								errors.concat(checkProp(value[i],propDef,path,i));
							}
						}
						if(schema.minItems && value.length < schema.minItems){
							addError("There must be a minimum of " + schema.minItems + " in the array");
						}
						if(schema.maxItems && value.length > schema.maxItems){
							addError("There must be a maximum of " + schema.maxItems + " in the array");
						}
					}else if(schema.properties || schema.additionalProperties){
						errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
					}
					if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
						addError("does not match the regex pattern " + schema.pattern);
					}
					if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
						addError("may only be " + schema.maxLength + " characters long");
					}
					if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
						addError("must be at least " + schema.minLength + " characters long");
					}
					if(typeof schema.minimum !== undefined && typeof value == typeof schema.minimum &&
							schema.minimum > value){
						addError("must have a minimum value of " + schema.minimum);
					}
					if(typeof schema.maximum !== undefined && typeof value == typeof schema.maximum &&
							schema.maximum < value){
						addError("must have a maximum value of " + schema.maximum);
					}
					if(schema['enum']){
						var enumer = schema['enum'];
						l = enumer.length;
						var found;
						for(var j = 0; j < l; j++){
							if(enumer[j]===value){
								found=1;
								break;
							}
						}
						if(!found){
							addError("does not have a value in the enumeration " + enumer.join(", "));
						}
					}
					if(typeof schema.maxDecimal == 'number' &&
						(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
						addError("may only have " + schema.maxDecimal + " digits of decimal places");
					}
				}
			}
			return null;
		}
		// validate an object against a schema
		function checkObj(instance,objTypeDef,path,additionalProp){
	
			if(typeof objTypeDef =='object'){
				if(typeof instance != 'object' || instance instanceof Array){
					errors.push({property:path,message:"an object is required"});
				}
				
				for(var i in objTypeDef){ 
					if(objTypeDef.hasOwnProperty(i)){
						var value = instance[i];
						// skip _not_ specified properties
						if (value === undefined && options.existingOnly) continue;
						var propDef = objTypeDef[i];
						// set default
						if(value === undefined && propDef["default"]){
							value = instance[i] = propDef["default"];
						}
						if(options.coerce && i in instance){
							value = instance[i] = options.coerce(value, propDef);
						}
						checkProp(value,propDef,path,i);
					}
				}
			}
			for(i in instance){
				if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
					if (options.filter) {
						delete instance[i];
						continue;
					} else {
						errors.push({property:path,message:(typeof value) + "The property " + i +
							" is not defined in the schema and the schema does not allow additional properties"});
					}
				}
				var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
				if(requires && !(requires in instance)){
					errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
				}
				value = instance[i];
				if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
					if(options.coerce){
						value = instance[i] = options.coerce(value, additionalProp);
					}
					checkProp(value,additionalProp,path,i);
				}
				if(!_changing && value && value.$schema){
					errors = errors.concat(checkProp(value,value.$schema,path,i));
				}
			}
			return errors;
		}
		if(schema){
			checkProp(instance,schema,'',_changing || '');
		}
		if(!_changing && instance && instance.$schema){
			checkProp(instance,instance.$schema,'','');
		}
		return {valid:!errors.length,errors:errors};
	};
	exports.mustBeValid = function(result){
		//	summary:
		//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
		// result: the result returned from checkPropertyChange or validate
		if(!result.valid){
			throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
		}
	}
	
	return exports;
	});


/***/ },
/* 677 */
/*!****************************************!*\
  !*** ./~/http-signature/lib/verify.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.
	
	var assert = __webpack_require__(/*! assert-plus */ 634);
	var crypto = __webpack_require__(/*! crypto */ 601);
	var sshpk = __webpack_require__(/*! sshpk */ 637);
	var utils = __webpack_require__(/*! ./utils */ 636);
	
	var HASH_ALGOS = utils.HASH_ALGOS;
	var PK_ALGOS = utils.PK_ALGOS;
	var InvalidAlgorithmError = utils.InvalidAlgorithmError;
	var HttpSignatureError = utils.HttpSignatureError;
	var validateAlgorithm = utils.validateAlgorithm;
	
	///--- Exported API
	
	module.exports = {
	  /**
	   * Verify RSA/DSA signature against public key.  You are expected to pass in
	   * an object that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} pubkey RSA/DSA private key PEM.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   * @throws {InvalidAlgorithmError}
	   */
	  verifySignature: function verifySignature(parsedSignature, pubkey) {
	    assert.object(parsedSignature, 'parsedSignature');
	    if (typeof (pubkey) === 'string' || Buffer.isBuffer(pubkey))
	      pubkey = sshpk.parseKey(pubkey);
	    assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), 'pubkey must be a sshpk.Key');
	
	    var alg = validateAlgorithm(parsedSignature.algorithm);
	    if (alg[0] === 'hmac' || alg[0] !== pubkey.type)
	      return (false);
	
	    var v = pubkey.createVerify(alg[1]);
	    v.update(parsedSignature.signingString);
	    return (v.verify(parsedSignature.params.signature, 'base64'));
	  },
	
	  /**
	   * Verify HMAC against shared secret.  You are expected to pass in an object
	   * that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} secret HMAC shared secret.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   * @throws {InvalidAlgorithmError}
	   */
	  verifyHMAC: function verifyHMAC(parsedSignature, secret) {
	    assert.object(parsedSignature, 'parsedHMAC');
	    assert.string(secret, 'secret');
	
	    var alg = validateAlgorithm(parsedSignature.algorithm);
	    if (alg[0] !== 'hmac')
	      return (false);
	
	    var hashAlg = alg[1].toUpperCase();
	
	    var hmac = crypto.createHmac(hashAlg, secret);
	    hmac.update(parsedSignature.signingString);
	
	    /*
	     * Now double-hash to avoid leaking timing information - there's
	     * no easy constant-time compare in JS, so we use this approach
	     * instead. See for more info:
	     * https://www.isecpartners.com/blog/2011/february/double-hmac-
	     * verification.aspx
	     */
	    var h1 = crypto.createHmac(hashAlg, secret);
	    h1.update(hmac.digest());
	    h1 = h1.digest();
	    var h2 = crypto.createHmac(hashAlg, secret);
	    h2.update(new Buffer(parsedSignature.params.signature, 'base64'));
	    h2 = h2.digest();
	
	    /* Node 0.8 returns strings from .digest(). */
	    if (typeof (h1) === 'string')
	      return (h1 === h2);
	    /* And node 0.10 lacks the .equals() method on Buffers. */
	    if (Buffer.isBuffer(h1) && !h1.equals)
	      return (h1.toString('binary') === h2.toString('binary'));
	
	    return (h1.equals(h2));
	  }
	};


/***/ },
/* 678 */
/*!*******************************!*\
  !*** ./~/mime-types/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-types
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	
	'use strict'
	
	/**
	 * Module dependencies.
	 * @private
	 */
	
	var db = __webpack_require__(/*! mime-db */ 679)
	var extname = __webpack_require__(/*! path */ 521).extname
	
	/**
	 * Module variables.
	 * @private
	 */
	
	var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/
	var textTypeRegExp = /^text\//i
	
	/**
	 * Module exports.
	 * @public
	 */
	
	exports.charset = charset
	exports.charsets = { lookup: charset }
	exports.contentType = contentType
	exports.extension = extension
	exports.extensions = Object.create(null)
	exports.lookup = lookup
	exports.types = Object.create(null)
	
	// Populate the extensions/types maps
	populateMaps(exports.extensions, exports.types)
	
	/**
	 * Get the default charset for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */
	
	function charset(type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }
	
	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type)
	  var mime = match && db[match[1].toLowerCase()]
	
	  if (mime && mime.charset) {
	    return mime.charset
	  }
	
	  // default text/* to utf-8
	  if (match && textTypeRegExp.test(match[1])) {
	    return 'UTF-8'
	  }
	
	  return false
	}
	
	/**
	 * Create a full Content-Type header given a MIME type or extension.
	 *
	 * @param {string} str
	 * @return {boolean|string}
	 */
	
	function contentType(str) {
	  // TODO: should this even be in this module?
	  if (!str || typeof str !== 'string') {
	    return false
	  }
	
	  var mime = str.indexOf('/') === -1
	    ? exports.lookup(str)
	    : str
	
	  if (!mime) {
	    return false
	  }
	
	  // TODO: use content-type or other module
	  if (mime.indexOf('charset') === -1) {
	    var charset = exports.charset(mime)
	    if (charset) mime += '; charset=' + charset.toLowerCase()
	  }
	
	  return mime
	}
	
	/**
	 * Get the default extension for a MIME type.
	 *
	 * @param {string} type
	 * @return {boolean|string}
	 */
	
	function extension(type) {
	  if (!type || typeof type !== 'string') {
	    return false
	  }
	
	  // TODO: use media-typer
	  var match = extractTypeRegExp.exec(type)
	
	  // get extensions
	  var exts = match && exports.extensions[match[1].toLowerCase()]
	
	  if (!exts || !exts.length) {
	    return false
	  }
	
	  return exts[0]
	}
	
	/**
	 * Lookup the MIME type for a file path/extension.
	 *
	 * @param {string} path
	 * @return {boolean|string}
	 */
	
	function lookup(path) {
	  if (!path || typeof path !== 'string') {
	    return false
	  }
	
	  // get the extension ("ext" or ".ext" or full path)
	  var extension = extname('x.' + path)
	    .toLowerCase()
	    .substr(1)
	
	  if (!extension) {
	    return false
	  }
	
	  return exports.types[extension] || false
	}
	
	/**
	 * Populate the extensions and types maps.
	 * @private
	 */
	
	function populateMaps(extensions, types) {
	  // source preference (least -> most)
	  var preference = ['nginx', 'apache', undefined, 'iana']
	
	  Object.keys(db).forEach(function forEachMimeType(type) {
	    var mime = db[type]
	    var exts = mime.extensions
	
	    if (!exts || !exts.length) {
	      return
	    }
	
	    // mime -> extensions
	    extensions[type] = exts
	
	    // extension -> mime
	    for (var i = 0; i < exts.length; i++) {
	      var extension = exts[i]
	
	      if (types[extension]) {
	        var from = preference.indexOf(db[types[extension]].source)
	        var to = preference.indexOf(mime.source)
	
	        if (types[extension] !== 'application/octet-stream'
	          && from > to || (from === to && types[extension].substr(0, 12) === 'application/')) {
	          // skip the remapping
	          continue
	        }
	      }
	
	      // set the extension -> mime
	      types[extension] = type
	    }
	  })
	}


/***/ },
/* 679 */
/*!****************************!*\
  !*** ./~/mime-db/index.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-db
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */
	
	/**
	 * Module exports.
	 */
	
	module.exports = __webpack_require__(/*! ./db.json */ 680)


/***/ },
/* 680 */
/*!***************************!*\
  !*** ./~/mime-db/db.json ***!
  \***************************/
/***/ function(module, exports) {

	module.exports = {
		"application/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"application/3gpdash-qoe-report+xml": {
			"source": "iana"
		},
		"application/3gpp-ims+xml": {
			"source": "iana"
		},
		"application/a2l": {
			"source": "iana"
		},
		"application/activemessage": {
			"source": "iana"
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": {
			"source": "iana"
		},
		"application/andrew-inset": {
			"source": "iana",
			"extensions": [
				"ez"
			]
		},
		"application/applefile": {
			"source": "iana"
		},
		"application/applixware": {
			"source": "apache",
			"extensions": [
				"aw"
			]
		},
		"application/atf": {
			"source": "iana"
		},
		"application/atfx": {
			"source": "iana"
		},
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"atom"
			]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"extensions": [
				"atomcat"
			]
		},
		"application/atomdeleted+xml": {
			"source": "iana"
		},
		"application/atomicmail": {
			"source": "iana"
		},
		"application/atomsvc+xml": {
			"source": "iana",
			"extensions": [
				"atomsvc"
			]
		},
		"application/atxml": {
			"source": "iana"
		},
		"application/auth-policy+xml": {
			"source": "iana"
		},
		"application/bacnet-xdd+zip": {
			"source": "iana"
		},
		"application/batch-smtp": {
			"source": "iana"
		},
		"application/bdoc": {
			"compressible": false,
			"extensions": [
				"bdoc"
			]
		},
		"application/beep+xml": {
			"source": "iana"
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana"
		},
		"application/call-completion": {
			"source": "iana"
		},
		"application/cals-1840": {
			"source": "iana"
		},
		"application/cbor": {
			"source": "iana"
		},
		"application/ccmp+xml": {
			"source": "iana"
		},
		"application/ccxml+xml": {
			"source": "iana",
			"extensions": [
				"ccxml"
			]
		},
		"application/cdfx+xml": {
			"source": "iana"
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": [
				"cdmia"
			]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": [
				"cdmic"
			]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": [
				"cdmid"
			]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": [
				"cdmio"
			]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": [
				"cdmiq"
			]
		},
		"application/cdni": {
			"source": "iana"
		},
		"application/cea": {
			"source": "iana"
		},
		"application/cea-2018+xml": {
			"source": "iana"
		},
		"application/cellml+xml": {
			"source": "iana"
		},
		"application/cfw": {
			"source": "iana"
		},
		"application/cms": {
			"source": "iana"
		},
		"application/cnrp+xml": {
			"source": "iana"
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/commonground": {
			"source": "iana"
		},
		"application/conference-info+xml": {
			"source": "iana"
		},
		"application/cpl+xml": {
			"source": "iana"
		},
		"application/csrattrs": {
			"source": "iana"
		},
		"application/csta+xml": {
			"source": "iana"
		},
		"application/cstadata+xml": {
			"source": "iana"
		},
		"application/csvm+json": {
			"source": "iana",
			"compressible": true
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": [
				"cu"
			]
		},
		"application/cybercash": {
			"source": "iana"
		},
		"application/dart": {
			"compressible": true
		},
		"application/dash+xml": {
			"source": "iana",
			"extensions": [
				"mpd"
			]
		},
		"application/dashdelta": {
			"source": "iana"
		},
		"application/davmount+xml": {
			"source": "iana",
			"extensions": [
				"davmount"
			]
		},
		"application/dca-rft": {
			"source": "iana"
		},
		"application/dcd": {
			"source": "iana"
		},
		"application/dec-dx": {
			"source": "iana"
		},
		"application/dialog-info+xml": {
			"source": "iana"
		},
		"application/dicom": {
			"source": "iana"
		},
		"application/dii": {
			"source": "iana"
		},
		"application/dit": {
			"source": "iana"
		},
		"application/dns": {
			"source": "iana"
		},
		"application/docbook+xml": {
			"source": "apache",
			"extensions": [
				"dbk"
			]
		},
		"application/dskpp+xml": {
			"source": "iana"
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": [
				"dssc"
			]
		},
		"application/dssc+xml": {
			"source": "iana",
			"extensions": [
				"xdssc"
			]
		},
		"application/dvcs": {
			"source": "iana"
		},
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ecma"
			]
		},
		"application/edi-consent": {
			"source": "iana"
		},
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/efi": {
			"source": "iana"
		},
		"application/emergencycalldata.comment+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.deviceinfo+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.providerinfo+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.serviceinfo+xml": {
			"source": "iana"
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			"source": "iana"
		},
		"application/emma+xml": {
			"source": "iana",
			"extensions": [
				"emma"
			]
		},
		"application/emotionml+xml": {
			"source": "iana"
		},
		"application/encaprtp": {
			"source": "iana"
		},
		"application/epp+xml": {
			"source": "iana"
		},
		"application/epub+zip": {
			"source": "iana",
			"extensions": [
				"epub"
			]
		},
		"application/eshop": {
			"source": "iana"
		},
		"application/exi": {
			"source": "iana",
			"extensions": [
				"exi"
			]
		},
		"application/fastinfoset": {
			"source": "iana"
		},
		"application/fastsoap": {
			"source": "iana"
		},
		"application/fdt+xml": {
			"source": "iana"
		},
		"application/fits": {
			"source": "iana"
		},
		"application/font-sfnt": {
			"source": "iana"
		},
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": [
				"pfr"
			]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"woff"
			]
		},
		"application/font-woff2": {
			"compressible": false,
			"extensions": [
				"woff2"
			]
		},
		"application/framework-attributes+xml": {
			"source": "iana"
		},
		"application/gml+xml": {
			"source": "apache",
			"extensions": [
				"gml"
			]
		},
		"application/gpx+xml": {
			"source": "apache",
			"extensions": [
				"gpx"
			]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": [
				"gxf"
			]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false
		},
		"application/h224": {
			"source": "iana"
		},
		"application/held+xml": {
			"source": "iana"
		},
		"application/http": {
			"source": "iana"
		},
		"application/hyperstudio": {
			"source": "iana",
			"extensions": [
				"stk"
			]
		},
		"application/ibe-key-request+xml": {
			"source": "iana"
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana"
		},
		"application/ibe-pp-data": {
			"source": "iana"
		},
		"application/iges": {
			"source": "iana"
		},
		"application/im-iscomposing+xml": {
			"source": "iana"
		},
		"application/index": {
			"source": "iana"
		},
		"application/index.cmd": {
			"source": "iana"
		},
		"application/index.obj": {
			"source": "iana"
		},
		"application/index.response": {
			"source": "iana"
		},
		"application/index.vnd": {
			"source": "iana"
		},
		"application/inkml+xml": {
			"source": "iana",
			"extensions": [
				"ink",
				"inkml"
			]
		},
		"application/iotp": {
			"source": "iana"
		},
		"application/ipfix": {
			"source": "iana",
			"extensions": [
				"ipfix"
			]
		},
		"application/ipp": {
			"source": "iana"
		},
		"application/isup": {
			"source": "iana"
		},
		"application/its+xml": {
			"source": "iana"
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar",
				"war",
				"ear"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"ser"
			]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"class"
			]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"js"
			]
		},
		"application/jose": {
			"source": "iana"
		},
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"json",
				"map"
			]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": {
			"source": "iana"
		},
		"application/json5": {
			"extensions": [
				"json5"
			]
		},
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"jsonml"
			]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": {
			"source": "iana"
		},
		"application/kpml-request+xml": {
			"source": "iana"
		},
		"application/kpml-response+xml": {
			"source": "iana"
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"jsonld"
			]
		},
		"application/link-format": {
			"source": "iana"
		},
		"application/load-control+xml": {
			"source": "iana"
		},
		"application/lost+xml": {
			"source": "iana",
			"extensions": [
				"lostxml"
			]
		},
		"application/lostsync+xml": {
			"source": "iana"
		},
		"application/lxf": {
			"source": "iana"
		},
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": [
				"hqx"
			]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": [
				"cpt"
			]
		},
		"application/macwriteii": {
			"source": "iana"
		},
		"application/mads+xml": {
			"source": "iana",
			"extensions": [
				"mads"
			]
		},
		"application/manifest+json": {
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"webmanifest"
			]
		},
		"application/marc": {
			"source": "iana",
			"extensions": [
				"mrc"
			]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"extensions": [
				"mrcx"
			]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"extensions": [
				"mathml"
			]
		},
		"application/mathml-content+xml": {
			"source": "iana"
		},
		"application/mathml-presentation+xml": {
			"source": "iana"
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana"
		},
		"application/mbms-deregister+xml": {
			"source": "iana"
		},
		"application/mbms-envelope+xml": {
			"source": "iana"
		},
		"application/mbms-msk+xml": {
			"source": "iana"
		},
		"application/mbms-msk-response+xml": {
			"source": "iana"
		},
		"application/mbms-protection-description+xml": {
			"source": "iana"
		},
		"application/mbms-reception-report+xml": {
			"source": "iana"
		},
		"application/mbms-register+xml": {
			"source": "iana"
		},
		"application/mbms-register-response+xml": {
			"source": "iana"
		},
		"application/mbms-schedule+xml": {
			"source": "iana"
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana"
		},
		"application/mbox": {
			"source": "iana",
			"extensions": [
				"mbox"
			]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana"
		},
		"application/media_control+xml": {
			"source": "iana"
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"extensions": [
				"mscml"
			]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"extensions": [
				"metalink"
			]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"extensions": [
				"meta4"
			]
		},
		"application/mets+xml": {
			"source": "iana",
			"extensions": [
				"mets"
			]
		},
		"application/mf4": {
			"source": "iana"
		},
		"application/mikey": {
			"source": "iana"
		},
		"application/mods+xml": {
			"source": "iana",
			"extensions": [
				"mods"
			]
		},
		"application/moss-keys": {
			"source": "iana"
		},
		"application/moss-signature": {
			"source": "iana"
		},
		"application/mosskey-data": {
			"source": "iana"
		},
		"application/mosskey-request": {
			"source": "iana"
		},
		"application/mp21": {
			"source": "iana",
			"extensions": [
				"m21",
				"mp21"
			]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": [
				"mp4s",
				"m4p"
			]
		},
		"application/mpeg4-generic": {
			"source": "iana"
		},
		"application/mpeg4-iod": {
			"source": "iana"
		},
		"application/mpeg4-iod-xmt": {
			"source": "iana"
		},
		"application/mrb-consumer+xml": {
			"source": "iana"
		},
		"application/mrb-publish+xml": {
			"source": "iana"
		},
		"application/msc-ivr+xml": {
			"source": "iana"
		},
		"application/msc-mixer+xml": {
			"source": "iana"
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"doc",
				"dot"
			]
		},
		"application/mxf": {
			"source": "iana",
			"extensions": [
				"mxf"
			]
		},
		"application/nasdata": {
			"source": "iana"
		},
		"application/news-checkgroups": {
			"source": "iana"
		},
		"application/news-groupinfo": {
			"source": "iana"
		},
		"application/news-transmission": {
			"source": "iana"
		},
		"application/nlsml+xml": {
			"source": "iana"
		},
		"application/nss": {
			"source": "iana"
		},
		"application/ocsp-request": {
			"source": "iana"
		},
		"application/ocsp-response": {
			"source": "iana"
		},
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": [
				"oda"
			]
		},
		"application/odx": {
			"source": "iana"
		},
		"application/oebps-package+xml": {
			"source": "iana",
			"extensions": [
				"opf"
			]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ogx"
			]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"extensions": [
				"omdoc"
			]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/oxps": {
			"source": "iana",
			"extensions": [
				"oxps"
			]
		},
		"application/p2p-overlay+xml": {
			"source": "iana"
		},
		"application/parityfec": {
			"source": "iana"
		},
		"application/patch-ops-error+xml": {
			"source": "iana",
			"extensions": [
				"xer"
			]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pdf"
			]
		},
		"application/pdx": {
			"source": "iana"
		},
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pgp"
			]
		},
		"application/pgp-keys": {
			"source": "iana"
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": [
				"asc",
				"sig"
			]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": [
				"prf"
			]
		},
		"application/pidf+xml": {
			"source": "iana"
		},
		"application/pidf-diff+xml": {
			"source": "iana"
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": [
				"p10"
			]
		},
		"application/pkcs12": {
			"source": "iana"
		},
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": [
				"p7m",
				"p7c"
			]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": [
				"p7s"
			]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": [
				"p8"
			]
		},
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": [
				"ac"
			]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": [
				"cer"
			]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": [
				"crl"
			]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": [
				"pkipath"
			]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": [
				"pki"
			]
		},
		"application/pls+xml": {
			"source": "iana",
			"extensions": [
				"pls"
			]
		},
		"application/poc-settings+xml": {
			"source": "iana"
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/ppsp-tracker+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+json": {
			"source": "iana",
			"compressible": true
		},
		"application/problem+xml": {
			"source": "iana"
		},
		"application/provenance+xml": {
			"source": "iana"
		},
		"application/prs.alvestrand.titrax-sheet": {
			"source": "iana"
		},
		"application/prs.cww": {
			"source": "iana",
			"extensions": [
				"cww"
			]
		},
		"application/prs.hpub+zip": {
			"source": "iana"
		},
		"application/prs.nprend": {
			"source": "iana"
		},
		"application/prs.plucker": {
			"source": "iana"
		},
		"application/prs.rdf-xml-crypt": {
			"source": "iana"
		},
		"application/prs.xsf+xml": {
			"source": "iana"
		},
		"application/pskc+xml": {
			"source": "iana",
			"extensions": [
				"pskcxml"
			]
		},
		"application/qsig": {
			"source": "iana"
		},
		"application/raptorfec": {
			"source": "iana"
		},
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rdf"
			]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"extensions": [
				"rif"
			]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": [
				"rnc"
			]
		},
		"application/remote-printing": {
			"source": "iana"
		},
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"extensions": [
				"rl"
			]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"extensions": [
				"rld"
			]
		},
		"application/rfc+xml": {
			"source": "iana"
		},
		"application/riscos": {
			"source": "iana"
		},
		"application/rlmi+xml": {
			"source": "iana"
		},
		"application/rls-services+xml": {
			"source": "iana",
			"extensions": [
				"rs"
			]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": [
				"gbr"
			]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": [
				"mft"
			]
		},
		"application/rpki-roa": {
			"source": "iana",
			"extensions": [
				"roa"
			]
		},
		"application/rpki-updown": {
			"source": "iana"
		},
		"application/rsd+xml": {
			"source": "apache",
			"extensions": [
				"rsd"
			]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"rss"
			]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtf"
			]
		},
		"application/rtploopback": {
			"source": "iana"
		},
		"application/rtx": {
			"source": "iana"
		},
		"application/samlassertion+xml": {
			"source": "iana"
		},
		"application/samlmetadata+xml": {
			"source": "iana"
		},
		"application/sbml+xml": {
			"source": "iana",
			"extensions": [
				"sbml"
			]
		},
		"application/scaip+xml": {
			"source": "iana"
		},
		"application/scim+json": {
			"source": "iana",
			"compressible": true
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": [
				"scq"
			]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": [
				"scs"
			]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": [
				"spq"
			]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": [
				"spp"
			]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": [
				"sdp"
			]
		},
		"application/sep+xml": {
			"source": "iana"
		},
		"application/sep-exi": {
			"source": "iana"
		},
		"application/session-info": {
			"source": "iana"
		},
		"application/set-payment": {
			"source": "iana"
		},
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": [
				"setpay"
			]
		},
		"application/set-registration": {
			"source": "iana"
		},
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": [
				"setreg"
			]
		},
		"application/sgml": {
			"source": "iana"
		},
		"application/sgml-open-catalog": {
			"source": "iana"
		},
		"application/shf+xml": {
			"source": "iana",
			"extensions": [
				"shf"
			]
		},
		"application/sieve": {
			"source": "iana"
		},
		"application/simple-filter+xml": {
			"source": "iana"
		},
		"application/simple-message-summary": {
			"source": "iana"
		},
		"application/simplesymbolcontainer": {
			"source": "iana"
		},
		"application/slate": {
			"source": "iana"
		},
		"application/smil": {
			"source": "iana"
		},
		"application/smil+xml": {
			"source": "iana",
			"extensions": [
				"smi",
				"smil"
			]
		},
		"application/smpte336m": {
			"source": "iana"
		},
		"application/soap+fastinfoset": {
			"source": "iana"
		},
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": [
				"rq"
			]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"extensions": [
				"srx"
			]
		},
		"application/spirits-event+xml": {
			"source": "iana"
		},
		"application/sql": {
			"source": "iana"
		},
		"application/srgs": {
			"source": "iana",
			"extensions": [
				"gram"
			]
		},
		"application/srgs+xml": {
			"source": "iana",
			"extensions": [
				"grxml"
			]
		},
		"application/sru+xml": {
			"source": "iana",
			"extensions": [
				"sru"
			]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"extensions": [
				"ssdl"
			]
		},
		"application/ssml+xml": {
			"source": "iana",
			"extensions": [
				"ssml"
			]
		},
		"application/tamp-apex-update": {
			"source": "iana"
		},
		"application/tamp-apex-update-confirm": {
			"source": "iana"
		},
		"application/tamp-community-update": {
			"source": "iana"
		},
		"application/tamp-community-update-confirm": {
			"source": "iana"
		},
		"application/tamp-error": {
			"source": "iana"
		},
		"application/tamp-sequence-adjust": {
			"source": "iana"
		},
		"application/tamp-sequence-adjust-confirm": {
			"source": "iana"
		},
		"application/tamp-status-query": {
			"source": "iana"
		},
		"application/tamp-status-response": {
			"source": "iana"
		},
		"application/tamp-update": {
			"source": "iana"
		},
		"application/tamp-update-confirm": {
			"source": "iana"
		},
		"application/tar": {
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"extensions": [
				"tei",
				"teicorpus"
			]
		},
		"application/thraud+xml": {
			"source": "iana",
			"extensions": [
				"tfi"
			]
		},
		"application/timestamp-query": {
			"source": "iana"
		},
		"application/timestamp-reply": {
			"source": "iana"
		},
		"application/timestamped-data": {
			"source": "iana",
			"extensions": [
				"tsd"
			]
		},
		"application/ttml+xml": {
			"source": "iana"
		},
		"application/tve-trigger": {
			"source": "iana"
		},
		"application/ulpfec": {
			"source": "iana"
		},
		"application/urc-grpsheet+xml": {
			"source": "iana"
		},
		"application/urc-ressheet+xml": {
			"source": "iana"
		},
		"application/urc-targetdesc+xml": {
			"source": "iana"
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana"
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana"
		},
		"application/vemmi": {
			"source": "iana"
		},
		"application/vividence.scriptfile": {
			"source": "apache"
		},
		"application/vnd.3gpp-prose+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.access-transfer-events+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.mid-call+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": [
				"plb"
			]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": [
				"psb"
			]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": [
				"pvb"
			]
		},
		"application/vnd.3gpp.sms": {
			"source": "iana"
		},
		"application/vnd.3gpp.sms+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.ussd+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp2.sms": {
			"source": "iana"
		},
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": [
				"tcap"
			]
		},
		"application/vnd.3lightssoftware.imagescal": {
			"source": "iana"
		},
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": [
				"pwn"
			]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": [
				"aso"
			]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": [
				"imp"
			]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": [
				"acu"
			]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": [
				"atc",
				"acutc"
			]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"extensions": [
				"air"
			]
		},
		"application/vnd.adobe.flash.movie": {
			"source": "iana"
		},
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": [
				"fcdt"
			]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": [
				"fxp",
				"fxpl"
			]
		},
		"application/vnd.adobe.partial-upload": {
			"source": "iana"
		},
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"extensions": [
				"xdp"
			]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": [
				"xfdf"
			]
		},
		"application/vnd.aether.imp": {
			"source": "iana"
		},
		"application/vnd.ah-barcode": {
			"source": "iana"
		},
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": [
				"ahead"
			]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": [
				"azf"
			]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": [
				"azs"
			]
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": [
				"azw"
			]
		},
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": [
				"acc"
			]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": [
				"ami"
			]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana"
		},
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"apk"
			]
		},
		"application/vnd.anki": {
			"source": "iana"
		},
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": [
				"cii"
			]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": [
				"fti"
			]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": [
				"atx"
			]
		},
		"application/vnd.apache.thrift.binary": {
			"source": "iana"
		},
		"application/vnd.apache.thrift.compact": {
			"source": "iana"
		},
		"application/vnd.apache.thrift.json": {
			"source": "iana"
		},
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"extensions": [
				"mpkg"
			]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": [
				"m3u8"
			]
		},
		"application/vnd.apple.pkpass": {
			"compressible": false,
			"extensions": [
				"pkpass"
			]
		},
		"application/vnd.arastra.swi": {
			"source": "iana"
		},
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": [
				"swi"
			]
		},
		"application/vnd.artsquare": {
			"source": "iana"
		},
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": [
				"iota"
			]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": [
				"aep"
			]
		},
		"application/vnd.autopackage": {
			"source": "iana"
		},
		"application/vnd.avistar+xml": {
			"source": "iana"
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana"
		},
		"application/vnd.balsamiq.bmpr": {
			"source": "iana"
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.biopax.rdf+xml": {
			"source": "iana"
		},
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": [
				"mpm"
			]
		},
		"application/vnd.bluetooth.ep.oob": {
			"source": "iana"
		},
		"application/vnd.bluetooth.le.oob": {
			"source": "iana"
		},
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": [
				"bmi"
			]
		},
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": [
				"rep"
			]
		},
		"application/vnd.cab-jscript": {
			"source": "iana"
		},
		"application/vnd.canon-cpdl": {
			"source": "iana"
		},
		"application/vnd.canon-lips": {
			"source": "iana"
		},
		"application/vnd.cendio.thinlinc.clientconf": {
			"source": "iana"
		},
		"application/vnd.century-systems.tcp_stream": {
			"source": "iana"
		},
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"extensions": [
				"cdxml"
			]
		},
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": [
				"mmd"
			]
		},
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": [
				"cdy"
			]
		},
		"application/vnd.cirpack.isdn-ext": {
			"source": "iana"
		},
		"application/vnd.citationstyles.style+xml": {
			"source": "iana"
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": [
				"cla"
			]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": [
				"rp9"
			]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": [
				"c11amc"
			]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": [
				"c11amz"
			]
		},
		"application/vnd.coffeescript": {
			"source": "iana"
		},
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.commerce-battelle": {
			"source": "iana"
		},
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": [
				"csp"
			]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": [
				"cdbcmsg"
			]
		},
		"application/vnd.coreos.ignition+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": [
				"cmc"
			]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": [
				"clkx"
			]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": [
				"clkk"
			]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": [
				"clkp"
			]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": [
				"clkt"
			]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": [
				"clkw"
			]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"extensions": [
				"wbs"
			]
		},
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": [
				"pml"
			]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana"
		},
		"application/vnd.cups-pdf": {
			"source": "iana"
		},
		"application/vnd.cups-postscript": {
			"source": "iana"
		},
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": [
				"ppd"
			]
		},
		"application/vnd.cups-raster": {
			"source": "iana"
		},
		"application/vnd.cups-raw": {
			"source": "iana"
		},
		"application/vnd.curl": {
			"source": "iana"
		},
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": [
				"car"
			]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": [
				"pcurl"
			]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana"
		},
		"application/vnd.cybank": {
			"source": "iana"
		},
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"dart"
			]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": [
				"rdz"
			]
		},
		"application/vnd.debian.binary-package": {
			"source": "iana"
		},
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"extensions": [
				"uvt",
				"uvvt"
			]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": [
				"uvx",
				"uvvx"
			]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": [
				"uvz",
				"uvvz"
			]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": [
				"fe_launch"
			]
		},
		"application/vnd.desmume-movie": {
			"source": "iana"
		},
		"application/vnd.desmume.movie": {
			"source": "apache"
		},
		"application/vnd.dir-bi.plate-dl-nosuffix": {
			"source": "iana"
		},
		"application/vnd.dm.delegation+xml": {
			"source": "iana"
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": [
				"dna"
			]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": [
				"mlp"
			]
		},
		"application/vnd.dolby.mobile.1": {
			"source": "iana"
		},
		"application/vnd.dolby.mobile.2": {
			"source": "iana"
		},
		"application/vnd.doremir.scorecloud-binary-document": {
			"source": "iana"
		},
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": [
				"dpg"
			]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": [
				"dfac"
			]
		},
		"application/vnd.drive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": [
				"kpxx"
			]
		},
		"application/vnd.dtg.local": {
			"source": "iana"
		},
		"application/vnd.dtg.local.flash": {
			"source": "iana"
		},
		"application/vnd.dtg.local.html": {
			"source": "iana"
		},
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": [
				"ait"
			]
		},
		"application/vnd.dvb.dvbj": {
			"source": "iana"
		},
		"application/vnd.dvb.esgcontainer": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcdftnotifaccess": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgaccess": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgaccess2": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgpdd": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcroaming": {
			"source": "iana"
		},
		"application/vnd.dvb.iptv.alfec-base": {
			"source": "iana"
		},
		"application/vnd.dvb.iptv.alfec-enhancement": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.pfr": {
			"source": "iana"
		},
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": [
				"svc"
			]
		},
		"application/vnd.dxr": {
			"source": "iana"
		},
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": [
				"geo"
			]
		},
		"application/vnd.dzr": {
			"source": "iana"
		},
		"application/vnd.easykaraoke.cdgdownload": {
			"source": "iana"
		},
		"application/vnd.ecdis-update": {
			"source": "iana"
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": [
				"mag"
			]
		},
		"application/vnd.ecowin.filerequest": {
			"source": "iana"
		},
		"application/vnd.ecowin.fileupdate": {
			"source": "iana"
		},
		"application/vnd.ecowin.series": {
			"source": "iana"
		},
		"application/vnd.ecowin.seriesrequest": {
			"source": "iana"
		},
		"application/vnd.ecowin.seriesupdate": {
			"source": "iana"
		},
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana"
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": [
				"nml"
			]
		},
		"application/vnd.enphase.envoy": {
			"source": "iana"
		},
		"application/vnd.eprints.data+xml": {
			"source": "iana"
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": [
				"esf"
			]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": [
				"msf"
			]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": [
				"qam"
			]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": [
				"slt"
			]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": [
				"ssf"
			]
		},
		"application/vnd.ericsson.quickcall": {
			"source": "iana"
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"extensions": [
				"es3",
				"et3"
			]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana"
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana"
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.mheg5": {
			"source": "iana"
		},
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.timestamp-token": {
			"source": "iana"
		},
		"application/vnd.etsi.tsl+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.tsl.der": {
			"source": "iana"
		},
		"application/vnd.eudora.data": {
			"source": "iana"
		},
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": [
				"ez2"
			]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": [
				"ez3"
			]
		},
		"application/vnd.f-secure.mobile": {
			"source": "iana"
		},
		"application/vnd.fastcopy-disk-image": {
			"source": "iana"
		},
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": [
				"fdf"
			]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": [
				"mseed"
			]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": [
				"seed",
				"dataless"
			]
		},
		"application/vnd.ffsns": {
			"source": "iana"
		},
		"application/vnd.filmit.zfc": {
			"source": "iana"
		},
		"application/vnd.fints": {
			"source": "iana"
		},
		"application/vnd.firemonkeys.cloudcell": {
			"source": "iana"
		},
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": [
				"gph"
			]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": [
				"ftc"
			]
		},
		"application/vnd.font-fontforge-sfd": {
			"source": "iana"
		},
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": [
				"fnc"
			]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": [
				"ltf"
			]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": [
				"fsc"
			]
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": [
				"oas"
			]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": [
				"oa2"
			]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": [
				"oa3"
			]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": [
				"fg5"
			]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": [
				"bh2"
			]
		},
		"application/vnd.fujixerox.art-ex": {
			"source": "iana"
		},
		"application/vnd.fujixerox.art4": {
			"source": "iana"
		},
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": [
				"ddd"
			]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": [
				"xdw"
			]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": [
				"xbd"
			]
		},
		"application/vnd.fujixerox.docuworks.container": {
			"source": "iana"
		},
		"application/vnd.fujixerox.hbpl": {
			"source": "iana"
		},
		"application/vnd.fut-misnet": {
			"source": "iana"
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": [
				"fzs"
			]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": [
				"txd"
			]
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana"
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": [
				"ggb"
			]
		},
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": [
				"ggt"
			]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": [
				"gex",
				"gre"
			]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": [
				"gxt"
			]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": [
				"g2w"
			]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": [
				"g3w"
			]
		},
		"application/vnd.gerber": {
			"source": "iana"
		},
		"application/vnd.globalplatform.card-content-mgt": {
			"source": "iana"
		},
		"application/vnd.globalplatform.card-content-mgt-response": {
			"source": "iana"
		},
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": [
				"gmx"
			]
		},
		"application/vnd.google-apps.document": {
			"compressible": false,
			"extensions": [
				"gdoc"
			]
		},
		"application/vnd.google-apps.presentation": {
			"compressible": false,
			"extensions": [
				"gslides"
			]
		},
		"application/vnd.google-apps.spreadsheet": {
			"compressible": false,
			"extensions": [
				"gsheet"
			]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"kml"
			]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"kmz"
			]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana"
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana"
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana"
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": [
				"gqf",
				"gqs"
			]
		},
		"application/vnd.gridmp": {
			"source": "iana"
		},
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": [
				"gac"
			]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": [
				"ghf"
			]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": [
				"gim"
			]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": [
				"grv"
			]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": [
				"gtm"
			]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": [
				"tpl"
			]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": [
				"vcg"
			]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"extensions": [
				"hal"
			]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"extensions": [
				"zmm"
			]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": [
				"hbci"
			]
		},
		"application/vnd.hcl-bireports": {
			"source": "iana"
		},
		"application/vnd.hdt": {
			"source": "iana"
		},
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": [
				"les"
			]
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": [
				"hpgl"
			]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": [
				"hpid"
			]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": [
				"hps"
			]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": [
				"jlt"
			]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": [
				"pcl"
			]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": [
				"pclxl"
			]
		},
		"application/vnd.httphone": {
			"source": "iana"
		},
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": [
				"sfd-hdstx"
			]
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": {
			"source": "iana"
		},
		"application/vnd.ibm.afplinedata": {
			"source": "iana"
		},
		"application/vnd.ibm.electronic-media": {
			"source": "iana"
		},
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": [
				"mpy"
			]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": [
				"irm"
			]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": [
				"sc"
			]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": [
				"icc",
				"icm"
			]
		},
		"application/vnd.ieee.1905": {
			"source": "iana"
		},
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": [
				"igl"
			]
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": [
				"ivp"
			]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": [
				"ivu"
			]
		},
		"application/vnd.ims.imsccv1p1": {
			"source": "iana"
		},
		"application/vnd.ims.imsccv1p2": {
			"source": "iana"
		},
		"application/vnd.ims.imsccv1p3": {
			"source": "iana"
		},
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana"
		},
		"application/vnd.informix-visionary": {
			"source": "iana"
		},
		"application/vnd.infotech.project": {
			"source": "iana"
		},
		"application/vnd.infotech.project+xml": {
			"source": "iana"
		},
		"application/vnd.innopath.wamp.notification": {
			"source": "iana"
		},
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": [
				"igm"
			]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": [
				"xpw",
				"xpx"
			]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": [
				"i2g"
			]
		},
		"application/vnd.intertrust.digibox": {
			"source": "iana"
		},
		"application/vnd.intertrust.nncp": {
			"source": "iana"
		},
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": [
				"qbo"
			]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": [
				"qfx"
			]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana"
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": [
				"rcprofile"
			]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"extensions": [
				"irp"
			]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": [
				"xpr"
			]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": [
				"fcs"
			]
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": [
				"jam"
			]
		},
		"application/vnd.japannet-directory-service": {
			"source": "iana"
		},
		"application/vnd.japannet-jpnstore-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-payment-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-registration": {
			"source": "iana"
		},
		"application/vnd.japannet-registration-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-setstore-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-verification": {
			"source": "iana"
		},
		"application/vnd.japannet-verification-wakeup": {
			"source": "iana"
		},
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": [
				"rms"
			]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": [
				"jisp"
			]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": [
				"joda"
			]
		},
		"application/vnd.jsk.isdn-ngn": {
			"source": "iana"
		},
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": [
				"ktz",
				"ktr"
			]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": [
				"karbon"
			]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": [
				"chrt"
			]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": [
				"kfo"
			]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": [
				"flw"
			]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": [
				"kon"
			]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": [
				"kpr",
				"kpt"
			]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": [
				"ksp"
			]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": [
				"kwd",
				"kwt"
			]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": [
				"htke"
			]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": [
				"kia"
			]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": [
				"kne",
				"knp"
			]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": [
				"sse"
			]
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"extensions": [
				"lasxml"
			]
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana"
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": [
				"lbd"
			]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"extensions": [
				"lbe"
			]
		},
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": [
				"123"
			]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": [
				"apr"
			]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": [
				"pre"
			]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": [
				"nsf"
			]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": [
				"org"
			]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": [
				"scm"
			]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": [
				"lwp"
			]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": [
				"portpkg"
			]
		},
		"application/vnd.mapbox-vector-tile": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.mdcf": {
			"source": "iana"
		},
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxmind.maxmind-db": {
			"source": "iana"
		},
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": [
				"mcd"
			]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": [
				"mc1"
			]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": [
				"cdkey"
			]
		},
		"application/vnd.meridian-slingshot": {
			"source": "iana"
		},
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": [
				"mwf"
			]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": [
				"mfm"
			]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": [
				"flo"
			]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": [
				"igx"
			]
		},
		"application/vnd.microsoft.portable-executable": {
			"source": "iana"
		},
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": [
				"mif"
			]
		},
		"application/vnd.minisoft-hp3000-save": {
			"source": "iana"
		},
		"application/vnd.mitsubishi.misty-guard.trustweb": {
			"source": "iana"
		},
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": [
				"daf"
			]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": [
				"dis"
			]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": [
				"mbk"
			]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": [
				"mqy"
			]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": [
				"msl"
			]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": [
				"plc"
			]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": [
				"txf"
			]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": [
				"mpn"
			]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": [
				"mpc"
			]
		},
		"application/vnd.motorola.flexsuite": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.adsi": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.fis": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.gotap": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.kmr": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.ttc": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.wem": {
			"source": "iana"
		},
		"application/vnd.motorola.iprm": {
			"source": "iana"
		},
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xul"
			]
		},
		"application/vnd.ms-3mfdocument": {
			"source": "iana"
		},
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": [
				"cil"
			]
		},
		"application/vnd.ms-asf": {
			"source": "iana"
		},
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": [
				"cab"
			]
		},
		"application/vnd.ms-color.iccprofile": {
			"source": "apache"
		},
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlam"
			]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlsb"
			]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlsm"
			]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xltm"
			]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"eot"
			]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": [
				"chm"
			]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": [
				"ims"
			]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": [
				"lrm"
			]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana"
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": [
				"thmx"
			]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-package.obfuscated-opentype": {
			"source": "apache"
		},
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": [
				"cat"
			]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": [
				"stl"
			]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana"
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"ppam"
			]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"pptm"
			]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"sldm"
			]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"ppsm"
			]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"potm"
			]
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			"source": "iana"
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache"
		},
		"application/vnd.ms-printschematicket+xml": {
			"source": "iana"
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": [
				"mpp",
				"mpt"
			]
		},
		"application/vnd.ms-tnef": {
			"source": "iana"
		},
		"application/vnd.ms-windows.devicepairing": {
			"source": "iana"
		},
		"application/vnd.ms-windows.nwprinting.oob": {
			"source": "iana"
		},
		"application/vnd.ms-windows.printerpairing": {
			"source": "iana"
		},
		"application/vnd.ms-windows.wsd.oob": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.lic-chlg-req": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.lic-resp": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.meter-chlg-req": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.meter-resp": {
			"source": "iana"
		},
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"docm"
			]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"dotm"
			]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": [
				"wpl"
			]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xps"
			]
		},
		"application/vnd.msa-disk-image": {
			"source": "iana"
		},
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": [
				"mseq"
			]
		},
		"application/vnd.msign": {
			"source": "iana"
		},
		"application/vnd.multiad.creator": {
			"source": "iana"
		},
		"application/vnd.multiad.creator.cif": {
			"source": "iana"
		},
		"application/vnd.music-niff": {
			"source": "iana"
		},
		"application/vnd.musician": {
			"source": "iana",
			"extensions": [
				"mus"
			]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": [
				"msty"
			]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": [
				"taglet"
			]
		},
		"application/vnd.ncd.control": {
			"source": "iana"
		},
		"application/vnd.ncd.reference": {
			"source": "iana"
		},
		"application/vnd.nervana": {
			"source": "iana"
		},
		"application/vnd.netfpx": {
			"source": "iana"
		},
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": [
				"nlu"
			]
		},
		"application/vnd.nintendo.nitro.rom": {
			"source": "iana"
		},
		"application/vnd.nintendo.snes.rom": {
			"source": "iana"
		},
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": [
				"ntf",
				"nitf"
			]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": [
				"nnd"
			]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": [
				"nns"
			]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": [
				"nnw"
			]
		},
		"application/vnd.nokia.catalogs": {
			"source": "iana"
		},
		"application/vnd.nokia.conml+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.conml+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.isds-radio-presets": {
			"source": "iana"
		},
		"application/vnd.nokia.landmark+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.landmark+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": [
				"ngdat"
			]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": [
				"n-gage"
			]
		},
		"application/vnd.nokia.ncd": {
			"source": "iana"
		},
		"application/vnd.nokia.pcd+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.pcd+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": [
				"rpst"
			]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": [
				"rpss"
			]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": [
				"edm"
			]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": [
				"edx"
			]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": [
				"ext"
			]
		},
		"application/vnd.ntt-local.content-share": {
			"source": "iana"
		},
		"application/vnd.ntt-local.file-transfer": {
			"source": "iana"
		},
		"application/vnd.ntt-local.ogw_remote-access": {
			"source": "iana"
		},
		"application/vnd.ntt-local.sip-ta_remote": {
			"source": "iana"
		},
		"application/vnd.ntt-local.sip-ta_tcp_stream": {
			"source": "iana"
		},
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": [
				"odc"
			]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": [
				"otc"
			]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": [
				"odb"
			]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": [
				"odf"
			]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": [
				"odft"
			]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odg"
			]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": [
				"otg"
			]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": [
				"odi"
			]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": [
				"oti"
			]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odp"
			]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": [
				"otp"
			]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ods"
			]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": [
				"ots"
			]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odt"
			]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": [
				"odm"
			]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": [
				"ott"
			]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": [
				"oth"
			]
		},
		"application/vnd.obn": {
			"source": "iana"
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.cspg-hexbinary": {
			"source": "iana"
		},
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.pae.gem": {
			"source": "iana"
		},
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana"
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": [
				"xo"
			]
		},
		"application/vnd.oma-scws-config": {
			"source": "iana"
		},
		"application/vnd.oma-scws-http-request": {
			"source": "iana"
		},
		"application/vnd.oma-scws-http-response": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.ltkm": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.provisioningtrigger": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgboot": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgdu": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.simple-symbol-container": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.stkm": {
			"source": "iana"
		},
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana"
		},
		"application/vnd.oma.dcd": {
			"source": "iana"
		},
		"application/vnd.oma.dcdc": {
			"source": "iana"
		},
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"extensions": [
				"dd2"
			]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana"
		},
		"application/vnd.oma.pal+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.push": {
			"source": "iana"
		},
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana"
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana"
		},
		"application/vnd.omads-email+xml": {
			"source": "iana"
		},
		"application/vnd.omads-file+xml": {
			"source": "iana"
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana"
		},
		"application/vnd.omaloc-supl-init": {
			"source": "iana"
		},
		"application/vnd.onepager": {
			"source": "iana"
		},
		"application/vnd.openblox.game+xml": {
			"source": "iana"
		},
		"application/vnd.openblox.game-binary": {
			"source": "iana"
		},
		"application/vnd.openeye.oeb": {
			"source": "iana"
		},
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": [
				"oxt"
			]
		},
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pptx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": [
				"sldx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": [
				"ppsx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "apache",
			"extensions": [
				"potx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xlsx"
			]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "apache",
			"extensions": [
				"xltx"
			]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"docx"
			]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "apache",
			"extensions": [
				"dotx"
			]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana"
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": {
			"source": "iana"
		},
		"application/vnd.osa.netdeploy": {
			"source": "iana"
		},
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": [
				"mgp"
			]
		},
		"application/vnd.osgi.bundle": {
			"source": "iana"
		},
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": [
				"dp"
			]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": [
				"esa"
			]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana"
		},
		"application/vnd.oxli.countgraph": {
			"source": "iana"
		},
		"application/vnd.pagerduty+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": {
			"source": "iana"
		},
		"application/vnd.paos+xml": {
			"source": "iana"
		},
		"application/vnd.paos.xml": {
			"source": "apache"
		},
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": [
				"paw"
			]
		},
		"application/vnd.pcos": {
			"source": "iana"
		},
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": [
				"str"
			]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": [
				"ei6"
			]
		},
		"application/vnd.piaccess.application-licence": {
			"source": "iana"
		},
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": [
				"efif"
			]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": [
				"wg"
			]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana"
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": [
				"plf"
			]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": [
				"pbd"
			]
		},
		"application/vnd.powerbuilder6-s": {
			"source": "iana"
		},
		"application/vnd.powerbuilder7": {
			"source": "iana"
		},
		"application/vnd.powerbuilder7-s": {
			"source": "iana"
		},
		"application/vnd.powerbuilder75": {
			"source": "iana"
		},
		"application/vnd.powerbuilder75-s": {
			"source": "iana"
		},
		"application/vnd.preminet": {
			"source": "iana"
		},
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": [
				"box"
			]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": [
				"mgz"
			]
		},
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": [
				"qps"
			]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": [
				"ptid"
			]
		},
		"application/vnd.pwg-multiplexed": {
			"source": "iana"
		},
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana"
		},
		"application/vnd.qualcomm.brew-app-res": {
			"source": "iana"
		},
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": {
			"source": "iana"
		},
		"application/vnd.radisys.moml+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana"
		},
		"application/vnd.rainstor.data": {
			"source": "iana"
		},
		"application/vnd.rapid": {
			"source": "iana"
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": [
				"bed"
			]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": [
				"mxl"
			]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"extensions": [
				"musicxml"
			]
		},
		"application/vnd.renlearn.rlprint": {
			"source": "iana"
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": [
				"cryptonote"
			]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": [
				"cod"
			]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": [
				"rm"
			]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": [
				"rmvb"
			]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"extensions": [
				"link66"
			]
		},
		"application/vnd.rs-274x": {
			"source": "iana"
		},
		"application/vnd.ruckus.download": {
			"source": "iana"
		},
		"application/vnd.s3sms": {
			"source": "iana"
		},
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": [
				"st"
			]
		},
		"application/vnd.sbm.cid": {
			"source": "iana"
		},
		"application/vnd.sbm.mid2": {
			"source": "iana"
		},
		"application/vnd.scribus": {
			"source": "iana"
		},
		"application/vnd.sealed.3df": {
			"source": "iana"
		},
		"application/vnd.sealed.csf": {
			"source": "iana"
		},
		"application/vnd.sealed.doc": {
			"source": "iana"
		},
		"application/vnd.sealed.eml": {
			"source": "iana"
		},
		"application/vnd.sealed.mht": {
			"source": "iana"
		},
		"application/vnd.sealed.net": {
			"source": "iana"
		},
		"application/vnd.sealed.ppt": {
			"source": "iana"
		},
		"application/vnd.sealed.tiff": {
			"source": "iana"
		},
		"application/vnd.sealed.xls": {
			"source": "iana"
		},
		"application/vnd.sealedmedia.softseal.html": {
			"source": "iana"
		},
		"application/vnd.sealedmedia.softseal.pdf": {
			"source": "iana"
		},
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": [
				"see"
			]
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": [
				"sema"
			]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": [
				"semd"
			]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": [
				"semf"
			]
		},
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": [
				"ifm"
			]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": [
				"itp"
			]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": [
				"iif"
			]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": [
				"ipk"
			]
		},
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": [
				"twd",
				"twds"
			]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": [
				"mmf"
			]
		},
		"application/vnd.smart.notebook": {
			"source": "iana"
		},
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": [
				"teacher"
			]
		},
		"application/vnd.software602.filler.form+xml": {
			"source": "iana"
		},
		"application/vnd.software602.filler.form-xml-zip": {
			"source": "iana"
		},
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"extensions": [
				"sdkm",
				"sdkd"
			]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": [
				"dxp"
			]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": [
				"sfs"
			]
		},
		"application/vnd.sss-cod": {
			"source": "iana"
		},
		"application/vnd.sss-dtf": {
			"source": "iana"
		},
		"application/vnd.sss-ntf": {
			"source": "iana"
		},
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": [
				"sdc"
			]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": [
				"sda"
			]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": [
				"sdd"
			]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": [
				"smf"
			]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": [
				"sdw",
				"vor"
			]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": [
				"sgl"
			]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": [
				"smzip"
			]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": [
				"sm"
			]
		},
		"application/vnd.street-stream": {
			"source": "iana"
		},
		"application/vnd.sun.wadl+xml": {
			"source": "iana"
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": [
				"sxc"
			]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": [
				"stc"
			]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": [
				"sxd"
			]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": [
				"std"
			]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": [
				"sxi"
			]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": [
				"sti"
			]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": [
				"sxm"
			]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": [
				"sxw"
			]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": [
				"sxg"
			]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": [
				"stw"
			]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": [
				"sus",
				"susp"
			]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": [
				"svd"
			]
		},
		"application/vnd.swiftview-ics": {
			"source": "iana"
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": [
				"sis",
				"sisx"
			]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"extensions": [
				"xsm"
			]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"extensions": [
				"bdm"
			]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"extensions": [
				"xdm"
			]
		},
		"application/vnd.syncml.dm.notification": {
			"source": "iana"
		},
		"application/vnd.syncml.dmddf+wbxml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmtnds+wbxml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana"
		},
		"application/vnd.syncml.ds.notification": {
			"source": "iana"
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": [
				"tao"
			]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana"
		},
		"application/vnd.tml": {
			"source": "iana"
		},
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": [
				"tmo"
			]
		},
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": [
				"tpt"
			]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": [
				"mxs"
			]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": [
				"tra"
			]
		},
		"application/vnd.truedoc": {
			"source": "iana"
		},
		"application/vnd.ubisoft.webplayer": {
			"source": "iana"
		},
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": [
				"ufd",
				"ufdl"
			]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": [
				"utz"
			]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": [
				"umj"
			]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": [
				"unityweb"
			]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"extensions": [
				"uoml"
			]
		},
		"application/vnd.uplanet.alert": {
			"source": "iana"
		},
		"application/vnd.uplanet.alert-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.bearer-choice": {
			"source": "iana"
		},
		"application/vnd.uplanet.bearer-choice-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.cacheop": {
			"source": "iana"
		},
		"application/vnd.uplanet.cacheop-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.channel": {
			"source": "iana"
		},
		"application/vnd.uplanet.channel-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.list": {
			"source": "iana"
		},
		"application/vnd.uplanet.list-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.listcmd": {
			"source": "iana"
		},
		"application/vnd.uplanet.listcmd-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.signal": {
			"source": "iana"
		},
		"application/vnd.uri-map": {
			"source": "iana"
		},
		"application/vnd.valve.source.material": {
			"source": "iana"
		},
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": [
				"vcx"
			]
		},
		"application/vnd.vd-study": {
			"source": "iana"
		},
		"application/vnd.vectorworks": {
			"source": "iana"
		},
		"application/vnd.vel+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.verimatrix.vcas": {
			"source": "iana"
		},
		"application/vnd.vidsoft.vidconference": {
			"source": "iana"
		},
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": [
				"vis"
			]
		},
		"application/vnd.vividence.scriptfile": {
			"source": "iana"
		},
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": [
				"vsf"
			]
		},
		"application/vnd.wap.sic": {
			"source": "iana"
		},
		"application/vnd.wap.slc": {
			"source": "iana"
		},
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"extensions": [
				"wbxml"
			]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": [
				"wmlc"
			]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": [
				"wmlsc"
			]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": [
				"wtb"
			]
		},
		"application/vnd.wfa.p2p": {
			"source": "iana"
		},
		"application/vnd.wfa.wsc": {
			"source": "iana"
		},
		"application/vnd.windows.devicepairing": {
			"source": "iana"
		},
		"application/vnd.wmc": {
			"source": "iana"
		},
		"application/vnd.wmf.bootstrap": {
			"source": "iana"
		},
		"application/vnd.wolfram.mathematica": {
			"source": "iana"
		},
		"application/vnd.wolfram.mathematica.package": {
			"source": "iana"
		},
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": [
				"nbp"
			]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": [
				"wpd"
			]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": [
				"wqd"
			]
		},
		"application/vnd.wrq-hp3000-labelled": {
			"source": "iana"
		},
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": [
				"stf"
			]
		},
		"application/vnd.wv.csp+wbxml": {
			"source": "iana"
		},
		"application/vnd.wv.csp+xml": {
			"source": "iana"
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana"
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": [
				"xar"
			]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": [
				"xfdl"
			]
		},
		"application/vnd.xfdl.webform": {
			"source": "iana"
		},
		"application/vnd.xmi+xml": {
			"source": "iana"
		},
		"application/vnd.xmpie.cpkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.dpkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.plan": {
			"source": "iana"
		},
		"application/vnd.xmpie.ppkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.xlim": {
			"source": "iana"
		},
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": [
				"hvd"
			]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": [
				"hvs"
			]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": [
				"hvp"
			]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": [
				"osf"
			]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"extensions": [
				"osfpvg"
			]
		},
		"application/vnd.yamaha.remote-setup": {
			"source": "iana"
		},
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": [
				"saf"
			]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": [
				"spf"
			]
		},
		"application/vnd.yamaha.through-ngn": {
			"source": "iana"
		},
		"application/vnd.yamaha.tunnel-udpencap": {
			"source": "iana"
		},
		"application/vnd.yaoweme": {
			"source": "iana"
		},
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": [
				"cmp"
			]
		},
		"application/vnd.zul": {
			"source": "iana",
			"extensions": [
				"zir",
				"zirz"
			]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"extensions": [
				"zaz"
			]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"extensions": [
				"vxml"
			]
		},
		"application/vq-rtcpxr": {
			"source": "iana"
		},
		"application/watcherinfo+xml": {
			"source": "iana"
		},
		"application/whoispp-query": {
			"source": "iana"
		},
		"application/whoispp-response": {
			"source": "iana"
		},
		"application/widget": {
			"source": "iana",
			"extensions": [
				"wgt"
			]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": [
				"hlp"
			]
		},
		"application/wita": {
			"source": "iana"
		},
		"application/wordperfect5.1": {
			"source": "iana"
		},
		"application/wsdl+xml": {
			"source": "iana",
			"extensions": [
				"wsdl"
			]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"extensions": [
				"wspolicy"
			]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"7z"
			]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": [
				"abw"
			]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": [
				"ace"
			]
		},
		"application/x-amf": {
			"source": "apache"
		},
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": [
				"dmg"
			]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": [
				"aam"
			]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": [
				"aas"
			]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": [
				"bcpio"
			]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": [
				"bdoc"
			]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": [
				"torrent"
			]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": [
				"blb",
				"blorb"
			]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"bz"
			]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"bz2",
				"boz"
			]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": [
				"vcd"
			]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": [
				"cfs"
			]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": [
				"chat"
			]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": [
				"pgn"
			]
		},
		"application/x-chrome-extension": {
			"extensions": [
				"crx"
			]
		},
		"application/x-cocoa": {
			"source": "nginx",
			"extensions": [
				"cco"
			]
		},
		"application/x-compress": {
			"source": "apache"
		},
		"application/x-conference": {
			"source": "apache",
			"extensions": [
				"nsc"
			]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": [
				"cpio"
			]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": [
				"csh"
			]
		},
		"application/x-deb": {
			"compressible": false
		},
		"application/x-debian-package": {
			"source": "apache",
			"extensions": [
				"deb",
				"udeb"
			]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": [
				"dgc"
			]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": [
				"wad"
			]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"extensions": [
				"ncx"
			]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"extensions": [
				"dtb"
			]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"extensions": [
				"res"
			]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"dvi"
			]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": [
				"evy"
			]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": [
				"eva"
			]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": [
				"bdf"
			]
		},
		"application/x-font-dos": {
			"source": "apache"
		},
		"application/x-font-framemaker": {
			"source": "apache"
		},
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": [
				"gsf"
			]
		},
		"application/x-font-libgrx": {
			"source": "apache"
		},
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": [
				"psf"
			]
		},
		"application/x-font-otf": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"otf"
			]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": [
				"pcf"
			]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": [
				"snf"
			]
		},
		"application/x-font-speedo": {
			"source": "apache"
		},
		"application/x-font-sunos-news": {
			"source": "apache"
		},
		"application/x-font-ttf": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"ttf",
				"ttc"
			]
		},
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": {
			"source": "apache"
		},
		"application/x-freearc": {
			"source": "apache",
			"extensions": [
				"arc"
			]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": [
				"spl"
			]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": [
				"gca"
			]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": [
				"ulx"
			]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": [
				"gnumeric"
			]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": [
				"gramps"
			]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": [
				"gtar"
			]
		},
		"application/x-gzip": {
			"source": "apache"
		},
		"application/x-hdf": {
			"source": "apache",
			"extensions": [
				"hdf"
			]
		},
		"application/x-httpd-php": {
			"compressible": true,
			"extensions": [
				"php"
			]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": [
				"install"
			]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": [
				"iso"
			]
		},
		"application/x-java-archive-diff": {
			"source": "nginx",
			"extensions": [
				"jardiff"
			]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jnlp"
			]
		},
		"application/x-javascript": {
			"compressible": true
		},
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"latex"
			]
		},
		"application/x-lua-bytecode": {
			"extensions": [
				"luac"
			]
		},
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": [
				"lzh",
				"lha"
			]
		},
		"application/x-makeself": {
			"source": "nginx",
			"extensions": [
				"run"
			]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": [
				"mie"
			]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": [
				"prc",
				"mobi"
			]
		},
		"application/x-mpegurl": {
			"compressible": false
		},
		"application/x-ms-application": {
			"source": "apache",
			"extensions": [
				"application"
			]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": [
				"lnk"
			]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": [
				"wmd"
			]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": [
				"wmz"
			]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": [
				"xbap"
			]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": [
				"mdb"
			]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": [
				"obd"
			]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": [
				"crd"
			]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": [
				"clp"
			]
		},
		"application/x-msdos-program": {
			"extensions": [
				"exe"
			]
		},
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": [
				"mny"
			]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": [
				"pub"
			]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": [
				"scd"
			]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": [
				"trm"
			]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": [
				"wri"
			]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": [
				"nc",
				"cdf"
			]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": [
				"pac"
			]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": [
				"nzb"
			]
		},
		"application/x-perl": {
			"source": "nginx",
			"extensions": [
				"pl",
				"pm"
			]
		},
		"application/x-pilot": {
			"source": "nginx",
			"extensions": [
				"prc",
				"pdb"
			]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"p12",
				"pfx"
			]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": [
				"p7b",
				"spc"
			]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": [
				"p7r"
			]
		},
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"rar"
			]
		},
		"application/x-redhat-package-manager": {
			"source": "nginx",
			"extensions": [
				"rpm"
			]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": [
				"ris"
			]
		},
		"application/x-sea": {
			"source": "nginx",
			"extensions": [
				"sea"
			]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"sh"
			]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": [
				"shar"
			]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"swf"
			]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": [
				"xap"
			]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": [
				"sql"
			]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"sit"
			]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": [
				"sitx"
			]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": [
				"srt"
			]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": [
				"sv4cpio"
			]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": [
				"sv4crc"
			]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": [
				"t3"
			]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": [
				"gam"
			]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"tar"
			]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": [
				"tcl",
				"tk"
			]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": [
				"tex"
			]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": [
				"tfm"
			]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": [
				"texinfo",
				"texi"
			]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": [
				"obj"
			]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": [
				"ustar"
			]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": [
				"src"
			]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": [
				"webapp"
			]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "apache",
			"extensions": [
				"der",
				"crt",
				"pem"
			]
		},
		"application/x-xfig": {
			"source": "apache",
			"extensions": [
				"fig"
			]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"extensions": [
				"xlf"
			]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"xpi"
			]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": [
				"xz"
			]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": {
			"source": "iana"
		},
		"application/xacml+xml": {
			"source": "iana"
		},
		"application/xaml+xml": {
			"source": "apache",
			"extensions": [
				"xaml"
			]
		},
		"application/xcap-att+xml": {
			"source": "iana"
		},
		"application/xcap-caps+xml": {
			"source": "iana"
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"extensions": [
				"xdf"
			]
		},
		"application/xcap-el+xml": {
			"source": "iana"
		},
		"application/xcap-error+xml": {
			"source": "iana"
		},
		"application/xcap-ns+xml": {
			"source": "iana"
		},
		"application/xcon-conference-info+xml": {
			"source": "iana"
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana"
		},
		"application/xenc+xml": {
			"source": "iana",
			"extensions": [
				"xenc"
			]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xhtml",
				"xht"
			]
		},
		"application/xhtml-voice+xml": {
			"source": "apache"
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd",
				"rng"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"dtd"
			]
		},
		"application/xml-external-parsed-entity": {
			"source": "iana"
		},
		"application/xml-patch+xml": {
			"source": "iana"
		},
		"application/xmpp+xml": {
			"source": "iana"
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xop"
			]
		},
		"application/xproc+xml": {
			"source": "apache",
			"extensions": [
				"xpl"
			]
		},
		"application/xslt+xml": {
			"source": "iana",
			"extensions": [
				"xslt"
			]
		},
		"application/xspf+xml": {
			"source": "apache",
			"extensions": [
				"xspf"
			]
		},
		"application/xv+xml": {
			"source": "iana",
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": [
				"yang"
			]
		},
		"application/yin+xml": {
			"source": "iana",
			"extensions": [
				"yin"
			]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"zip"
			]
		},
		"application/zlib": {
			"source": "iana"
		},
		"audio/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"audio/32kadpcm": {
			"source": "iana"
		},
		"audio/3gpp": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"3gpp"
			]
		},
		"audio/3gpp2": {
			"source": "iana"
		},
		"audio/ac3": {
			"source": "iana"
		},
		"audio/adpcm": {
			"source": "apache",
			"extensions": [
				"adp"
			]
		},
		"audio/amr": {
			"source": "iana"
		},
		"audio/amr-wb": {
			"source": "iana"
		},
		"audio/amr-wb+": {
			"source": "iana"
		},
		"audio/aptx": {
			"source": "iana"
		},
		"audio/asc": {
			"source": "iana"
		},
		"audio/atrac-advanced-lossless": {
			"source": "iana"
		},
		"audio/atrac-x": {
			"source": "iana"
		},
		"audio/atrac3": {
			"source": "iana"
		},
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"au",
				"snd"
			]
		},
		"audio/bv16": {
			"source": "iana"
		},
		"audio/bv32": {
			"source": "iana"
		},
		"audio/clearmode": {
			"source": "iana"
		},
		"audio/cn": {
			"source": "iana"
		},
		"audio/dat12": {
			"source": "iana"
		},
		"audio/dls": {
			"source": "iana"
		},
		"audio/dsr-es201108": {
			"source": "iana"
		},
		"audio/dsr-es202050": {
			"source": "iana"
		},
		"audio/dsr-es202211": {
			"source": "iana"
		},
		"audio/dsr-es202212": {
			"source": "iana"
		},
		"audio/dv": {
			"source": "iana"
		},
		"audio/dvi4": {
			"source": "iana"
		},
		"audio/eac3": {
			"source": "iana"
		},
		"audio/encaprtp": {
			"source": "iana"
		},
		"audio/evrc": {
			"source": "iana"
		},
		"audio/evrc-qcp": {
			"source": "iana"
		},
		"audio/evrc0": {
			"source": "iana"
		},
		"audio/evrc1": {
			"source": "iana"
		},
		"audio/evrcb": {
			"source": "iana"
		},
		"audio/evrcb0": {
			"source": "iana"
		},
		"audio/evrcb1": {
			"source": "iana"
		},
		"audio/evrcnw": {
			"source": "iana"
		},
		"audio/evrcnw0": {
			"source": "iana"
		},
		"audio/evrcnw1": {
			"source": "iana"
		},
		"audio/evrcwb": {
			"source": "iana"
		},
		"audio/evrcwb0": {
			"source": "iana"
		},
		"audio/evrcwb1": {
			"source": "iana"
		},
		"audio/evs": {
			"source": "iana"
		},
		"audio/fwdred": {
			"source": "iana"
		},
		"audio/g711-0": {
			"source": "iana"
		},
		"audio/g719": {
			"source": "iana"
		},
		"audio/g722": {
			"source": "iana"
		},
		"audio/g7221": {
			"source": "iana"
		},
		"audio/g723": {
			"source": "iana"
		},
		"audio/g726-16": {
			"source": "iana"
		},
		"audio/g726-24": {
			"source": "iana"
		},
		"audio/g726-32": {
			"source": "iana"
		},
		"audio/g726-40": {
			"source": "iana"
		},
		"audio/g728": {
			"source": "iana"
		},
		"audio/g729": {
			"source": "iana"
		},
		"audio/g7291": {
			"source": "iana"
		},
		"audio/g729d": {
			"source": "iana"
		},
		"audio/g729e": {
			"source": "iana"
		},
		"audio/gsm": {
			"source": "iana"
		},
		"audio/gsm-efr": {
			"source": "iana"
		},
		"audio/gsm-hr-08": {
			"source": "iana"
		},
		"audio/ilbc": {
			"source": "iana"
		},
		"audio/ip-mr_v2.5": {
			"source": "iana"
		},
		"audio/isac": {
			"source": "apache"
		},
		"audio/l16": {
			"source": "iana"
		},
		"audio/l20": {
			"source": "iana"
		},
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": {
			"source": "iana"
		},
		"audio/lpc": {
			"source": "iana"
		},
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana"
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"m4a",
				"mp4a"
			]
		},
		"audio/mp4a-latm": {
			"source": "iana"
		},
		"audio/mpa": {
			"source": "iana"
		},
		"audio/mpa-robust": {
			"source": "iana"
		},
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": {
			"source": "iana"
		},
		"audio/musepack": {
			"source": "apache"
		},
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx"
			]
		},
		"audio/opus": {
			"source": "iana"
		},
		"audio/parityfec": {
			"source": "iana"
		},
		"audio/pcma": {
			"source": "iana"
		},
		"audio/pcma-wb": {
			"source": "iana"
		},
		"audio/pcmu": {
			"source": "iana"
		},
		"audio/pcmu-wb": {
			"source": "iana"
		},
		"audio/prs.sid": {
			"source": "iana"
		},
		"audio/qcelp": {
			"source": "iana"
		},
		"audio/raptorfec": {
			"source": "iana"
		},
		"audio/red": {
			"source": "iana"
		},
		"audio/rtp-enc-aescm128": {
			"source": "iana"
		},
		"audio/rtp-midi": {
			"source": "iana"
		},
		"audio/rtploopback": {
			"source": "iana"
		},
		"audio/rtx": {
			"source": "iana"
		},
		"audio/s3m": {
			"source": "apache",
			"extensions": [
				"s3m"
			]
		},
		"audio/silk": {
			"source": "apache",
			"extensions": [
				"sil"
			]
		},
		"audio/smv": {
			"source": "iana"
		},
		"audio/smv-qcp": {
			"source": "iana"
		},
		"audio/smv0": {
			"source": "iana"
		},
		"audio/sp-midi": {
			"source": "iana"
		},
		"audio/speex": {
			"source": "iana"
		},
		"audio/t140c": {
			"source": "iana"
		},
		"audio/t38": {
			"source": "iana"
		},
		"audio/telephone-event": {
			"source": "iana"
		},
		"audio/tone": {
			"source": "iana"
		},
		"audio/uemclip": {
			"source": "iana"
		},
		"audio/ulpfec": {
			"source": "iana"
		},
		"audio/vdvi": {
			"source": "iana"
		},
		"audio/vmr-wb": {
			"source": "iana"
		},
		"audio/vnd.3gpp.iufp": {
			"source": "iana"
		},
		"audio/vnd.4sb": {
			"source": "iana"
		},
		"audio/vnd.audiokoz": {
			"source": "iana"
		},
		"audio/vnd.celp": {
			"source": "iana"
		},
		"audio/vnd.cisco.nse": {
			"source": "iana"
		},
		"audio/vnd.cmles.radio-events": {
			"source": "iana"
		},
		"audio/vnd.cns.anp1": {
			"source": "iana"
		},
		"audio/vnd.cns.inf1": {
			"source": "iana"
		},
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": [
				"uva",
				"uvva"
			]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": [
				"eol"
			]
		},
		"audio/vnd.dlna.adts": {
			"source": "iana"
		},
		"audio/vnd.dolby.heaac.1": {
			"source": "iana"
		},
		"audio/vnd.dolby.heaac.2": {
			"source": "iana"
		},
		"audio/vnd.dolby.mlp": {
			"source": "iana"
		},
		"audio/vnd.dolby.mps": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2x": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2z": {
			"source": "iana"
		},
		"audio/vnd.dolby.pulse.1": {
			"source": "iana"
		},
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": [
				"dra"
			]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": [
				"dts"
			]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": [
				"dtshd"
			]
		},
		"audio/vnd.dvb.file": {
			"source": "iana"
		},
		"audio/vnd.everad.plj": {
			"source": "iana"
		},
		"audio/vnd.hns.audio": {
			"source": "iana"
		},
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": [
				"lvp"
			]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": [
				"pya"
			]
		},
		"audio/vnd.nokia.mobile-xmf": {
			"source": "iana"
		},
		"audio/vnd.nortel.vbk": {
			"source": "iana"
		},
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": [
				"ecelp4800"
			]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": [
				"ecelp7470"
			]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": [
				"ecelp9600"
			]
		},
		"audio/vnd.octel.sbc": {
			"source": "iana"
		},
		"audio/vnd.qcelp": {
			"source": "iana"
		},
		"audio/vnd.rhetorex.32kadpcm": {
			"source": "iana"
		},
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": [
				"rip"
			]
		},
		"audio/vnd.rn-realaudio": {
			"compressible": false
		},
		"audio/vnd.sealedmedia.softseal.mpeg": {
			"source": "iana"
		},
		"audio/vnd.vmx.cvsd": {
			"source": "iana"
		},
		"audio/vnd.wave": {
			"compressible": false
		},
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": {
			"source": "iana"
		},
		"audio/wav": {
			"compressible": false,
			"extensions": [
				"wav"
			]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": [
				"wav"
			]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"weba"
			]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"aac"
			]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"caf"
			]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": [
				"flac"
			]
		},
		"audio/x-m4a": {
			"source": "nginx",
			"extensions": [
				"m4a"
			]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": [
				"mka"
			]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": [
				"m3u"
			]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": [
				"wax"
			]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": [
				"wma"
			]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": [
				"ram",
				"ra"
			]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": [
				"rmp"
			]
		},
		"audio/x-realaudio": {
			"source": "nginx",
			"extensions": [
				"ra"
			]
		},
		"audio/x-tta": {
			"source": "apache"
		},
		"audio/x-wav": {
			"source": "apache",
			"extensions": [
				"wav"
			]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": [
				"xm"
			]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": [
				"cdx"
			]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": [
				"cif"
			]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": [
				"cmdf"
			]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": [
				"cml"
			]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": [
				"csml"
			]
		},
		"chemical/x-pdb": {
			"source": "apache"
		},
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": [
				"xyz"
			]
		},
		"font/opentype": {
			"compressible": true,
			"extensions": [
				"otf"
			]
		},
		"image/bmp": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"bmp"
			]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": [
				"cgm"
			]
		},
		"image/fits": {
			"source": "iana"
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": [
				"g3"
			]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"gif"
			]
		},
		"image/ief": {
			"source": "iana",
			"extensions": [
				"ief"
			]
		},
		"image/jp2": {
			"source": "iana"
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jpm": {
			"source": "iana"
		},
		"image/jpx": {
			"source": "iana"
		},
		"image/ktx": {
			"source": "iana",
			"extensions": [
				"ktx"
			]
		},
		"image/naplps": {
			"source": "iana"
		},
		"image/pjpeg": {
			"compressible": false
		},
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"png"
			]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": [
				"btif"
			]
		},
		"image/prs.pti": {
			"source": "iana"
		},
		"image/pwg-raster": {
			"source": "iana"
		},
		"image/sgi": {
			"source": "apache",
			"extensions": [
				"sgi"
			]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"svg",
				"svgz"
			]
		},
		"image/t38": {
			"source": "iana"
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"tiff",
				"tif"
			]
		},
		"image/tiff-fx": {
			"source": "iana"
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"psd"
			]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana"
		},
		"image/vnd.cns.inf2": {
			"source": "iana"
		},
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": [
				"djvu",
				"djv"
			]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": [
				"sub"
			]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": [
				"dwg"
			]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": [
				"dxf"
			]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": [
				"fbs"
			]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": [
				"fpx"
			]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": [
				"fst"
			]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": [
				"mmr"
			]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": [
				"rlc"
			]
		},
		"image/vnd.globalgraphics.pgb": {
			"source": "iana"
		},
		"image/vnd.microsoft.icon": {
			"source": "iana"
		},
		"image/vnd.mix": {
			"source": "iana"
		},
		"image/vnd.mozilla.apng": {
			"source": "iana"
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": [
				"mdi"
			]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": [
				"wdp"
			]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": [
				"npx"
			]
		},
		"image/vnd.radiance": {
			"source": "iana"
		},
		"image/vnd.sealed.png": {
			"source": "iana"
		},
		"image/vnd.sealedmedia.softseal.gif": {
			"source": "iana"
		},
		"image/vnd.sealedmedia.softseal.jpg": {
			"source": "iana"
		},
		"image/vnd.svf": {
			"source": "iana"
		},
		"image/vnd.tencent.tap": {
			"source": "iana"
		},
		"image/vnd.valve.source.texture": {
			"source": "iana"
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": [
				"wbmp"
			]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": [
				"xif"
			]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana"
		},
		"image/webp": {
			"source": "apache",
			"extensions": [
				"webp"
			]
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": [
				"3ds"
			]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": [
				"ras"
			]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": [
				"cmx"
			]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"ico"
			]
		},
		"image/x-jng": {
			"source": "nginx",
			"extensions": [
				"jng"
			]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": [
				"sid"
			]
		},
		"image/x-ms-bmp": {
			"source": "nginx",
			"compressible": true,
			"extensions": [
				"bmp"
			]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": [
				"pcx"
			]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": [
				"pic",
				"pct"
			]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": [
				"pnm"
			]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": [
				"pbm"
			]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": [
				"pgm"
			]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": [
				"ppm"
			]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": [
				"rgb"
			]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": [
				"tga"
			]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": [
				"xbm"
			]
		},
		"image/x-xcf": {
			"compressible": false
		},
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": [
				"xpm"
			]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": [
				"xwd"
			]
		},
		"message/cpim": {
			"source": "iana"
		},
		"message/delivery-status": {
			"source": "iana"
		},
		"message/disposition-notification": {
			"source": "iana"
		},
		"message/external-body": {
			"source": "iana"
		},
		"message/feedback-report": {
			"source": "iana"
		},
		"message/global": {
			"source": "iana"
		},
		"message/global-delivery-status": {
			"source": "iana"
		},
		"message/global-disposition-notification": {
			"source": "iana"
		},
		"message/global-headers": {
			"source": "iana"
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": {
			"source": "iana"
		},
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"eml",
				"mime"
			]
		},
		"message/s-http": {
			"source": "iana"
		},
		"message/sip": {
			"source": "iana"
		},
		"message/sipfrag": {
			"source": "iana"
		},
		"message/tracking-status": {
			"source": "iana"
		},
		"message/vnd.si.simp": {
			"source": "iana"
		},
		"message/vnd.wfa.wsc": {
			"source": "iana"
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"igs",
				"iges"
			]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"extensions": [
				"dae"
			]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": [
				"dwf"
			]
		},
		"model/vnd.flatland.3dml": {
			"source": "iana"
		},
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": [
				"gdl"
			]
		},
		"model/vnd.gs-gdl": {
			"source": "apache"
		},
		"model/vnd.gs.gdl": {
			"source": "iana"
		},
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": [
				"gtw"
			]
		},
		"model/vnd.moml+xml": {
			"source": "iana"
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": [
				"mts"
			]
		},
		"model/vnd.opengex": {
			"source": "iana"
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana"
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana"
		},
		"model/vnd.rosette.annotated-data-model": {
			"source": "iana"
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana"
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": [
				"vtu"
			]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"wrl",
				"vrml"
			]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"x3db",
				"x3dbz"
			]
		},
		"model/x3d+fastinfoset": {
			"source": "iana"
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"x3dv",
				"x3dvz"
			]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"x3d",
				"x3dz"
			]
		},
		"model/x3d-vrml": {
			"source": "iana"
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": {
			"source": "iana"
		},
		"multipart/byteranges": {
			"source": "iana"
		},
		"multipart/digest": {
			"source": "iana"
		},
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": {
			"source": "iana"
		},
		"multipart/mixed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/parallel": {
			"source": "iana"
		},
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": {
			"source": "iana"
		},
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/voice-message": {
			"source": "iana"
		},
		"multipart/x-mixed-replace": {
			"source": "iana"
		},
		"text/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"appcache",
				"manifest"
			]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": [
				"ics",
				"ifb"
			]
		},
		"text/calender": {
			"compressible": true
		},
		"text/cmd": {
			"compressible": true
		},
		"text/coffeescript": {
			"extensions": [
				"coffee",
				"litcoffee"
			]
		},
		"text/css": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"css"
			]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"csv"
			]
		},
		"text/csv-schema": {
			"source": "iana"
		},
		"text/directory": {
			"source": "iana"
		},
		"text/dns": {
			"source": "iana"
		},
		"text/ecmascript": {
			"source": "iana"
		},
		"text/encaprtp": {
			"source": "iana"
		},
		"text/enriched": {
			"source": "iana"
		},
		"text/fwdred": {
			"source": "iana"
		},
		"text/grammar-ref-list": {
			"source": "iana"
		},
		"text/hjson": {
			"extensions": [
				"hjson"
			]
		},
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm",
				"shtml"
			]
		},
		"text/jade": {
			"extensions": [
				"jade"
			]
		},
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": {
			"source": "iana"
		},
		"text/jsx": {
			"compressible": true,
			"extensions": [
				"jsx"
			]
		},
		"text/less": {
			"extensions": [
				"less"
			]
		},
		"text/markdown": {
			"source": "iana"
		},
		"text/mathml": {
			"source": "nginx",
			"extensions": [
				"mml"
			]
		},
		"text/mizar": {
			"source": "iana"
		},
		"text/n3": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"n3"
			]
		},
		"text/parameters": {
			"source": "iana"
		},
		"text/parityfec": {
			"source": "iana"
		},
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana"
		},
		"text/prs.fallenstein.rst": {
			"source": "iana"
		},
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": [
				"dsc"
			]
		},
		"text/prs.prop.logic": {
			"source": "iana"
		},
		"text/raptorfec": {
			"source": "iana"
		},
		"text/red": {
			"source": "iana"
		},
		"text/rfc822-headers": {
			"source": "iana"
		},
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtx"
			]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtf"
			]
		},
		"text/rtp-enc-aescm128": {
			"source": "iana"
		},
		"text/rtploopback": {
			"source": "iana"
		},
		"text/rtx": {
			"source": "iana"
		},
		"text/sgml": {
			"source": "iana",
			"extensions": [
				"sgml",
				"sgm"
			]
		},
		"text/slim": {
			"extensions": [
				"slim",
				"slm"
			]
		},
		"text/stylus": {
			"extensions": [
				"stylus",
				"styl"
			]
		},
		"text/t140": {
			"source": "iana"
		},
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"tsv"
			]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"extensions": [
				"ttl"
			]
		},
		"text/ulpfec": {
			"source": "iana"
		},
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"vcard"
			]
		},
		"text/vnd.a": {
			"source": "iana"
		},
		"text/vnd.abc": {
			"source": "iana"
		},
		"text/vnd.curl": {
			"source": "iana",
			"extensions": [
				"curl"
			]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": [
				"dcurl"
			]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": [
				"mcurl"
			]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": [
				"scurl"
			]
		},
		"text/vnd.debian.copyright": {
			"source": "iana"
		},
		"text/vnd.dmclientscript": {
			"source": "iana"
		},
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": [
				"sub"
			]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana"
		},
		"text/vnd.fly": {
			"source": "iana",
			"extensions": [
				"fly"
			]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": [
				"flx"
			]
		},
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": [
				"gv"
			]
		},
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": [
				"3dml"
			]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": [
				"spot"
			]
		},
		"text/vnd.iptc.newsml": {
			"source": "iana"
		},
		"text/vnd.iptc.nitf": {
			"source": "iana"
		},
		"text/vnd.latex-z": {
			"source": "iana"
		},
		"text/vnd.motorola.reflex": {
			"source": "iana"
		},
		"text/vnd.ms-mediapackage": {
			"source": "iana"
		},
		"text/vnd.net2phone.commcenter.command": {
			"source": "iana"
		},
		"text/vnd.radisys.msml-basic-layout": {
			"source": "iana"
		},
		"text/vnd.si.uricatalogue": {
			"source": "iana"
		},
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"extensions": [
				"jad"
			]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana"
		},
		"text/vnd.wap.si": {
			"source": "iana"
		},
		"text/vnd.wap.sl": {
			"source": "iana"
		},
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": [
				"wml"
			]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": [
				"wmls"
			]
		},
		"text/vtt": {
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"vtt"
			]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": [
				"s",
				"asm"
			]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"source": "nginx",
			"extensions": [
				"htc"
			]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": {
			"compressible": true
		},
		"text/x-handlebars-template": {
			"extensions": [
				"hbs"
			]
		},
		"text/x-java-source": {
			"source": "apache",
			"extensions": [
				"java"
			]
		},
		"text/x-jquery-tmpl": {
			"compressible": true
		},
		"text/x-lua": {
			"extensions": [
				"lua"
			]
		},
		"text/x-markdown": {
			"compressible": true,
			"extensions": [
				"markdown",
				"md",
				"mkd"
			]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": [
				"nfo"
			]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": [
				"opml"
			]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": [
				"p",
				"pas"
			]
		},
		"text/x-processing": {
			"compressible": true,
			"extensions": [
				"pde"
			]
		},
		"text/x-sass": {
			"extensions": [
				"sass"
			]
		},
		"text/x-scss": {
			"extensions": [
				"scss"
			]
		},
		"text/x-setext": {
			"source": "apache",
			"extensions": [
				"etx"
			]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": [
				"sfv"
			]
		},
		"text/x-suse-ymp": {
			"compressible": true,
			"extensions": [
				"ymp"
			]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": [
				"uu"
			]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": [
				"vcs"
			]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": [
				"vcf"
			]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml"
			]
		},
		"text/xml-external-parsed-entity": {
			"source": "iana"
		},
		"text/yaml": {
			"extensions": [
				"yaml",
				"yml"
			]
		},
		"video/1d-interleaved-parityfec": {
			"source": "apache"
		},
		"video/3gpp": {
			"source": "apache",
			"extensions": [
				"3gp",
				"3gpp"
			]
		},
		"video/3gpp-tt": {
			"source": "apache"
		},
		"video/3gpp2": {
			"source": "apache",
			"extensions": [
				"3g2"
			]
		},
		"video/bmpeg": {
			"source": "apache"
		},
		"video/bt656": {
			"source": "apache"
		},
		"video/celb": {
			"source": "apache"
		},
		"video/dv": {
			"source": "apache"
		},
		"video/encaprtp": {
			"source": "apache"
		},
		"video/h261": {
			"source": "apache",
			"extensions": [
				"h261"
			]
		},
		"video/h263": {
			"source": "apache",
			"extensions": [
				"h263"
			]
		},
		"video/h263-1998": {
			"source": "apache"
		},
		"video/h263-2000": {
			"source": "apache"
		},
		"video/h264": {
			"source": "apache",
			"extensions": [
				"h264"
			]
		},
		"video/h264-rcdo": {
			"source": "apache"
		},
		"video/h264-svc": {
			"source": "apache"
		},
		"video/h265": {
			"source": "apache"
		},
		"video/iso.segment": {
			"source": "apache"
		},
		"video/jpeg": {
			"source": "apache",
			"extensions": [
				"jpgv"
			]
		},
		"video/jpeg2000": {
			"source": "apache"
		},
		"video/jpm": {
			"source": "apache",
			"extensions": [
				"jpm",
				"jpgm"
			]
		},
		"video/mj2": {
			"source": "apache",
			"extensions": [
				"mj2",
				"mjp2"
			]
		},
		"video/mp1s": {
			"source": "apache"
		},
		"video/mp2p": {
			"source": "apache"
		},
		"video/mp2t": {
			"source": "apache",
			"extensions": [
				"ts"
			]
		},
		"video/mp4": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": {
			"source": "apache"
		},
		"video/mpeg": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": {
			"source": "apache"
		},
		"video/mpv": {
			"source": "apache"
		},
		"video/nv": {
			"source": "apache"
		},
		"video/ogg": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"ogv"
			]
		},
		"video/parityfec": {
			"source": "apache"
		},
		"video/pointer": {
			"source": "apache"
		},
		"video/quicktime": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"qt",
				"mov"
			]
		},
		"video/raptorfec": {
			"source": "apache"
		},
		"video/raw": {
			"source": "apache"
		},
		"video/rtp-enc-aescm128": {
			"source": "apache"
		},
		"video/rtploopback": {
			"source": "apache"
		},
		"video/rtx": {
			"source": "apache"
		},
		"video/smpte292m": {
			"source": "apache"
		},
		"video/ulpfec": {
			"source": "apache"
		},
		"video/vc1": {
			"source": "apache"
		},
		"video/vnd.cctv": {
			"source": "apache"
		},
		"video/vnd.dece.hd": {
			"source": "apache",
			"extensions": [
				"uvh",
				"uvvh"
			]
		},
		"video/vnd.dece.mobile": {
			"source": "apache",
			"extensions": [
				"uvm",
				"uvvm"
			]
		},
		"video/vnd.dece.mp4": {
			"source": "apache"
		},
		"video/vnd.dece.pd": {
			"source": "apache",
			"extensions": [
				"uvp",
				"uvvp"
			]
		},
		"video/vnd.dece.sd": {
			"source": "apache",
			"extensions": [
				"uvs",
				"uvvs"
			]
		},
		"video/vnd.dece.video": {
			"source": "apache",
			"extensions": [
				"uvv",
				"uvvv"
			]
		},
		"video/vnd.directv.mpeg": {
			"source": "apache"
		},
		"video/vnd.directv.mpeg-tts": {
			"source": "apache"
		},
		"video/vnd.dlna.mpeg-tts": {
			"source": "apache"
		},
		"video/vnd.dvb.file": {
			"source": "apache",
			"extensions": [
				"dvb"
			]
		},
		"video/vnd.fvt": {
			"source": "apache",
			"extensions": [
				"fvt"
			]
		},
		"video/vnd.hns.video": {
			"source": "apache"
		},
		"video/vnd.iptvforum.1dparityfec-1010": {
			"source": "apache"
		},
		"video/vnd.iptvforum.1dparityfec-2005": {
			"source": "apache"
		},
		"video/vnd.iptvforum.2dparityfec-1010": {
			"source": "apache"
		},
		"video/vnd.iptvforum.2dparityfec-2005": {
			"source": "apache"
		},
		"video/vnd.iptvforum.ttsavc": {
			"source": "apache"
		},
		"video/vnd.iptvforum.ttsmpeg2": {
			"source": "apache"
		},
		"video/vnd.motorola.video": {
			"source": "apache"
		},
		"video/vnd.motorola.videop": {
			"source": "apache"
		},
		"video/vnd.mpegurl": {
			"source": "apache",
			"extensions": [
				"mxu",
				"m4u"
			]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "apache",
			"extensions": [
				"pyv"
			]
		},
		"video/vnd.nokia.interleaved-multimedia": {
			"source": "apache"
		},
		"video/vnd.nokia.videovoip": {
			"source": "apache"
		},
		"video/vnd.objectvideo": {
			"source": "apache"
		},
		"video/vnd.radgamettools.bink": {
			"source": "apache"
		},
		"video/vnd.radgamettools.smacker": {
			"source": "apache"
		},
		"video/vnd.sealed.mpeg1": {
			"source": "apache"
		},
		"video/vnd.sealed.mpeg4": {
			"source": "apache"
		},
		"video/vnd.sealed.swf": {
			"source": "apache"
		},
		"video/vnd.sealedmedia.softseal.mov": {
			"source": "apache"
		},
		"video/vnd.uvvu.mp4": {
			"source": "apache",
			"extensions": [
				"uvu",
				"uvvu"
			]
		},
		"video/vnd.vivo": {
			"source": "apache",
			"extensions": [
				"viv"
			]
		},
		"video/vp8": {
			"source": "apache"
		},
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"webm"
			]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": [
				"f4v"
			]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": [
				"fli"
			]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"flv"
			]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": [
				"m4v"
			]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": [
				"mng"
			]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": [
				"asf",
				"asx"
			]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": [
				"vob"
			]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": [
				"wm"
			]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"wmv"
			]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": [
				"wmx"
			]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": [
				"wvx"
			]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": [
				"avi"
			]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": [
				"movie"
			]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": [
				"smv"
			]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": [
				"ice"
			]
		},
		"x-shader/x-fragment": {
			"compressible": true
		},
		"x-shader/x-vertex": {
			"compressible": true
		}
	};

/***/ },
/* 681 */
/*!****************************************!*\
  !*** ./~/stringstream/stringstream.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(/*! util */ 597)
	var Stream = __webpack_require__(/*! stream */ 604)
	var StringDecoder = __webpack_require__(/*! string_decoder */ 682).StringDecoder
	
	module.exports = StringStream
	module.exports.AlignedStringDecoder = AlignedStringDecoder
	
	function StringStream(from, to) {
	  if (!(this instanceof StringStream)) return new StringStream(from, to)
	
	  Stream.call(this)
	
	  if (from == null) from = 'utf8'
	
	  this.readable = this.writable = true
	  this.paused = false
	  this.toEncoding = (to == null ? from : to)
	  this.fromEncoding = (to == null ? '' : from)
	  this.decoder = new AlignedStringDecoder(this.toEncoding)
	}
	util.inherits(StringStream, Stream)
	
	StringStream.prototype.write = function(data) {
	  if (!this.writable) {
	    var err = new Error('stream not writable')
	    err.code = 'EPIPE'
	    this.emit('error', err)
	    return false
	  }
	  if (this.fromEncoding) {
	    if (Buffer.isBuffer(data)) data = data.toString()
	    data = new Buffer(data, this.fromEncoding)
	  }
	  var string = this.decoder.write(data)
	  if (string.length) this.emit('data', string)
	  return !this.paused
	}
	
	StringStream.prototype.flush = function() {
	  if (this.decoder.flush) {
	    var string = this.decoder.flush()
	    if (string.length) this.emit('data', string)
	  }
	}
	
	StringStream.prototype.end = function() {
	  if (!this.writable && !this.readable) return
	  this.flush()
	  this.emit('end')
	  this.writable = this.readable = false
	  this.destroy()
	}
	
	StringStream.prototype.destroy = function() {
	  this.decoder = null
	  this.writable = this.readable = false
	  this.emit('close')
	}
	
	StringStream.prototype.pause = function() {
	  this.paused = true
	}
	
	StringStream.prototype.resume = function () {
	  if (this.paused) this.emit('drain')
	  this.paused = false
	}
	
	function AlignedStringDecoder(encoding) {
	  StringDecoder.call(this, encoding)
	
	  switch (this.encoding) {
	    case 'base64':
	      this.write = alignedWrite
	      this.alignedBuffer = new Buffer(3)
	      this.alignedBytes = 0
	      break
	  }
	}
	util.inherits(AlignedStringDecoder, StringDecoder)
	
	AlignedStringDecoder.prototype.flush = function() {
	  if (!this.alignedBuffer || !this.alignedBytes) return ''
	  var leftover = this.alignedBuffer.toString(this.encoding, 0, this.alignedBytes)
	  this.alignedBytes = 0
	  return leftover
	}
	
	function alignedWrite(buffer) {
	  var rem = (this.alignedBytes + buffer.length) % this.alignedBuffer.length
	  if (!rem && !this.alignedBytes) return buffer.toString(this.encoding)
	
	  var returnBuffer = new Buffer(this.alignedBytes + buffer.length - rem)
	
	  this.alignedBuffer.copy(returnBuffer, 0, 0, this.alignedBytes)
	  buffer.copy(returnBuffer, this.alignedBytes, 0, buffer.length - rem)
	
	  buffer.copy(this.alignedBuffer, 0, buffer.length - rem, buffer.length)
	  this.alignedBytes = rem
	
	  return returnBuffer.toString(this.encoding)
	}


/***/ },
/* 682 */
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ function(module, exports) {

	module.exports = require("string_decoder");

/***/ },
/* 683 */
/*!*****************************!*\
  !*** ./~/caseless/index.js ***!
  \*****************************/
/***/ function(module, exports) {

	function Caseless (dict) {
	  this.dict = dict || {}
	}
	Caseless.prototype.set = function (name, value, clobber) {
	  if (typeof name === 'object') {
	    for (var i in name) {
	      this.set(i, name[i], value)
	    }
	  } else {
	    if (typeof clobber === 'undefined') clobber = true
	    var has = this.has(name)
	
	    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value
	    else this.dict[has || name] = value
	    return has
	  }
	}
	Caseless.prototype.has = function (name) {
	  var keys = Object.keys(this.dict)
	    , name = name.toLowerCase()
	    ;
	  for (var i=0;i<keys.length;i++) {
	    if (keys[i].toLowerCase() === name) return keys[i]
	  }
	  return false
	}
	Caseless.prototype.get = function (name) {
	  name = name.toLowerCase()
	  var result, _key
	  var headers = this.dict
	  Object.keys(headers).forEach(function (key) {
	    _key = key.toLowerCase()
	    if (name === _key) result = headers[key]
	  })
	  return result
	}
	Caseless.prototype.swap = function (name) {
	  var has = this.has(name)
	  if (!has) throw new Error('There is no header than matches "'+name+'"')
	  this.dict[name] = this.dict[has]
	  delete this.dict[has]
	}
	Caseless.prototype.del = function (name) {
	  var has = this.has(name)
	  return delete this.dict[has || name]
	}
	
	module.exports = function (dict) {return new Caseless(dict)}
	module.exports.httpify = function (resp, headers) {
	  var c = new Caseless(headers)
	  resp.setHeader = function (key, value, clobber) {
	    if (typeof value === 'undefined') return
	    return c.set(key, value, clobber)
	  }
	  resp.hasHeader = function (key) {
	    return c.has(key)
	  }
	  resp.getHeader = function (key) {
	    return c.get(key)
	  }
	  resp.removeHeader = function (key) {
	    return c.del(key)
	  }
	  resp.headers = c.dict
	  return c
	}


/***/ },
/* 684 */
/*!**********************************!*\
  !*** ./~/forever-agent/index.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = ForeverAgent
	ForeverAgent.SSL = ForeverAgentSSL
	
	var util = __webpack_require__(/*! util */ 597)
	  , Agent = __webpack_require__(/*! http */ 533).Agent
	  , net = __webpack_require__(/*! net */ 590)
	  , tls = __webpack_require__(/*! tls */ 685)
	  , AgentSSL = __webpack_require__(/*! https */ 603).Agent
	  
	function getConnectionName(host, port) {  
	  var name = ''
	  if (typeof host === 'string') {
	    name = host + ':' + port
	  } else {
	    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
	    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')
	  }
	  return name
	}    
	
	function ForeverAgent(options) {
	  var self = this
	  self.options = options || {}
	  self.requests = {}
	  self.sockets = {}
	  self.freeSockets = {}
	  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
	  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
	  self.on('free', function(socket, host, port) {
	    var name = getConnectionName(host, port)
	
	    if (self.requests[name] && self.requests[name].length) {
	      self.requests[name].shift().onSocket(socket)
	    } else if (self.sockets[name].length < self.minSockets) {
	      if (!self.freeSockets[name]) self.freeSockets[name] = []
	      self.freeSockets[name].push(socket)
	      
	      // if an error happens while we don't use the socket anyway, meh, throw the socket away
	      var onIdleError = function() {
	        socket.destroy()
	      }
	      socket._onIdleError = onIdleError
	      socket.on('error', onIdleError)
	    } else {
	      // If there are no pending requests just destroy the
	      // socket and it will get removed from the pool. This
	      // gets us out of timeout issues and allows us to
	      // default to Connection:keep-alive.
	      socket.destroy()
	    }
	  })
	
	}
	util.inherits(ForeverAgent, Agent)
	
	ForeverAgent.defaultMinSockets = 5
	
	
	ForeverAgent.prototype.createConnection = net.createConnection
	ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
	ForeverAgent.prototype.addRequest = function(req, host, port) {
	  var name = getConnectionName(host, port)
	  
	  if (typeof host !== 'string') {
	    var options = host
	    port = options.port
	    host = options.host
	  }
	
	  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
	    var idleSocket = this.freeSockets[name].pop()
	    idleSocket.removeListener('error', idleSocket._onIdleError)
	    delete idleSocket._onIdleError
	    req._reusedSocket = true
	    req.onSocket(idleSocket)
	  } else {
	    this.addRequestNoreuse(req, host, port)
	  }
	}
	
	ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
	  if (this.sockets[name]) {
	    var index = this.sockets[name].indexOf(s)
	    if (index !== -1) {
	      this.sockets[name].splice(index, 1)
	    }
	  } else if (this.sockets[name] && this.sockets[name].length === 0) {
	    // don't leak
	    delete this.sockets[name]
	    delete this.requests[name]
	  }
	  
	  if (this.freeSockets[name]) {
	    var index = this.freeSockets[name].indexOf(s)
	    if (index !== -1) {
	      this.freeSockets[name].splice(index, 1)
	      if (this.freeSockets[name].length === 0) {
	        delete this.freeSockets[name]
	      }
	    }
	  }
	
	  if (this.requests[name] && this.requests[name].length) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createSocket(name, host, port).emit('free')
	  }
	}
	
	function ForeverAgentSSL (options) {
	  ForeverAgent.call(this, options)
	}
	util.inherits(ForeverAgentSSL, ForeverAgent)
	
	ForeverAgentSSL.prototype.createConnection = createConnectionSSL
	ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest
	
	function createConnectionSSL (port, host, options) {
	  if (typeof port === 'object') {
	    options = port;
	  } else if (typeof host === 'object') {
	    options = host;
	  } else if (typeof options === 'object') {
	    options = options;
	  } else {
	    options = {};
	  }
	
	  if (typeof port === 'number') {
	    options.port = port;
	  }
	
	  if (typeof host === 'string') {
	    options.host = host;
	  }
	
	  return tls.connect(options);
	}


/***/ },
/* 685 */
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ function(module, exports) {

	module.exports = require("tls");

/***/ },
/* 686 */
/*!**************************************!*\
  !*** ./~/form-data/lib/form_data.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var CombinedStream = __webpack_require__(/*! combined-stream */ 687);
	var util = __webpack_require__(/*! util */ 597);
	var path = __webpack_require__(/*! path */ 521);
	var http = __webpack_require__(/*! http */ 533);
	var https = __webpack_require__(/*! https */ 603);
	var parseUrl = __webpack_require__(/*! url */ 534).parse;
	var fs = __webpack_require__(/*! fs */ 531);
	var mime = __webpack_require__(/*! mime-types */ 678);
	var async = __webpack_require__(/*! async */ 689);
	var populate = __webpack_require__(/*! ./populate.js */ 690);
	
	// Public API
	module.exports = FormData;
	
	// make it a Stream
	util.inherits(FormData, CombinedStream);
	
	/**
	 * Create readable "multipart/form-data" streams.
	 * Can be used to submit forms
	 * and file uploads to other web applications.
	 *
	 * @constructor
	 */
	function FormData() {
	  if (!(this instanceof FormData)) {
	    throw new TypeError('Failed to construct FormData: Please use the _new_ operator, this object constructor cannot be called as a function.');
	  }
	
	  this._overheadLength = 0;
	  this._valueLength = 0;
	  this._lengthRetrievers = [];
	
	  CombinedStream.call(this);
	}
	
	FormData.LINE_BREAK = '\r\n';
	FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
	
	FormData.prototype.append = function(field, value, options) {
	
	  options = options || {};
	
	  // allow filename as single option
	  if (typeof options == 'string') {
	    options = {filename: options};
	  }
	
	  var append = CombinedStream.prototype.append.bind(this);
	
	  // all that streamy business can't handle numbers
	  if (typeof value == 'number') {
	    value = '' + value;
	  }
	
	  // https://github.com/felixge/node-form-data/issues/38
	  if (util.isArray(value)) {
	    // Please convert your array into string
	    // the way web server expects it
	    this._error(new Error('Arrays are not supported.'));
	    return;
	  }
	
	  var header = this._multiPartHeader(field, value, options);
	  var footer = this._multiPartFooter();
	
	  append(header);
	  append(value);
	  append(footer);
	
	  // pass along options.knownLength
	  this._trackLength(header, value, options);
	};
	
	FormData.prototype._trackLength = function(header, value, options) {
	  var valueLength = 0;
	
	  // used w/ getLengthSync(), when length is known.
	  // e.g. for streaming directly from a remote server,
	  // w/ a known file a size, and not wanting to wait for
	  // incoming file to finish to get its size.
	  if (options.knownLength != null) {
	    valueLength += +options.knownLength;
	  } else if (Buffer.isBuffer(value)) {
	    valueLength = value.length;
	  } else if (typeof value === 'string') {
	    valueLength = Buffer.byteLength(value);
	  }
	
	  this._valueLength += valueLength;
	
	  // @check why add CRLF? does this account for custom/multiple CRLFs?
	  this._overheadLength +=
	    Buffer.byteLength(header) +
	    FormData.LINE_BREAK.length;
	
	  // empty or either doesn't have path or not an http response
	  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
	    return;
	  }
	
	  // no need to bother with the length
	  if (!options.knownLength) {
	    this._lengthRetrievers.push(function(next) {
	
	      if (value.hasOwnProperty('fd')) {
	
	        // take read range into a account
	        // `end` = Infinity –> read file till the end
	        //
	        // TODO: Looks like there is bug in Node fs.createReadStream
	        // it doesn't respect `end` options without `start` options
	        // Fix it when node fixes it.
	        // https://github.com/joyent/node/issues/7819
	        if (value.end != undefined && value.end != Infinity && value.start != undefined) {
	
	          // when end specified
	          // no need to calculate range
	          // inclusive, starts with 0
	          next(null, value.end + 1 - (value.start ? value.start : 0));
	
	        // not that fast snoopy
	        } else {
	          // still need to fetch file size from fs
	          fs.stat(value.path, function(err, stat) {
	
	            var fileSize;
	
	            if (err) {
	              next(err);
	              return;
	            }
	
	            // update final size based on the range options
	            fileSize = stat.size - (value.start ? value.start : 0);
	            next(null, fileSize);
	          });
	        }
	
	      // or http response
	      } else if (value.hasOwnProperty('httpVersion')) {
	        next(null, +value.headers['content-length']);
	
	      // or request stream http://github.com/mikeal/request
	      } else if (value.hasOwnProperty('httpModule')) {
	        // wait till response come back
	        value.on('response', function(response) {
	          value.pause();
	          next(null, +response.headers['content-length']);
	        });
	        value.resume();
	
	      // something else
	      } else {
	        next('Unknown stream');
	      }
	    });
	  }
	};
	
	FormData.prototype._multiPartHeader = function(field, value, options) {
	  // custom header specified (as string)?
	  // it becomes responsible for boundary
	  // (e.g. to handle extra CRLFs on .NET servers)
	  if (options.header) {
	    return options.header;
	  }
	
	  var contentDisposition = this._getContentDisposition(value, options);
	  var contentType = this._getContentType(value, options);
	
	  var contents = '';
	  var headers  = {
	    // add custom disposition as third element or keep it two elements if not
	    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
	    // if no content type. allow it to be empty array
	    'Content-Type': [].concat(contentType || [])
	  };
	
	  for (var prop in headers) {
	    if (headers[prop].length) {
	      contents += prop + ': ' + headers[prop].join('; ') + FormData.LINE_BREAK;
	    }
	  }
	
	  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
	};
	
	FormData.prototype._getContentDisposition = function(value, options) {
	
	  var contentDisposition;
	
	  // custom filename takes precedence
	  // fs- and request- streams have path property
	  var filename = options.filename || value.path;
	
	  // or try http response
	  if (!filename && value.readable && value.hasOwnProperty('httpVersion')) {
	    filename = value.client._httpMessage.path;
	  }
	
	  if (filename) {
	    contentDisposition = 'filename="' + path.basename(filename) + '"';
	  }
	
	  return contentDisposition;
	};
	
	FormData.prototype._getContentType = function(value, options) {
	
	  // use custom content-type above all
	  var contentType = options.contentType;
	
	  // or try `path` from fs-, request- streams
	  if (!contentType && value.path) {
	    contentType = mime.lookup(value.path);
	  }
	
	  // or if it's http-reponse
	  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
	    contentType = value.headers['content-type'];
	  }
	
	  // or guess it from the filename
	  if (!contentType && options.filename) {
	    contentType = mime.lookup(options.filename);
	  }
	
	  // fallback to the default content type if `value` is not simple value
	  if (!contentType && typeof value == 'object') {
	    contentType = FormData.DEFAULT_CONTENT_TYPE;
	  }
	
	  return contentType;
	};
	
	FormData.prototype._multiPartFooter = function() {
	  return function(next) {
	    var footer = FormData.LINE_BREAK;
	
	    var lastPart = (this._streams.length === 0);
	    if (lastPart) {
	      footer += this._lastBoundary();
	    }
	
	    next(footer);
	  }.bind(this);
	};
	
	FormData.prototype._lastBoundary = function() {
	  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
	};
	
	FormData.prototype.getHeaders = function(userHeaders) {
	  var header;
	  var formHeaders = {
	    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
	  };
	
	  for (header in userHeaders) {
	    if (userHeaders.hasOwnProperty(header)) {
	      formHeaders[header.toLowerCase()] = userHeaders[header];
	    }
	  }
	
	  return formHeaders;
	};
	
	FormData.prototype.getCustomHeaders = function(contentType) {
	  contentType = contentType ? contentType : 'multipart/form-data';
	
	  var formHeaders = {
	    'content-type': contentType + '; boundary=' + this.getBoundary(),
	    'content-length': this.getLengthSync()
	  };
	
	  return formHeaders;
	};
	
	FormData.prototype.getBoundary = function() {
	  if (!this._boundary) {
	    this._generateBoundary();
	  }
	
	  return this._boundary;
	};
	
	FormData.prototype._generateBoundary = function() {
	  // This generates a 50 character boundary similar to those used by Firefox.
	  // They are optimized for boyer-moore parsing.
	  var boundary = '--------------------------';
	  for (var i = 0; i < 24; i++) {
	    boundary += Math.floor(Math.random() * 10).toString(16);
	  }
	
	  this._boundary = boundary;
	};
	
	// Note: getLengthSync DOESN'T calculate streams length
	// As workaround one can calculate file size manually
	// and add it as knownLength option
	FormData.prototype.getLengthSync = function() {
	  var knownLength = this._overheadLength + this._valueLength;
	
	  // Don't get confused, there are 3 "internal" streams for each keyval pair
	  // so it basically checks if there is any value added to the form
	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }
	
	  // https://github.com/form-data/form-data/issues/40
	  if (this._lengthRetrievers.length) {
	    // Some async length retrievers are present
	    // therefore synchronous length calculation is false.
	    // Please use getLength(callback) to get proper length
	    this._error(new Error('Cannot calculate proper length in synchronous way.'));
	  }
	
	  return knownLength;
	};
	
	FormData.prototype.getLength = function(cb) {
	  var knownLength = this._overheadLength + this._valueLength;
	
	  if (this._streams.length) {
	    knownLength += this._lastBoundary().length;
	  }
	
	  if (!this._lengthRetrievers.length) {
	    process.nextTick(cb.bind(this, null, knownLength));
	    return;
	  }
	
	  async.parallel(this._lengthRetrievers, function(err, values) {
	    if (err) {
	      cb(err);
	      return;
	    }
	
	    values.forEach(function(length) {
	      knownLength += length;
	    });
	
	    cb(null, knownLength);
	  });
	};
	
	FormData.prototype.submit = function(params, cb) {
	  var request
	    , options
	    , defaults = {method: 'post'}
	    ;
	
	  // parse provided url if it's string
	  // or treat it as options object
	  if (typeof params == 'string') {
	
	    params = parseUrl(params);
	    options = populate({
	      port: params.port,
	      path: params.pathname,
	      host: params.hostname
	    }, defaults);
	
	  // use custom params
	  } else {
	
	    options = populate(params, defaults);
	    // if no port provided use default one
	    if (!options.port) {
	      options.port = options.protocol == 'https:' ? 443 : 80;
	    }
	  }
	
	  // put that good code in getHeaders to some use
	  options.headers = this.getHeaders(params.headers);
	
	  // https if specified, fallback to http in any other case
	  if (options.protocol == 'https:') {
	    request = https.request(options);
	  } else {
	    request = http.request(options);
	  }
	
	  // get content length and fire away
	  this.getLength(function(err, length) {
	    if (err) {
	      this._error(err);
	      return;
	    }
	
	    // add content length
	    request.setHeader('Content-Length', length);
	
	    this.pipe(request);
	    if (cb) {
	      request.on('error', cb);
	      request.on('response', cb.bind(this, null));
	    }
	  }.bind(this));
	
	  return request;
	};
	
	FormData.prototype._error = function(err) {
	  if (!this.error) {
	    this.error = err;
	    this.pause();
	    this.emit('error', err);
	  }
	};


/***/ },
/* 687 */
/*!**************************************************!*\
  !*** ./~/combined-stream/lib/combined_stream.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(/*! util */ 597);
	var Stream = __webpack_require__(/*! stream */ 604).Stream;
	var DelayedStream = __webpack_require__(/*! delayed-stream */ 688);
	
	module.exports = CombinedStream;
	function CombinedStream() {
	  this.writable = false;
	  this.readable = true;
	  this.dataSize = 0;
	  this.maxDataSize = 2 * 1024 * 1024;
	  this.pauseStreams = true;
	
	  this._released = false;
	  this._streams = [];
	  this._currentStream = null;
	}
	util.inherits(CombinedStream, Stream);
	
	CombinedStream.create = function(options) {
	  var combinedStream = new this();
	
	  options = options || {};
	  for (var option in options) {
	    combinedStream[option] = options[option];
	  }
	
	  return combinedStream;
	};
	
	CombinedStream.isStreamLike = function(stream) {
	  return (typeof stream !== 'function')
	    && (typeof stream !== 'string')
	    && (typeof stream !== 'boolean')
	    && (typeof stream !== 'number')
	    && (!Buffer.isBuffer(stream));
	};
	
	CombinedStream.prototype.append = function(stream) {
	  var isStreamLike = CombinedStream.isStreamLike(stream);
	
	  if (isStreamLike) {
	    if (!(stream instanceof DelayedStream)) {
	      var newStream = DelayedStream.create(stream, {
	        maxDataSize: Infinity,
	        pauseStream: this.pauseStreams,
	      });
	      stream.on('data', this._checkDataSize.bind(this));
	      stream = newStream;
	    }
	
	    this._handleErrors(stream);
	
	    if (this.pauseStreams) {
	      stream.pause();
	    }
	  }
	
	  this._streams.push(stream);
	  return this;
	};
	
	CombinedStream.prototype.pipe = function(dest, options) {
	  Stream.prototype.pipe.call(this, dest, options);
	  this.resume();
	  return dest;
	};
	
	CombinedStream.prototype._getNext = function() {
	  this._currentStream = null;
	  var stream = this._streams.shift();
	
	
	  if (typeof stream == 'undefined') {
	    this.end();
	    return;
	  }
	
	  if (typeof stream !== 'function') {
	    this._pipeNext(stream);
	    return;
	  }
	
	  var getStream = stream;
	  getStream(function(stream) {
	    var isStreamLike = CombinedStream.isStreamLike(stream);
	    if (isStreamLike) {
	      stream.on('data', this._checkDataSize.bind(this));
	      this._handleErrors(stream);
	    }
	
	    this._pipeNext(stream);
	  }.bind(this));
	};
	
	CombinedStream.prototype._pipeNext = function(stream) {
	  this._currentStream = stream;
	
	  var isStreamLike = CombinedStream.isStreamLike(stream);
	  if (isStreamLike) {
	    stream.on('end', this._getNext.bind(this));
	    stream.pipe(this, {end: false});
	    return;
	  }
	
	  var value = stream;
	  this.write(value);
	  this._getNext();
	};
	
	CombinedStream.prototype._handleErrors = function(stream) {
	  var self = this;
	  stream.on('error', function(err) {
	    self._emitError(err);
	  });
	};
	
	CombinedStream.prototype.write = function(data) {
	  this.emit('data', data);
	};
	
	CombinedStream.prototype.pause = function() {
	  if (!this.pauseStreams) {
	    return;
	  }
	
	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
	  this.emit('pause');
	};
	
	CombinedStream.prototype.resume = function() {
	  if (!this._released) {
	    this._released = true;
	    this.writable = true;
	    this._getNext();
	  }
	
	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
	  this.emit('resume');
	};
	
	CombinedStream.prototype.end = function() {
	  this._reset();
	  this.emit('end');
	};
	
	CombinedStream.prototype.destroy = function() {
	  this._reset();
	  this.emit('close');
	};
	
	CombinedStream.prototype._reset = function() {
	  this.writable = false;
	  this._streams = [];
	  this._currentStream = null;
	};
	
	CombinedStream.prototype._checkDataSize = function() {
	  this._updateDataSize();
	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }
	
	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this._emitError(new Error(message));
	};
	
	CombinedStream.prototype._updateDataSize = function() {
	  this.dataSize = 0;
	
	  var self = this;
	  this._streams.forEach(function(stream) {
	    if (!stream.dataSize) {
	      return;
	    }
	
	    self.dataSize += stream.dataSize;
	  });
	
	  if (this._currentStream && this._currentStream.dataSize) {
	    this.dataSize += this._currentStream.dataSize;
	  }
	};
	
	CombinedStream.prototype._emitError = function(err) {
	  this._reset();
	  this.emit('error', err);
	};


/***/ },
/* 688 */
/*!************************************************!*\
  !*** ./~/delayed-stream/lib/delayed_stream.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(/*! stream */ 604).Stream;
	var util = __webpack_require__(/*! util */ 597);
	
	module.exports = DelayedStream;
	function DelayedStream() {
	  this.source = null;
	  this.dataSize = 0;
	  this.maxDataSize = 1024 * 1024;
	  this.pauseStream = true;
	
	  this._maxDataSizeExceeded = false;
	  this._released = false;
	  this._bufferedEvents = [];
	}
	util.inherits(DelayedStream, Stream);
	
	DelayedStream.create = function(source, options) {
	  var delayedStream = new this();
	
	  options = options || {};
	  for (var option in options) {
	    delayedStream[option] = options[option];
	  }
	
	  delayedStream.source = source;
	
	  var realEmit = source.emit;
	  source.emit = function() {
	    delayedStream._handleEmit(arguments);
	    return realEmit.apply(source, arguments);
	  };
	
	  source.on('error', function() {});
	  if (delayedStream.pauseStream) {
	    source.pause();
	  }
	
	  return delayedStream;
	};
	
	Object.defineProperty(DelayedStream.prototype, 'readable', {
	  configurable: true,
	  enumerable: true,
	  get: function() {
	    return this.source.readable;
	  }
	});
	
	DelayedStream.prototype.setEncoding = function() {
	  return this.source.setEncoding.apply(this.source, arguments);
	};
	
	DelayedStream.prototype.resume = function() {
	  if (!this._released) {
	    this.release();
	  }
	
	  this.source.resume();
	};
	
	DelayedStream.prototype.pause = function() {
	  this.source.pause();
	};
	
	DelayedStream.prototype.release = function() {
	  this._released = true;
	
	  this._bufferedEvents.forEach(function(args) {
	    this.emit.apply(this, args);
	  }.bind(this));
	  this._bufferedEvents = [];
	};
	
	DelayedStream.prototype.pipe = function() {
	  var r = Stream.prototype.pipe.apply(this, arguments);
	  this.resume();
	  return r;
	};
	
	DelayedStream.prototype._handleEmit = function(args) {
	  if (this._released) {
	    this.emit.apply(this, args);
	    return;
	  }
	
	  if (args[0] === 'data') {
	    this.dataSize += args[1].length;
	    this._checkIfMaxDataSizeExceeded();
	  }
	
	  this._bufferedEvents.push(args);
	};
	
	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
	  if (this._maxDataSizeExceeded) {
	    return;
	  }
	
	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }
	
	  this._maxDataSizeExceeded = true;
	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
	  this.emit('error', new Error(message));
	};


/***/ },
/* 689 */
/*!******************************!*\
  !*** ./~/async/lib/async.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	(function () {
	
	    var async = {};
	    function noop() {}
	    function identity(v) {
	        return v;
	    }
	    function toBool(v) {
	        return !!v;
	    }
	    function notId(v) {
	        return !v;
	    }
	
	    // global on the server, window in the browser
	    var previous_async;
	
	    // Establish the root object, `window` (`self`) in the browser, `global`
	    // on the server, or `this` in some virtual machines. We use `self`
	    // instead of `window` for `WebWorker` support.
	    var root = typeof self === 'object' && self.self === self && self ||
	            typeof global === 'object' && global.global === global && global ||
	            this;
	
	    if (root != null) {
	        previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        return function() {
	            if (fn === null) throw new Error("Callback was already called.");
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    function _once(fn) {
	        return function() {
	            if (fn === null) return;
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    // Ported from underscore.js isObject
	    var _isObject = function(obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };
	
	    function _isArrayLike(arr) {
	        return _isArray(arr) || (
	            // has a positive integer length property
	            typeof arr.length === "number" &&
	            arr.length >= 0 &&
	            arr.length % 1 === 0
	        );
	    }
	
	    function _arrayEach(arr, iterator) {
	        var index = -1,
	            length = arr.length;
	
	        while (++index < length) {
	            iterator(arr[index], index, arr);
	        }
	    }
	
	    function _map(arr, iterator) {
	        var index = -1,
	            length = arr.length,
	            result = Array(length);
	
	        while (++index < length) {
	            result[index] = iterator(arr[index], index, arr);
	        }
	        return result;
	    }
	
	    function _range(count) {
	        return _map(Array(count), function (v, i) { return i; });
	    }
	
	    function _reduce(arr, iterator, memo) {
	        _arrayEach(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    }
	
	    function _forEachOf(object, iterator) {
	        _arrayEach(_keys(object), function (key) {
	            iterator(object[key], key);
	        });
	    }
	
	    function _indexOf(arr, item) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === item) return i;
	        }
	        return -1;
	    }
	
	    var _keys = Object.keys || function (obj) {
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    function _keyIterator(coll) {
	        var i = -1;
	        var len;
	        var keys;
	        if (_isArrayLike(coll)) {
	            len = coll.length;
	            return function next() {
	                i++;
	                return i < len ? i : null;
	            };
	        } else {
	            keys = _keys(coll);
	            len = keys.length;
	            return function next() {
	                i++;
	                return i < len ? keys[i] : null;
	            };
	        }
	    }
	
	    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
	    // This accumulates the arguments passed into an array, after a given index.
	    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
	    function _restParam(func, startIndex) {
	        startIndex = startIndex == null ? func.length - 1 : +startIndex;
	        return function() {
	            var length = Math.max(arguments.length - startIndex, 0);
	            var rest = Array(length);
	            for (var index = 0; index < length; index++) {
	                rest[index] = arguments[index + startIndex];
	            }
	            switch (startIndex) {
	                case 0: return func.call(this, rest);
	                case 1: return func.call(this, arguments[0], rest);
	            }
	            // Currently unused but handle cases outside of the switch statement:
	            // var args = Array(startIndex + 1);
	            // for (index = 0; index < startIndex; index++) {
	            //     args[index] = arguments[index];
	            // }
	            // args[startIndex] = rest;
	            // return func.apply(this, args);
	        };
	    }
	
	    function _withoutIndex(iterator) {
	        return function (value, index, callback) {
	            return iterator(value, callback);
	        };
	    }
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	
	    // capture the global reference to guard against fakeTimer mocks
	    var _setImmediate = typeof setImmediate === 'function' && setImmediate;
	
	    var _delay = _setImmediate ? function(fn) {
	        // not a direct alias for IE10 compatibility
	        _setImmediate(fn);
	    } : function(fn) {
	        setTimeout(fn, 0);
	    };
	
	    if (typeof process === 'object' && typeof process.nextTick === 'function') {
	        async.nextTick = process.nextTick;
	    } else {
	        async.nextTick = _delay;
	    }
	    async.setImmediate = _setImmediate ? _delay : async.nextTick;
	
	
	    async.forEach =
	    async.each = function (arr, iterator, callback) {
	        return async.eachOf(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachSeries =
	    async.eachSeries = function (arr, iterator, callback) {
	        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
	    };
	
	
	    async.forEachLimit =
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachOf =
	    async.eachOf = function (object, iterator, callback) {
	        callback = _once(callback || noop);
	        object = object || [];
	
	        var iter = _keyIterator(object);
	        var key, completed = 0;
	
	        while ((key = iter()) != null) {
	            completed += 1;
	            iterator(object[key], key, only_once(done));
	        }
	
	        if (completed === 0) callback(null);
	
	        function done(err) {
	            completed--;
	            if (err) {
	                callback(err);
	            }
	            // Check key is null in case iterator isn't exhausted
	            // and done resolved synchronously.
	            else if (key === null && completed <= 0) {
	                callback(null);
	            }
	        }
	    };
	
	    async.forEachOfSeries =
	    async.eachOfSeries = function (obj, iterator, callback) {
	        callback = _once(callback || noop);
	        obj = obj || [];
	        var nextKey = _keyIterator(obj);
	        var key = nextKey();
	        function iterate() {
	            var sync = true;
	            if (key === null) {
	                return callback(null);
	            }
	            iterator(obj[key], key, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    key = nextKey();
	                    if (key === null) {
	                        return callback(null);
	                    } else {
	                        if (sync) {
	                            async.setImmediate(iterate);
	                        } else {
	                            iterate();
	                        }
	                    }
	                }
	            }));
	            sync = false;
	        }
	        iterate();
	    };
	
	
	
	    async.forEachOfLimit =
	    async.eachOfLimit = function (obj, limit, iterator, callback) {
	        _eachOfLimit(limit)(obj, iterator, callback);
	    };
	
	    function _eachOfLimit(limit) {
	
	        return function (obj, iterator, callback) {
	            callback = _once(callback || noop);
	            obj = obj || [];
	            var nextKey = _keyIterator(obj);
	            if (limit <= 0) {
	                return callback(null);
	            }
	            var done = false;
	            var running = 0;
	            var errored = false;
	
	            (function replenish () {
	                if (done && running <= 0) {
	                    return callback(null);
	                }
	
	                while (running < limit && !errored) {
	                    var key = nextKey();
	                    if (key === null) {
	                        done = true;
	                        if (running <= 0) {
	                            callback(null);
	                        }
	                        return;
	                    }
	                    running += 1;
	                    iterator(obj[key], key, only_once(function (err) {
	                        running -= 1;
	                        if (err) {
	                            callback(err);
	                            errored = true;
	                        }
	                        else {
	                            replenish();
	                        }
	                    }));
	                }
	            })();
	        };
	    }
	
	
	    function doParallel(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOf, obj, iterator, callback);
	        };
	    }
	    function doParallelLimit(fn) {
	        return function (obj, limit, iterator, callback) {
	            return fn(_eachOfLimit(limit), obj, iterator, callback);
	        };
	    }
	    function doSeries(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOfSeries, obj, iterator, callback);
	        };
	    }
	
	    function _asyncMap(eachfn, arr, iterator, callback) {
	        callback = _once(callback || noop);
	        arr = arr || [];
	        var results = _isArrayLike(arr) ? [] : {};
	        eachfn(arr, function (value, index, callback) {
	            iterator(value, function (err, v) {
	                results[index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = doParallelLimit(_asyncMap);
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.inject =
	    async.foldl =
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachOfSeries(arr, function (x, i, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	
	    async.foldr =
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, identity).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	
	    async.transform = function (arr, memo, iterator, callback) {
	        if (arguments.length === 3) {
	            callback = iterator;
	            iterator = memo;
	            memo = _isArray(arr) ? [] : {};
	        }
	
	        async.eachOf(arr, function(v, k, cb) {
	            iterator(memo, v, k, cb);
	        }, function(err) {
	            callback(err, memo);
	        });
	    };
	
	    function _filter(eachfn, arr, iterator, callback) {
	        var results = [];
	        eachfn(arr, function (x, index, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    results.push({index: index, value: x});
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }
	
	    async.select =
	    async.filter = doParallel(_filter);
	
	    async.selectLimit =
	    async.filterLimit = doParallelLimit(_filter);
	
	    async.selectSeries =
	    async.filterSeries = doSeries(_filter);
	
	    function _reject(eachfn, arr, iterator, callback) {
	        _filter(eachfn, arr, function(value, cb) {
	            iterator(value, function(v) {
	                cb(!v);
	            });
	        }, callback);
	    }
	    async.reject = doParallel(_reject);
	    async.rejectLimit = doParallelLimit(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    function _createTester(eachfn, check, getResult) {
	        return function(arr, limit, iterator, cb) {
	            function done() {
	                if (cb) cb(getResult(false, void 0));
	            }
	            function iteratee(x, _, callback) {
	                if (!cb) return callback();
	                iterator(x, function (v) {
	                    if (cb && check(v)) {
	                        cb(getResult(true, x));
	                        cb = iterator = false;
	                    }
	                    callback();
	                });
	            }
	            if (arguments.length > 3) {
	                eachfn(arr, limit, iteratee, done);
	            } else {
	                cb = iterator;
	                iterator = limit;
	                eachfn(arr, iteratee, done);
	            }
	        };
	    }
	
	    async.any =
	    async.some = _createTester(async.eachOf, toBool, identity);
	
	    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
	
	    async.all =
	    async.every = _createTester(async.eachOf, notId, notId);
	
	    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
	
	    function _findGetResult(v, x) {
	        return x;
	    }
	    async.detect = _createTester(async.eachOf, identity, _findGetResult);
	    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
	    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                callback(null, _map(results.sort(comparator), function (x) {
	                    return x.value;
	                }));
	            }
	
	        });
	
	        function comparator(left, right) {
	            var a = left.criteria, b = right.criteria;
	            return a < b ? -1 : a > b ? 1 : 0;
	        }
	    };
	
	    async.auto = function (tasks, concurrency, callback) {
	        if (typeof arguments[1] === 'function') {
	            // concurrency is optional, shift the args.
	            callback = concurrency;
	            concurrency = null;
	        }
	        callback = _once(callback || noop);
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length;
	        if (!remainingTasks) {
	            return callback(null);
	        }
	        if (!concurrency) {
	            concurrency = remainingTasks;
	        }
	
	        var results = {};
	        var runningTasks = 0;
	
	        var hasError = false;
	
	        var listeners = [];
	        function addListener(fn) {
	            listeners.unshift(fn);
	        }
	        function removeListener(fn) {
	            var idx = _indexOf(listeners, fn);
	            if (idx >= 0) listeners.splice(idx, 1);
	        }
	        function taskComplete() {
	            remainingTasks--;
	            _arrayEach(listeners.slice(0), function (fn) {
	                fn();
	            });
	        }
	
	        addListener(function () {
	            if (!remainingTasks) {
	                callback(null, results);
	            }
	        });
	
	        _arrayEach(keys, function (k) {
	            if (hasError) return;
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = _restParam(function(err, args) {
	                runningTasks--;
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _forEachOf(results, function(val, rkey) {
	                        safeResults[rkey] = val;
	                    });
	                    safeResults[k] = args;
	                    hasError = true;
	
	                    callback(err, safeResults);
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            });
	            var requires = task.slice(0, task.length - 1);
	            // prevent dead-locks
	            var len = requires.length;
	            var dep;
	            while (len--) {
	                if (!(dep = tasks[requires[len]])) {
	                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
	                }
	                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
	                    throw new Error('Has cyclic dependencies');
	                }
	            }
	            function ready() {
	                return runningTasks < concurrency && _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            }
	            if (ready()) {
	                runningTasks++;
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                addListener(listener);
	            }
	            function listener() {
	                if (ready()) {
	                    runningTasks++;
	                    removeListener(listener);
	                    task[task.length - 1](taskCallback, results);
	                }
	            }
	        });
	    };
	
	
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var DEFAULT_INTERVAL = 0;
	
	        var attempts = [];
	
	        var opts = {
	            times: DEFAULT_TIMES,
	            interval: DEFAULT_INTERVAL
	        };
	
	        function parseTimes(acc, t){
	            if(typeof t === 'number'){
	                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
	            } else if(typeof t === 'object'){
	                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
	                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
	            } else {
	                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
	            }
	        }
	
	        var length = arguments.length;
	        if (length < 1 || length > 3) {
	            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
	        } else if (length <= 2 && typeof times === 'function') {
	            callback = task;
	            task = times;
	        }
	        if (typeof times !== 'function') {
	            parseTimes(opts, times);
	        }
	        opts.callback = callback;
	        opts.task = task;
	
	        function wrappedTask(wrappedCallback, wrappedResults) {
	            function retryAttempt(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            }
	
	            function retryInterval(interval){
	                return function(seriesCallback){
	                    setTimeout(function(){
	                        seriesCallback(null);
	                    }, interval);
	                };
	            }
	
	            while (opts.times) {
	
	                var finalAttempt = !(opts.times-=1);
	                attempts.push(retryAttempt(opts.task, finalAttempt));
	                if(!finalAttempt && opts.interval > 0){
	                    attempts.push(retryInterval(opts.interval));
	                }
	            }
	
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || opts.callback)(data.err, data.result);
	            });
	        }
	
	        // If a callback is passed, run this as a controll flow
	        return opts.callback ? wrappedTask() : wrappedTask;
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = _once(callback || noop);
	        if (!_isArray(tasks)) {
	            var err = new Error('First argument to waterfall must be an array of functions');
	            return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        function wrapIterator(iterator) {
	            return _restParam(function (err, args) {
	                if (err) {
	                    callback.apply(null, [err].concat(args));
	                }
	                else {
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    ensureAsync(iterator).apply(null, args);
	                }
	            });
	        }
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    function _parallel(eachfn, tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};
	
	        eachfn(tasks, function (task, key, callback) {
	            task(_restParam(function (err, args) {
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            }));
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.parallel = function (tasks, callback) {
	        _parallel(async.eachOf, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel(_eachOfLimit(limit), tasks, callback);
	    };
	
	    async.series = function(tasks, callback) {
	        _parallel(async.eachOfSeries, tasks, callback);
	    };
	
	    async.iterator = function (tasks) {
	        function makeCallback(index) {
	            function fn() {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            }
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        }
	        return makeCallback(0);
	    };
	
	    async.apply = _restParam(function (fn, args) {
	        return _restParam(function (callArgs) {
	            return fn.apply(
	                null, args.concat(callArgs)
	            );
	        });
	    });
	
	    function _concat(eachfn, arr, fn, callback) {
	        var result = [];
	        eachfn(arr, function (x, index, cb) {
	            fn(x, function (err, y) {
	                result = result.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, result);
	        });
	    }
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        callback = callback || noop;
	        if (test()) {
	            var next = _restParam(function(err, args) {
	                if (err) {
	                    callback(err);
	                } else if (test.apply(this, args)) {
	                    iterator(next);
	                } else {
	                    callback.apply(null, [null].concat(args));
	                }
	            });
	            iterator(next);
	        } else {
	            callback(null);
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        var calls = 0;
	        return async.whilst(function() {
	            return ++calls <= 1 || test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.until = function (test, iterator, callback) {
	        return async.whilst(function() {
	            return !test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        return async.doWhilst(iterator, function() {
	            return !test.apply(this, arguments);
	        }, callback);
	    };
	
	    async.during = function (test, iterator, callback) {
	        callback = callback || noop;
	
	        var next = _restParam(function(err, args) {
	            if (err) {
	                callback(err);
	            } else {
	                args.push(check);
	                test.apply(this, args);
	            }
	        });
	
	        var check = function(err, truth) {
	            if (err) {
	                callback(err);
	            } else if (truth) {
	                iterator(next);
	            } else {
	                callback(null);
	            }
	        };
	
	        test(check);
	    };
	
	    async.doDuring = function (iterator, test, callback) {
	        var calls = 0;
	        async.during(function(next) {
	            if (calls++ < 1) {
	                next(null, true);
	            } else {
	                test.apply(this, arguments);
	            }
	        }, iterator, callback);
	    };
	
	    function _queue(worker, concurrency, payload) {
	        if (concurrency == null) {
	            concurrency = 1;
	        }
	        else if(concurrency === 0) {
	            throw new Error('Concurrency must not be zero');
	        }
	        function _insert(q, data, pos, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0 && q.idle()) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    callback: callback || noop
	                };
	
	                if (pos) {
	                    q.tasks.unshift(item);
	                } else {
	                    q.tasks.push(item);
	                }
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	            });
	            async.setImmediate(q.process);
	        }
	        function _next(q, tasks) {
	            return function(){
	                workers -= 1;
	
	                var removed = false;
	                var args = arguments;
	                _arrayEach(tasks, function (task) {
	                    _arrayEach(workersList, function (worker, index) {
	                        if (worker === task && !removed) {
	                            workersList.splice(index, 1);
	                            removed = true;
	                        }
	                    });
	
	                    task.callback.apply(task, args);
	                });
	                if (q.tasks.length + workers === 0) {
	                    q.drain();
	                }
	                q.process();
	            };
	        }
	
	        var workers = 0;
	        var workersList = [];
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            payload: payload,
	            saturated: noop,
	            empty: noop,
	            drain: noop,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	                _insert(q, data, false, callback);
	            },
	            kill: function () {
	                q.drain = noop;
	                q.tasks = [];
	            },
	            unshift: function (data, callback) {
	                _insert(q, data, true, callback);
	            },
	            process: function () {
	                while(!q.paused && workers < q.concurrency && q.tasks.length){
	
	                    var tasks = q.payload ?
	                        q.tasks.splice(0, q.payload) :
	                        q.tasks.splice(0, q.tasks.length);
	
	                    var data = _map(tasks, function (task) {
	                        return task.data;
	                    });
	
	                    if (q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    workersList.push(tasks[0]);
	                    var cb = only_once(_next(q, tasks));
	                    worker(data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            workersList: function () {
	                return workersList;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                var resumeCount = Math.min(q.concurrency, q.tasks.length);
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= resumeCount; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    }
	
	    async.queue = function (worker, concurrency) {
	        var q = _queue(function (items, cb) {
	            worker(items[0], cb);
	        }, concurrency, 1);
	
	        return q;
	    };
	
	    async.priorityQueue = function (worker, concurrency) {
	
	        function _compareTasks(a, b){
	            return a.priority - b.priority;
	        }
	
	        function _binarySearch(sequence, item, compare) {
	            var beg = -1,
	                end = sequence.length - 1;
	            while (beg < end) {
	                var mid = beg + ((end - beg + 1) >>> 1);
	                if (compare(item, sequence[mid]) >= 0) {
	                    beg = mid;
	                } else {
	                    end = mid - 1;
	                }
	            }
	            return beg;
	        }
	
	        function _insert(q, data, priority, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    priority: priority,
	                    callback: typeof callback === 'function' ? callback : noop
	                };
	
	                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	                async.setImmediate(q.process);
	            });
	        }
	
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	            _insert(q, data, priority, callback);
	        };
	
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        return _queue(worker, 1, payload);
	    };
	
	    function _console_fn(name) {
	        return _restParam(function (fn, args) {
	            fn.apply(null, args.concat([_restParam(function (err, args) {
	                if (typeof console === 'object') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _arrayEach(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            })]));
	        });
	    }
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        var has = Object.prototype.hasOwnProperty;
	        hasher = hasher || identity;
	        var memoized = _restParam(function memoized(args) {
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (has.call(memo, key)) {   
	                async.setImmediate(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (has.call(queues, key)) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([_restParam(function (args) {
	                    memo[key] = args;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                        q[i].apply(null, args);
	                    }
	                })]));
	            }
	        });
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	        return function () {
	            return (fn.unmemoized || fn).apply(null, arguments);
	        };
	    };
	
	    function _times(mapper) {
	        return function (count, iterator, callback) {
	            mapper(_range(count), iterator, callback);
	        };
	    }
	
	    async.times = _times(async.map);
	    async.timesSeries = _times(async.mapSeries);
	    async.timesLimit = function (count, limit, iterator, callback) {
	        return async.mapLimit(_range(count), limit, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return _restParam(function (args) {
	            var that = this;
	
	            var callback = args[args.length - 1];
	            if (typeof callback == 'function') {
	                args.pop();
	            } else {
	                callback = noop;
	            }
	
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
	                    cb(err, nextargs);
	                })]));
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        });
	    };
	
	    async.compose = function (/* functions... */) {
	        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	
	    function _applyEach(eachfn) {
	        return _restParam(function(fns, args) {
	            var go = _restParam(function(args) {
	                var that = this;
	                var callback = args.pop();
	                return eachfn(fns, function (fn, _, cb) {
	                    fn.apply(that, args.concat([cb]));
	                },
	                callback);
	            });
	            if (args.length) {
	                return go.apply(this, args);
	            }
	            else {
	                return go;
	            }
	        });
	    }
	
	    async.applyEach = _applyEach(async.eachOf);
	    async.applyEachSeries = _applyEach(async.eachOfSeries);
	
	
	    async.forever = function (fn, callback) {
	        var done = only_once(callback || noop);
	        var task = ensureAsync(fn);
	        function next(err) {
	            if (err) {
	                return done(err);
	            }
	            task(next);
	        }
	        next();
	    };
	
	    function ensureAsync(fn) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            args.push(function () {
	                var innerArgs = arguments;
	                if (sync) {
	                    async.setImmediate(function () {
	                        callback.apply(null, innerArgs);
	                    });
	                } else {
	                    callback.apply(null, innerArgs);
	                }
	            });
	            var sync = true;
	            fn.apply(this, args);
	            sync = false;
	        });
	    }
	
	    async.ensureAsync = ensureAsync;
	
	    async.constant = _restParam(function(values) {
	        var args = [null].concat(values);
	        return function (callback) {
	            return callback.apply(this, args);
	        };
	    });
	
	    async.wrapSync =
	    async.asyncify = function asyncify(func) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            var result;
	            try {
	                result = func.apply(this, args);
	            } catch (e) {
	                return callback(e);
	            }
	            // if result is Promise object
	            if (_isObject(result) && typeof result.then === "function") {
	                result.then(function(value) {
	                    callback(null, value);
	                })["catch"](function(err) {
	                    callback(err.message ? err : new Error(err));
	                });
	            } else {
	                callback(null, result);
	            }
	        });
	    };
	
	    // Node.js
	    if (typeof module === 'object' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());


/***/ },
/* 690 */
/*!*************************************!*\
  !*** ./~/form-data/lib/populate.js ***!
  \*************************************/
/***/ function(module, exports) {

	// populates missing values
	module.exports = function(dst, src) {
	  for (var prop in src) {
	    if (src.hasOwnProperty(prop) && !dst[prop]) {
	      dst[prop] = src[prop];
	    }
	  }
	  return dst;
	};


/***/ },
/* 691 */
/*!********************************!*\
  !*** ./~/isstream/isstream.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var stream = __webpack_require__(/*! stream */ 604)
	
	
	function isStream (obj) {
	  return obj instanceof stream.Stream
	}
	
	
	function isReadable (obj) {
	  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
	}
	
	
	function isWritable (obj) {
	  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
	}
	
	
	function isDuplex (obj) {
	  return isReadable(obj) && isWritable(obj)
	}
	
	
	module.exports            = isStream
	module.exports.isReadable = isReadable
	module.exports.isWritable = isWritable
	module.exports.isDuplex   = isDuplex


/***/ },
/* 692 */
/*!**********************************!*\
  !*** ./~/is-typedarray/index.js ***!
  \**********************************/
/***/ function(module, exports) {

	module.exports      = isTypedArray
	isTypedArray.strict = isStrictTypedArray
	isTypedArray.loose  = isLooseTypedArray
	
	var toString = Object.prototype.toString
	var names = {
	    '[object Int8Array]': true
	  , '[object Int16Array]': true
	  , '[object Int32Array]': true
	  , '[object Uint8Array]': true
	  , '[object Uint8ClampedArray]': true
	  , '[object Uint16Array]': true
	  , '[object Uint32Array]': true
	  , '[object Float32Array]': true
	  , '[object Float64Array]': true
	}
	
	function isTypedArray(arr) {
	  return (
	       isStrictTypedArray(arr)
	    || isLooseTypedArray(arr)
	  )
	}
	
	function isStrictTypedArray(arr) {
	  return (
	       arr instanceof Int8Array
	    || arr instanceof Int16Array
	    || arr instanceof Int32Array
	    || arr instanceof Uint8Array
	    || arr instanceof Uint8ClampedArray
	    || arr instanceof Uint16Array
	    || arr instanceof Uint32Array
	    || arr instanceof Float32Array
	    || arr instanceof Float64Array
	  )
	}
	
	function isLooseTypedArray(arr) {
	  return names[toString.call(arr)]
	}


/***/ },
/* 693 */
/*!******************************************!*\
  !*** ./~/request/lib/getProxyFromURI.js ***!
  \******************************************/
/***/ function(module, exports) {

	'use strict'
	
	function formatHostname(hostname) {
	  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
	  return hostname.replace(/^\.*/, '.').toLowerCase()
	}
	
	function parseNoProxyZone(zone) {
	  zone = zone.trim().toLowerCase()
	
	  var zoneParts = zone.split(':', 2)
	    , zoneHost = formatHostname(zoneParts[0])
	    , zonePort = zoneParts[1]
	    , hasPort = zone.indexOf(':') > -1
	
	  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}
	}
	
	function uriInNoProxy(uri, noProxy) {
	  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')
	    , hostname = formatHostname(uri.hostname)
	    , noProxyList = noProxy.split(',')
	
	  // iterate through the noProxyList until it finds a match.
	  return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
	    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)
	      , hostnameMatched = (
	          isMatchedAt > -1 &&
	          (isMatchedAt === hostname.length - noProxyZone.hostname.length)
	        )
	
	    if (noProxyZone.hasPort) {
	      return (port === noProxyZone.port) && hostnameMatched
	    }
	
	    return hostnameMatched
	  })
	}
	
	function getProxyFromURI(uri) {
	  // Decide the proper request proxy to use based on the request URI object and the
	  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)
	  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)
	
	  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''
	
	  // if the noProxy is a wildcard then return null
	
	  if (noProxy === '*') {
	    return null
	  }
	
	  // if the noProxy is not empty and the uri is found return null
	
	  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {
	    return null
	  }
	
	  // Check for HTTP or HTTPS Proxy in environment Else default to null
	
	  if (uri.protocol === 'http:') {
	    return process.env.HTTP_PROXY ||
	           process.env.http_proxy || null
	  }
	
	  if (uri.protocol === 'https:') {
	    return process.env.HTTPS_PROXY ||
	           process.env.https_proxy ||
	           process.env.HTTP_PROXY  ||
	           process.env.http_proxy  || null
	  }
	
	  // if none of that works, return null
	  // (What uri protocol are you using then?)
	
	  return null
	}
	
	module.exports = getProxyFromURI


/***/ },
/* 694 */
/*!**************************************!*\
  !*** ./~/request/lib/querystring.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var qs = __webpack_require__(/*! qs */ 695)
	  , querystring = __webpack_require__(/*! querystring */ 540)
	
	
	function Querystring (request) {
	  this.request = request
	  this.lib = null
	  this.useQuerystring = null
	  this.parseOptions = null
	  this.stringifyOptions = null
	}
	
	Querystring.prototype.init = function (options) {
	  if (this.lib) {return}
	
	  this.useQuerystring = options.useQuerystring
	  this.lib = (this.useQuerystring ? querystring : qs)
	
	  this.parseOptions = options.qsParseOptions || {}
	  this.stringifyOptions = options.qsStringifyOptions || {}
	}
	
	Querystring.prototype.stringify = function (obj) {
	  return (this.useQuerystring)
	    ? this.rfc3986(this.lib.stringify(obj,
	      this.stringifyOptions.sep || null,
	      this.stringifyOptions.eq || null,
	      this.stringifyOptions))
	    : this.lib.stringify(obj, this.stringifyOptions)
	}
	
	Querystring.prototype.parse = function (str) {
	  return (this.useQuerystring)
	    ? this.lib.parse(str,
	      this.parseOptions.sep || null,
	      this.parseOptions.eq || null,
	      this.parseOptions)
	    : this.lib.parse(str, this.parseOptions)
	}
	
	Querystring.prototype.rfc3986 = function (str) {
	  return str.replace(/[!'()*]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}
	
	Querystring.prototype.unescape = querystring.unescape
	
	exports.Querystring = Querystring


/***/ },
/* 695 */
/*!***************************!*\
  !*** ./~/qs/lib/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Stringify = __webpack_require__(/*! ./stringify */ 696);
	var Parse = __webpack_require__(/*! ./parse */ 698);
	
	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 696 */
/*!*******************************!*\
  !*** ./~/qs/lib/stringify.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Utils = __webpack_require__(/*! ./utils */ 697);
	
	var internals = {
	    delimiter: '&',
	    arrayPrefixGenerators: {
	        brackets: function (prefix) {
	            return prefix + '[]';
	        },
	        indices: function (prefix, key) {
	            return prefix + '[' + key + ']';
	        },
	        repeat: function (prefix) {
	            return prefix;
	        }
	    },
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true
	};
	
	internals.stringify = function (object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (Utils.isBuffer(obj)) {
	        obj = String(obj);
	    } else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encode ? Utils.encode(prefix) : prefix;
	        }
	
	        obj = '';
	    }
	
	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
	        if (encode) {
	            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
	        }
	        return [prefix + '=' + obj];
	    }
	
	    var values = [];
	
	    if (typeof obj === 'undefined') {
	        return values;
	    }
	
	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }
	
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];
	
	        if (skipNulls && obj[key] === null) {
	            continue;
	        }
	
	        if (Array.isArray(obj)) {
	            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));
	        } else {
	            values = values.concat(internals.stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));
	        }
	    }
	
	    return values;
	};
	
	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var objKeys;
	    var filter;
	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }
	
	    var keys = [];
	
	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }
	
	    var arrayFormat;
	    if (options.arrayFormat in internals.arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }
	
	    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];
	
	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }
	
	    if (sort) {
	        objKeys.sort(sort);
	    }
	
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];
	
	        if (skipNulls && obj[key] === null) {
	            continue;
	        }
	
	        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));
	    }
	
	    return keys.join(delimiter);
	};


/***/ },
/* 697 */
/*!***************************!*\
  !*** ./~/qs/lib/utils.js ***!
  \***************************/
/***/ function(module, exports) {

	'use strict';
	
	var hexTable = (function () {
	    var array = new Array(256);
	    for (var i = 0; i < 256; ++i) {
	        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	    }
	
	    return array;
	}());
	
	exports.arrayToObject = function (source, options) {
	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }
	
	    return obj;
	};
	
	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }
	
	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if (typeof target === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }
	
	        return target;
	    }
	
	    if (typeof target !== 'object') {
	        return [target].concat(source);
	    }
	
	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }
	
		return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];
	
	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
			return acc;
	    }, mergeTarget);
	};
	
	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};
	
	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }
	
	    var string = typeof str === 'string' ? str : String(str);
	
	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);
	
	        if (
	            c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }
	
	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }
	
	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }
	
	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }
	
	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        out += (hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	    }
	
	    return out;
	};
	
	exports.compact = function (obj, references) {
	    if (typeof obj !== 'object' || obj === null) {
	        return obj;
	    }
	
	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }
	
	    refs.push(obj);
	
	    if (Array.isArray(obj)) {
	        var compacted = [];
	
	        for (var i = 0; i < obj.length; ++i) {
	            if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }
	
	        return compacted;
	    }
	
	    var keys = Object.keys(obj);
	    for (var j = 0; j < keys.length; ++j) {
	        var key = keys[j];
	        obj[key] = exports.compact(obj[key], refs);
	    }
	
	    return obj;
	};
	
	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};
	
	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }
	
	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};


/***/ },
/* 698 */
/*!***************************!*\
  !*** ./~/qs/lib/parse.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Utils = __webpack_require__(/*! ./utils */ 697);
	
	var internals = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false
	};
	
	internals.parseValues = function (str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);
	
	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;
	
	        if (pos === -1) {
	            obj[Utils.decode(part)] = '';
	
	            if (options.strictNullHandling) {
	                obj[Utils.decode(part)] = null;
	            }
	        } else {
	            var key = Utils.decode(part.slice(0, pos));
	            var val = Utils.decode(part.slice(pos + 1));
	
	            if (Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = [].concat(obj[key]).concat(val);
	            } else {
	                obj[key] = val;
	            }
	        }
	    }
	
	    return obj;
	};
	
	internals.parseObject = function (chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }
	
	    var root = chain.shift();
	
	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(internals.parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (
	            !isNaN(index) &&
	            root !== cleanRoot &&
	            String(index) === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays && index <= options.arrayLimit)
	        ) {
	            obj = [];
	            obj[index] = internals.parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = internals.parseObject(chain, val, options);
	        }
	    }
	
	    return obj;
	};
	
	internals.parseKeys = function (givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }
	
	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;
	
	    // The regex chunks
	
	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;
	
	    // Get the parent
	
	    var segment = parent.exec(key);
	
	    // Stash the parent if it exists
	
	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	
	        keys.push(segment[1]);
	    }
	
	    // Loop through children appending to the array until we hit depth
	
	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }
	
	    // If there's a remainder, just add whatever is left
	
	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }
	
	    return internals.parseObject(keys, val, options);
	};
	
	module.exports = function (str, opts) {
	    var options = opts || {};
	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
	
	    if (
	        str === '' ||
	        str === null ||
	        typeof str === 'undefined'
	    ) {
	        return options.plainObjects ? Object.create(null) : {};
	    }
	
	    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};
	
	    // Iterate over the keys and setup the new object
	
	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = internals.parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }
	
	    return Utils.compact(obj);
	};


/***/ },
/* 699 */
/*!******************************!*\
  !*** ./~/request/lib/har.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var fs = __webpack_require__(/*! fs */ 531)
	var qs = __webpack_require__(/*! querystring */ 540)
	var validate = __webpack_require__(/*! har-validator */ 700)
	var extend = __webpack_require__(/*! extend */ 587)
	
	function Har (request) {
	  this.request = request
	}
	
	Har.prototype.reducer = function (obj, pair) {
	  // new property ?
	  if (obj[pair.name] === undefined) {
	    obj[pair.name] = pair.value
	    return obj
	  }
	
	  // existing? convert to array
	  var arr = [
	    obj[pair.name],
	    pair.value
	  ]
	
	  obj[pair.name] = arr
	
	  return obj
	}
	
	Har.prototype.prep = function (data) {
	  // construct utility properties
	  data.queryObj = {}
	  data.headersObj = {}
	  data.postData.jsonObj = false
	  data.postData.paramsObj = false
	
	  // construct query objects
	  if (data.queryString && data.queryString.length) {
	    data.queryObj = data.queryString.reduce(this.reducer, {})
	  }
	
	  // construct headers objects
	  if (data.headers && data.headers.length) {
	    // loweCase header keys
	    data.headersObj = data.headers.reduceRight(function (headers, header) {
	      headers[header.name] = header.value
	      return headers
	    }, {})
	  }
	
	  // construct Cookie header
	  if (data.cookies && data.cookies.length) {
	    var cookies = data.cookies.map(function (cookie) {
	      return cookie.name + '=' + cookie.value
	    })
	
	    if (cookies.length) {
	      data.headersObj.cookie = cookies.join('; ')
	    }
	  }
	
	  // prep body
	  function some (arr) {
	    return arr.some(function (type) {
	      return data.postData.mimeType.indexOf(type) === 0
	    })
	  }
	
	  if (some([
	    'multipart/mixed',
	    'multipart/related',
	    'multipart/form-data',
	    'multipart/alternative'])) {
	
	    // reset values
	    data.postData.mimeType = 'multipart/form-data'
	  }
	
	  else if (some([
	    'application/x-www-form-urlencoded'])) {
	
	    if (!data.postData.params) {
	      data.postData.text = ''
	    } else {
	      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})
	
	      // always overwrite
	      data.postData.text = qs.stringify(data.postData.paramsObj)
	    }
	  }
	
	  else if (some([
	    'text/json',
	    'text/x-json',
	    'application/json',
	    'application/x-json'])) {
	
	    data.postData.mimeType = 'application/json'
	
	    if (data.postData.text) {
	      try {
	        data.postData.jsonObj = JSON.parse(data.postData.text)
	      } catch (e) {
	        this.request.debug(e)
	
	        // force back to text/plain
	        data.postData.mimeType = 'text/plain'
	      }
	    }
	  }
	
	  return data
	}
	
	Har.prototype.options = function (options) {
	  // skip if no har property defined
	  if (!options.har) {
	    return options
	  }
	
	  var har = {}
	  extend(har, options.har)
	
	  // only process the first entry
	  if (har.log && har.log.entries) {
	    har = har.log.entries[0]
	  }
	
	  // add optional properties to make validation successful
	  har.url = har.url || options.url || options.uri || options.baseUrl || '/'
	  har.httpVersion = har.httpVersion || 'HTTP/1.1'
	  har.queryString = har.queryString || []
	  har.headers = har.headers || []
	  har.cookies = har.cookies || []
	  har.postData = har.postData || {}
	  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'
	
	  har.bodySize = 0
	  har.headersSize = 0
	  har.postData.size = 0
	
	  if (!validate.request(har)) {
	    return options
	  }
	
	  // clean up and get some utility properties
	  var req = this.prep(har)
	
	  // construct new options
	  if (req.url) {
	    options.url = req.url
	  }
	
	  if (req.method) {
	    options.method = req.method
	  }
	
	  if (Object.keys(req.queryObj).length) {
	    options.qs = req.queryObj
	  }
	
	  if (Object.keys(req.headersObj).length) {
	    options.headers = req.headersObj
	  }
	
	  function test (type) {
	    return req.postData.mimeType.indexOf(type) === 0
	  }
	  if (test('application/x-www-form-urlencoded')) {
	    options.form = req.postData.paramsObj
	  }
	  else if (test('application/json')) {
	    if (req.postData.jsonObj) {
	      options.body = req.postData.jsonObj
	      options.json = true
	    }
	  }
	  else if (test('multipart/form-data')) {
	    options.formData = {}
	
	    req.postData.params.forEach(function (param) {
	      var attachment = {}
	
	      if (!param.fileName && !param.fileName && !param.contentType) {
	        options.formData[param.name] = param.value
	        return
	      }
	
	      // attempt to read from disk!
	      if (param.fileName && !param.value) {
	        attachment.value = fs.createReadStream(param.fileName)
	      } else if (param.value) {
	        attachment.value = param.value
	      }
	
	      if (param.fileName) {
	        attachment.options = {
	          filename: param.fileName,
	          contentType: param.contentType ? param.contentType : null
	        }
	      }
	
	      options.formData[param.name] = attachment
	    })
	  }
	  else {
	    if (req.postData.text) {
	      options.body = req.postData.text
	    }
	  }
	
	  return options
	}
	
	exports.Har = Har


/***/ },
/* 700 */
/*!**************************************!*\
  !*** ./~/har-validator/lib/index.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Promise = __webpack_require__(/*! pinkie-promise */ 701)
	var runner = __webpack_require__(/*! ./runner */ 703)
	var schemas = __webpack_require__(/*! ./schemas */ 704)
	
	var promisify = function (schema) {
	  return function (data) {
	    return new Promise(function (resolve, reject) {
	      runner(schema, data, function (err, valid) {
	        return err === null ? resolve(data) : reject(err)
	      })
	    })
	  }
	}
	
	module.exports = promisify(schemas.har)
	
	// utility methods for all parts of the schema
	Object.keys(schemas).map(function (name) {
	  module.exports[name] = promisify(schemas[name])
	})


/***/ },
/* 701 */
/*!***********************************!*\
  !*** ./~/pinkie-promise/index.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = typeof Promise === 'function' ? Promise : __webpack_require__(/*! pinkie */ 702);


/***/ },
/* 702 */
/*!***************************!*\
  !*** ./~/pinkie/index.js ***!
  \***************************/
/***/ function(module, exports) {

	'use strict';
	
	var PENDING = 'pending';
	var SETTLED = 'settled';
	var FULFILLED = 'fulfilled';
	var REJECTED = 'rejected';
	var NOOP = function () {};
	var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';
	
	var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
	var asyncQueue = [];
	var asyncTimer;
	
	function asyncFlush() {
		// run promise callbacks
		for (var i = 0; i < asyncQueue.length; i++) {
			asyncQueue[i][0](asyncQueue[i][1]);
		}
	
		// reset async asyncQueue
		asyncQueue = [];
		asyncTimer = false;
	}
	
	function asyncCall(callback, arg) {
		asyncQueue.push([callback, arg]);
	
		if (!asyncTimer) {
			asyncTimer = true;
			asyncSetTimer(asyncFlush, 0);
		}
	}
	
	function invokeResolver(resolver, promise) {
		function resolvePromise(value) {
			resolve(promise, value);
		}
	
		function rejectPromise(reason) {
			reject(promise, reason);
		}
	
		try {
			resolver(resolvePromise, rejectPromise);
		} catch (e) {
			rejectPromise(e);
		}
	}
	
	function invokeCallback(subscriber) {
		var owner = subscriber.owner;
		var settled = owner._state;
		var value = owner._data;
		var callback = subscriber[settled];
		var promise = subscriber.then;
	
		if (typeof callback === 'function') {
			settled = FULFILLED;
			try {
				value = callback(value);
			} catch (e) {
				reject(promise, e);
			}
		}
	
		if (!handleThenable(promise, value)) {
			if (settled === FULFILLED) {
				resolve(promise, value);
			}
	
			if (settled === REJECTED) {
				reject(promise, value);
			}
		}
	}
	
	function handleThenable(promise, value) {
		var resolved;
	
		try {
			if (promise === value) {
				throw new TypeError('A promises callback cannot return that same promise.');
			}
	
			if (value && (typeof value === 'function' || typeof value === 'object')) {
				// then should be retrieved only once
				var then = value.then;
	
				if (typeof then === 'function') {
					then.call(value, function (val) {
						if (!resolved) {
							resolved = true;
	
							if (value === val) {
								fulfill(promise, val);
							} else {
								resolve(promise, val);
							}
						}
					}, function (reason) {
						if (!resolved) {
							resolved = true;
	
							reject(promise, reason);
						}
					});
	
					return true;
				}
			}
		} catch (e) {
			if (!resolved) {
				reject(promise, e);
			}
	
			return true;
		}
	
		return false;
	}
	
	function resolve(promise, value) {
		if (promise === value || !handleThenable(promise, value)) {
			fulfill(promise, value);
		}
	}
	
	function fulfill(promise, value) {
		if (promise._state === PENDING) {
			promise._state = SETTLED;
			promise._data = value;
	
			asyncCall(publishFulfillment, promise);
		}
	}
	
	function reject(promise, reason) {
		if (promise._state === PENDING) {
			promise._state = SETTLED;
			promise._data = reason;
	
			asyncCall(publishRejection, promise);
		}
	}
	
	function publish(promise) {
		promise._then = promise._then.forEach(invokeCallback);
	}
	
	function publishFulfillment(promise) {
		promise._state = FULFILLED;
		publish(promise);
	}
	
	function publishRejection(promise) {
		promise._state = REJECTED;
		publish(promise);
		if (!promise._handled && isNode) {
			global.process.emit('unhandledRejection', promise._data, promise);
		}
	}
	
	function notifyRejectionHandled(promise) {
		global.process.emit('rejectionHandled', promise);
	}
	
	/**
	 * @class
	 */
	function Promise(resolver) {
		if (typeof resolver !== 'function') {
			throw new TypeError('Promise resolver ' + resolver + ' is not a function');
		}
	
		if (this instanceof Promise === false) {
			throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
		}
	
		this._then = [];
	
		invokeResolver(resolver, this);
	}
	
	Promise.prototype = {
		constructor: Promise,
	
		_state: PENDING,
		_then: null,
		_data: undefined,
		_handled: false,
	
		then: function (onFulfillment, onRejection) {
			var subscriber = {
				owner: this,
				then: new this.constructor(NOOP),
				fulfilled: onFulfillment,
				rejected: onRejection
			};
	
			if ((onRejection || onFulfillment) && !this._handled) {
				this._handled = true;
				if (this._state === REJECTED && isNode) {
					asyncCall(notifyRejectionHandled, this);
				}
			}
	
			if (this._state === FULFILLED || this._state === REJECTED) {
				// already resolved, call callback async
				asyncCall(invokeCallback, subscriber);
			} else {
				// subscribe
				this._then.push(subscriber);
			}
	
			return subscriber.then;
		},
	
		catch: function (onRejection) {
			return this.then(null, onRejection);
		}
	};
	
	Promise.all = function (promises) {
		if (!Array.isArray(promises)) {
			throw new TypeError('You must pass an array to Promise.all().');
		}
	
		return new Promise(function (resolve, reject) {
			var results = [];
			var remaining = 0;
	
			function resolver(index) {
				remaining++;
				return function (value) {
					results[index] = value;
					if (!--remaining) {
						resolve(results);
					}
				};
			}
	
			for (var i = 0, promise; i < promises.length; i++) {
				promise = promises[i];
	
				if (promise && typeof promise.then === 'function') {
					promise.then(resolver(i), reject);
				} else {
					results[i] = promise;
				}
			}
	
			if (!remaining) {
				resolve(results);
			}
		});
	};
	
	Promise.race = function (promises) {
		if (!Array.isArray(promises)) {
			throw new TypeError('You must pass an array to Promise.race().');
		}
	
		return new Promise(function (resolve, reject) {
			for (var i = 0, promise; i < promises.length; i++) {
				promise = promises[i];
	
				if (promise && typeof promise.then === 'function') {
					promise.then(resolve, reject);
				} else {
					resolve(promise);
				}
			}
		});
	};
	
	Promise.resolve = function (value) {
		if (value && typeof value === 'object' && value.constructor === Promise) {
			return value;
		}
	
		return new Promise(function (resolve) {
			resolve(value);
		});
	};
	
	Promise.reject = function (reason) {
		return new Promise(function (resolve, reject) {
			reject(reason);
		});
	};
	
	module.exports = Promise;


/***/ },
/* 703 */
/*!***************************************!*\
  !*** ./~/har-validator/lib/runner.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var schemas = __webpack_require__(/*! ./schemas */ 704)
	var ValidationError = __webpack_require__(/*! ./error */ 720)
	var validator = __webpack_require__(/*! is-my-json-valid */ 721)
	
	module.exports = function (schema, data, cb) {
	  // default value
	  var valid = false
	
	  // validator config
	  var validate = validator(schema, {
	    greedy: true,
	    verbose: true,
	    schemas: schemas
	  })
	
	  // execute is-my-json-valid
	  if (data !== undefined) {
	    valid = validate(data)
	  }
	
	  // callback?
	  if (typeof cb === 'function') {
	    return cb(validate.errors ? new ValidationError(validate.errors) : null, valid)
	  }
	
	  return valid
	}


/***/ },
/* 704 */
/*!**********************************************!*\
  !*** ./~/har-validator/lib/schemas/index.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var schemas = {
	  cache: __webpack_require__(/*! ./cache.json */ 705),
	  cacheEntry: __webpack_require__(/*! ./cacheEntry.json */ 706),
	  content: __webpack_require__(/*! ./content.json */ 707),
	  cookie: __webpack_require__(/*! ./cookie.json */ 708),
	  creator: __webpack_require__(/*! ./creator.json */ 709),
	  entry: __webpack_require__(/*! ./entry.json */ 710),
	  har: __webpack_require__(/*! ./har.json */ 711),
	  log: __webpack_require__(/*! ./log.json */ 712),
	  page: __webpack_require__(/*! ./page.json */ 713),
	  pageTimings: __webpack_require__(/*! ./pageTimings.json */ 714),
	  postData: __webpack_require__(/*! ./postData.json */ 715),
	  record: __webpack_require__(/*! ./record.json */ 716),
	  request: __webpack_require__(/*! ./request.json */ 717),
	  response: __webpack_require__(/*! ./response.json */ 718),
	  timings: __webpack_require__(/*! ./timings.json */ 719)
	}
	
	// is-my-json-valid does not provide meaningful error messages for external schemas
	// this is a workaround
	schemas.cache.properties.beforeRequest = schemas.cacheEntry
	schemas.cache.properties.afterRequest = schemas.cacheEntry
	
	schemas.page.properties.pageTimings = schemas.pageTimings
	
	schemas.request.properties.cookies.items = schemas.cookie
	schemas.request.properties.headers.items = schemas.record
	schemas.request.properties.queryString.items = schemas.record
	schemas.request.properties.postData = schemas.postData
	
	schemas.response.properties.cookies.items = schemas.cookie
	schemas.response.properties.headers.items = schemas.record
	schemas.response.properties.content = schemas.content
	
	schemas.entry.properties.request = schemas.request
	schemas.entry.properties.response = schemas.response
	schemas.entry.properties.cache = schemas.cache
	schemas.entry.properties.timings = schemas.timings
	
	schemas.log.properties.creator = schemas.creator
	schemas.log.properties.browser = schemas.creator
	schemas.log.properties.pages.items = schemas.page
	schemas.log.properties.entries.items = schemas.entry
	
	schemas.har.properties.log = schemas.log
	
	module.exports = schemas


/***/ },
/* 705 */
/*!************************************************!*\
  !*** ./~/har-validator/lib/schemas/cache.json ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = {
		"properties": {
			"beforeRequest": {
				"$ref": "#cacheEntry"
			},
			"afterRequest": {
				"$ref": "#cacheEntry"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 706 */
/*!*****************************************************!*\
  !*** ./~/har-validator/lib/schemas/cacheEntry.json ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = {
		"oneOf": [
			{
				"type": "object",
				"optional": true,
				"required": [
					"lastAccess",
					"eTag",
					"hitCount"
				],
				"properties": {
					"expires": {
						"type": "string"
					},
					"lastAccess": {
						"type": "string"
					},
					"eTag": {
						"type": "string"
					},
					"hitCount": {
						"type": "integer"
					},
					"comment": {
						"type": "string"
					}
				}
			},
			{
				"type": null,
				"additionalProperties": false
			}
		]
	};

/***/ },
/* 707 */
/*!**************************************************!*\
  !*** ./~/har-validator/lib/schemas/content.json ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"size",
			"mimeType"
		],
		"properties": {
			"size": {
				"type": "integer"
			},
			"compression": {
				"type": "integer"
			},
			"mimeType": {
				"type": "string"
			},
			"text": {
				"type": "string"
			},
			"encoding": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 708 */
/*!*************************************************!*\
  !*** ./~/har-validator/lib/schemas/cookie.json ***!
  \*************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"name",
			"value"
		],
		"properties": {
			"name": {
				"type": "string"
			},
			"value": {
				"type": "string"
			},
			"path": {
				"type": "string"
			},
			"domain": {
				"type": "string"
			},
			"expires": {
				"type": [
					"string",
					"null"
				],
				"format": "date-time"
			},
			"httpOnly": {
				"type": "boolean"
			},
			"secure": {
				"type": "boolean"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 709 */
/*!**************************************************!*\
  !*** ./~/har-validator/lib/schemas/creator.json ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"name",
			"version"
		],
		"properties": {
			"name": {
				"type": "string"
			},
			"version": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 710 */
/*!************************************************!*\
  !*** ./~/har-validator/lib/schemas/entry.json ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"optional": true,
		"required": [
			"startedDateTime",
			"time",
			"request",
			"response",
			"cache",
			"timings"
		],
		"properties": {
			"pageref": {
				"type": "string"
			},
			"startedDateTime": {
				"type": "string",
				"format": "date-time",
				"pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
			},
			"time": {
				"type": "number",
				"min": 0
			},
			"request": {
				"$ref": "#request"
			},
			"response": {
				"$ref": "#response"
			},
			"cache": {
				"$ref": "#cache"
			},
			"timings": {
				"$ref": "#timings"
			},
			"serverIPAddress": {
				"type": "string",
				"oneOf": [
					{
						"format": "ipv4"
					},
					{
						"format": "ipv6"
					}
				]
			},
			"connection": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 711 */
/*!**********************************************!*\
  !*** ./~/har-validator/lib/schemas/har.json ***!
  \**********************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"log"
		],
		"properties": {
			"log": {
				"$ref": "#log"
			}
		}
	};

/***/ },
/* 712 */
/*!**********************************************!*\
  !*** ./~/har-validator/lib/schemas/log.json ***!
  \**********************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"version",
			"creator",
			"entries"
		],
		"properties": {
			"version": {
				"type": "string"
			},
			"creator": {
				"$ref": "#creator"
			},
			"browser": {
				"$ref": "#creator"
			},
			"pages": {
				"type": "array",
				"items": {
					"$ref": "#page"
				}
			},
			"entries": {
				"type": "array",
				"items": {
					"$ref": "#entry"
				}
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 713 */
/*!***********************************************!*\
  !*** ./~/har-validator/lib/schemas/page.json ***!
  \***********************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"optional": true,
		"required": [
			"startedDateTime",
			"id",
			"title",
			"pageTimings"
		],
		"properties": {
			"startedDateTime": {
				"type": "string",
				"format": "date-time",
				"pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
			},
			"id": {
				"type": "string",
				"unique": true
			},
			"title": {
				"type": "string"
			},
			"pageTimings": {
				"$ref": "#pageTimings"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 714 */
/*!******************************************************!*\
  !*** ./~/har-validator/lib/schemas/pageTimings.json ***!
  \******************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"properties": {
			"onContentLoad": {
				"type": "number",
				"min": -1
			},
			"onLoad": {
				"type": "number",
				"min": -1
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 715 */
/*!***************************************************!*\
  !*** ./~/har-validator/lib/schemas/postData.json ***!
  \***************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"optional": true,
		"required": [
			"mimeType"
		],
		"properties": {
			"mimeType": {
				"type": "string"
			},
			"text": {
				"type": "string"
			},
			"params": {
				"type": "array",
				"required": [
					"name"
				],
				"properties": {
					"name": {
						"type": "string"
					},
					"value": {
						"type": "string"
					},
					"fileName": {
						"type": "string"
					},
					"contentType": {
						"type": "string"
					},
					"comment": {
						"type": "string"
					}
				}
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 716 */
/*!*************************************************!*\
  !*** ./~/har-validator/lib/schemas/record.json ***!
  \*************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"name",
			"value"
		],
		"properties": {
			"name": {
				"type": "string"
			},
			"value": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 717 */
/*!**************************************************!*\
  !*** ./~/har-validator/lib/schemas/request.json ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"method",
			"url",
			"httpVersion",
			"cookies",
			"headers",
			"queryString",
			"headersSize",
			"bodySize"
		],
		"properties": {
			"method": {
				"type": "string"
			},
			"url": {
				"type": "string",
				"format": "uri"
			},
			"httpVersion": {
				"type": "string"
			},
			"cookies": {
				"type": "array",
				"items": {
					"$ref": "#cookie"
				}
			},
			"headers": {
				"type": "array",
				"items": {
					"$ref": "#record"
				}
			},
			"queryString": {
				"type": "array",
				"items": {
					"$ref": "#record"
				}
			},
			"postData": {
				"$ref": "#postData"
			},
			"headersSize": {
				"type": "integer"
			},
			"bodySize": {
				"type": "integer"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 718 */
/*!***************************************************!*\
  !*** ./~/har-validator/lib/schemas/response.json ***!
  \***************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"status",
			"statusText",
			"httpVersion",
			"cookies",
			"headers",
			"content",
			"redirectURL",
			"headersSize",
			"bodySize"
		],
		"properties": {
			"status": {
				"type": "integer"
			},
			"statusText": {
				"type": "string"
			},
			"httpVersion": {
				"type": "string"
			},
			"cookies": {
				"type": "array",
				"items": {
					"$ref": "#cookie"
				}
			},
			"headers": {
				"type": "array",
				"items": {
					"$ref": "#record"
				}
			},
			"content": {
				"$ref": "#content"
			},
			"redirectURL": {
				"type": "string"
			},
			"headersSize": {
				"type": "integer"
			},
			"bodySize": {
				"type": "integer"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 719 */
/*!**************************************************!*\
  !*** ./~/har-validator/lib/schemas/timings.json ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = {
		"required": [
			"send",
			"wait",
			"receive"
		],
		"properties": {
			"dns": {
				"type": "number",
				"min": -1
			},
			"connect": {
				"type": "number",
				"min": -1
			},
			"blocked": {
				"type": "number",
				"min": -1
			},
			"send": {
				"type": "number",
				"min": -1
			},
			"wait": {
				"type": "number",
				"min": -1
			},
			"receive": {
				"type": "number",
				"min": -1
			},
			"ssl": {
				"type": "number",
				"min": -1
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 720 */
/*!**************************************!*\
  !*** ./~/har-validator/lib/error.js ***!
  \**************************************/
/***/ function(module, exports) {

	'use strict'
	
	function ValidationError (errors) {
	  this.name = 'ValidationError'
	  this.errors = errors
	}
	
	ValidationError.prototype = Error.prototype
	
	module.exports = ValidationError


/***/ },
/* 721 */
/*!*************************************!*\
  !*** ./~/is-my-json-valid/index.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var genobj = __webpack_require__(/*! generate-object-property */ 722)
	var genfun = __webpack_require__(/*! generate-function */ 724)
	var jsonpointer = __webpack_require__(/*! jsonpointer */ 725)
	var xtend = __webpack_require__(/*! xtend */ 726)
	var formats = __webpack_require__(/*! ./formats */ 732)
	
	var get = function(obj, additionalSchemas, ptr) {
	
	  var visit = function(sub) {
	    if (sub && sub.id === ptr) return sub
	    if (typeof sub !== 'object' || !sub) return null
	    return Object.keys(sub).reduce(function(res, k) {
	      return res || visit(sub[k])
	    }, null)
	  }
	
	  var res = visit(obj)
	  if (res) return res
	
	  ptr = ptr.replace(/^#/, '')
	  ptr = ptr.replace(/\/$/, '')
	
	  try {
	    return jsonpointer.get(obj, decodeURI(ptr))
	  } catch (err) {
	    var end = ptr.indexOf('#')
	    var other
	    // external reference
	    if (end !== 0) {
	      // fragment doesn't exist.
	      if (end === -1) {
	        other = additionalSchemas[ptr]
	      } else {
	        var ext = ptr.slice(0, end)
	        other = additionalSchemas[ext]
	        var fragment = ptr.slice(end).replace(/^#/, '')
	        try {
	          return jsonpointer.get(other, fragment)
	        } catch (err) {}
	      }
	    } else {
	      other = additionalSchemas[ptr]
	    }
	    return other || null
	  }
	}
	
	var formatName = function(field) {
	  field = JSON.stringify(field)
	  var pattern = /\[([^\[\]"]+)\]/
	  while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
	  return field
	}
	
	var types = {}
	
	types.any = function() {
	  return 'true'
	}
	
	types.null = function(name) {
	  return name+' === null'
	}
	
	types.boolean = function(name) {
	  return 'typeof '+name+' === "boolean"'
	}
	
	types.array = function(name) {
	  return 'Array.isArray('+name+')'
	}
	
	types.object = function(name) {
	  return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
	}
	
	types.number = function(name) {
	  return 'typeof '+name+' === "number"'
	}
	
	types.integer = function(name) {
	  return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
	}
	
	types.string = function(name) {
	  return 'typeof '+name+' === "string"'
	}
	
	var unique = function(array) {
	  var list = []
	  for (var i = 0; i < array.length; i++) {
	    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
	  }
	  for (var i = 1; i < list.length; i++) {
	    if (list.indexOf(list[i]) !== i) return false
	  }
	  return true
	}
	
	var isMultipleOf = function(name, multipleOf) {
	  var res;
	  var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1
	  if (factor > 1) {
	    var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1
	    if (factorName > factor) res = true
	    else res = Math.round(factor * name) % (factor * multipleOf)
	  }
	  else res = name % multipleOf;
	  return !res;
	}
	
	var toType = function(node) {
	  return node.type
	}
	
	var compile = function(schema, cache, root, reporter, opts) {
	  var fmts = opts ? xtend(formats, opts.formats) : formats
	  var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf}
	  var verbose = opts ? !!opts.verbose : false;
	  var greedy = opts && opts.greedy !== undefined ?
	    opts.greedy : false;
	
	  var syms = {}
	  var gensym = function(name) {
	    return name+(syms[name] = (syms[name] || 0)+1)
	  }
	
	  var reversePatterns = {}
	  var patterns = function(p) {
	    if (reversePatterns[p]) return reversePatterns[p]
	    var n = gensym('pattern')
	    scope[n] = new RegExp(p)
	    reversePatterns[p] = n
	    return n
	  }
	
	  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
	  var genloop = function() {
	    var v = vars.shift()
	    vars.push(v+v[0])
	    return v
	  }
	
	  var visit = function(name, node, reporter, filter) {
	    var properties = node.properties
	    var type = node.type
	    var tuple = false
	
	    if (Array.isArray(node.items)) { // tuple type
	      properties = {}
	      node.items.forEach(function(item, i) {
	        properties[i] = item
	      })
	      type = 'array'
	      tuple = true
	    }
	
	    var indent = 0
	    var error = function(msg, prop, value) {
	      validate('errors++')
	      if (reporter === true) {
	        validate('if (validate.errors === null) validate.errors = []')
	        if (verbose) {
	          validate('validate.errors.push({field:%s,message:%s,value:%s,type:%s})', formatName(prop || name), JSON.stringify(msg), value || name, JSON.stringify(type))
	        } else {
	          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
	        }
	      }
	    }
	
	    if (node.required === true) {
	      indent++
	      validate('if (%s === undefined) {', name)
	      error('is required')
	      validate('} else {')
	    } else {
	      indent++
	      validate('if (%s !== undefined) {', name)
	    }
	
	    var valid = [].concat(type)
	      .map(function(t) {
	        return types[t || 'any'](name)
	      })
	      .join(' || ') || 'true'
	
	    if (valid !== 'true') {
	      indent++
	      validate('if (!(%s)) {', valid)
	      error('is the wrong type')
	      validate('} else {')
	    }
	
	    if (tuple) {
	      if (node.additionalItems === false) {
	        validate('if (%s.length > %d) {', name, node.items.length)
	        error('has additional items')
	        validate('}')
	      } else if (node.additionalItems) {
	        var i = genloop()
	        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
	        visit(name+'['+i+']', node.additionalItems, reporter, filter)
	        validate('}')
	      }
	    }
	
	    if (node.format && fmts[node.format]) {
	      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
	      var n = gensym('format')
	      scope[n] = fmts[node.format]
	
	      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
	      else validate('if (!%s.test(%s)) {', n, name)
	      error('must be '+node.format+' format')
	      validate('}')
	      if (type !== 'string' && formats[node.format]) validate('}')
	    }
	
	    if (Array.isArray(node.required)) {
	      var isUndefined = function(req) {
	        return genobj(name, req) + ' === undefined'
	      }
	
	      var checkRequired = function (req) {
	        var prop = genobj(name, req);
	        validate('if (%s === undefined) {', prop)
	        error('is required', prop)
	        validate('missing++')
	        validate('}')
	      }
	      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
	      validate('var missing = 0')
	      node.required.map(checkRequired)
	      validate('}');
	      if (!greedy) {
	        validate('if (missing === 0) {')
	        indent++
	      }
	    }
	
	    if (node.uniqueItems) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	      validate('if (!(unique(%s))) {', name)
	      error('must be unique')
	      validate('}')
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.enum) {
	      var complex = node.enum.some(function(e) {
	        return typeof e === 'object'
	      })
	
	      var compare = complex ?
	        function(e) {
	          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
	        } :
	        function(e) {
	          return name+' !== '+JSON.stringify(e)
	        }
	
	      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
	      error('must be an enum value')
	      validate('}')
	    }
	
	    if (node.dependencies) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      Object.keys(node.dependencies).forEach(function(key) {
	        var deps = node.dependencies[key]
	        if (typeof deps === 'string') deps = [deps]
	
	        var exists = function(k) {
	          return genobj(name, k) + ' !== undefined'
	        }
	
	        if (Array.isArray(deps)) {
	          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
	          error('dependencies not set')
	          validate('}')
	        }
	        if (typeof deps === 'object') {
	          validate('if (%s !== undefined) {', genobj(name, key))
	          visit(name, deps, reporter, filter)
	          validate('}')
	        }
	      })
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.additionalProperties || node.additionalProperties === false) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      var i = genloop()
	      var keys = gensym('keys')
	
	      var toCompare = function(p) {
	        return keys+'['+i+'] !== '+JSON.stringify(p)
	      }
	
	      var toTest = function(p) {
	        return '!'+patterns(p)+'.test('+keys+'['+i+'])'
	      }
	
	      var additionalProp = Object.keys(properties || {}).map(toCompare)
	        .concat(Object.keys(node.patternProperties || {}).map(toTest))
	        .join(' && ') || 'true'
	
	      validate('var %s = Object.keys(%s)', keys, name)
	        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
	          ('if (%s) {', additionalProp)
	
	      if (node.additionalProperties === false) {
	        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
	        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
	      } else {
	        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
	      }
	
	      validate
	          ('}')
	        ('}')
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.$ref) {
	      var sub = get(root, opts && opts.schemas || {}, node.$ref)
	      if (sub) {
	        var fn = cache[node.$ref]
	        if (!fn) {
	          cache[node.$ref] = function proxy(data) {
	            return fn(data)
	          }
	          fn = compile(sub, cache, root, false, opts)
	        }
	        var n = gensym('ref')
	        scope[n] = fn
	        validate('if (!(%s(%s))) {', n, name)
	        error('referenced schema does not match')
	        validate('}')
	      }
	    }
	
	    if (node.not) {
	      var prev = gensym('prev')
	      validate('var %s = errors', prev)
	      visit(name, node.not, false, filter)
	      validate('if (%s === errors) {', prev)
	      error('negative schema matches')
	      validate('} else {')
	        ('errors = %s', prev)
	      ('}')
	    }
	
	    if (node.items && !tuple) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	
	      var i = genloop()
	      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
	      visit(name+'['+i+']', node.items, reporter, filter)
	      validate('}')
	
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.patternProperties) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	      var keys = gensym('keys')
	      var i = genloop()
	      validate
	        ('var %s = Object.keys(%s)', keys, name)
	        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
	
	      Object.keys(node.patternProperties).forEach(function(key) {
	        var p = patterns(key)
	        validate('if (%s.test(%s)) {', p, keys+'['+i+']')
	        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
	        validate('}')
	      })
	
	      validate('}')
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.pattern) {
	      var p = patterns(node.pattern)
	      if (type !== 'string') validate('if (%s) {', types.string(name))
	      validate('if (!(%s.test(%s))) {', p, name)
	      error('pattern mismatch')
	      validate('}')
	      if (type !== 'string') validate('}')
	    }
	
	    if (node.allOf) {
	      node.allOf.forEach(function(sch) {
	        visit(name, sch, reporter, filter)
	      })
	    }
	
	    if (node.anyOf && node.anyOf.length) {
	      var prev = gensym('prev')
	
	      node.anyOf.forEach(function(sch, i) {
	        if (i === 0) {
	          validate('var %s = errors', prev)
	        } else {
	          validate('if (errors !== %s) {', prev)
	            ('errors = %s', prev)
	        }
	        visit(name, sch, false, false)
	      })
	      node.anyOf.forEach(function(sch, i) {
	        if (i) validate('}')
	      })
	      validate('if (%s !== errors) {', prev)
	      error('no schemas match')
	      validate('}')
	    }
	
	    if (node.oneOf && node.oneOf.length) {
	      var prev = gensym('prev')
	      var passes = gensym('passes')
	
	      validate
	        ('var %s = errors', prev)
	        ('var %s = 0', passes)
	
	      node.oneOf.forEach(function(sch, i) {
	        visit(name, sch, false, false)
	        validate('if (%s === errors) {', prev)
	          ('%s++', passes)
	        ('} else {')
	          ('errors = %s', prev)
	        ('}')
	      })
	
	      validate('if (%s !== 1) {', passes)
	      error('no (or more than one) schemas match')
	      validate('}')
	    }
	
	    if (node.multipleOf !== undefined) {
	      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))
	
	      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)
	
	      error('has a remainder')
	      validate('}')
	
	      if (type !== 'number' && type !== 'integer') validate('}')
	    }
	
	    if (node.maxProperties !== undefined) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
	      error('has more properties than allowed')
	      validate('}')
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.minProperties !== undefined) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
	      error('has less properties than allowed')
	      validate('}')
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.maxItems !== undefined) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	
	      validate('if (%s.length > %d) {', name, node.maxItems)
	      error('has more items than allowed')
	      validate('}')
	
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.minItems !== undefined) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	
	      validate('if (%s.length < %d) {', name, node.minItems)
	      error('has less items than allowed')
	      validate('}')
	
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.maxLength !== undefined) {
	      if (type !== 'string') validate('if (%s) {', types.string(name))
	
	      validate('if (%s.length > %d) {', name, node.maxLength)
	      error('has longer length than allowed')
	      validate('}')
	
	      if (type !== 'string') validate('}')
	    }
	
	    if (node.minLength !== undefined) {
	      if (type !== 'string') validate('if (%s) {', types.string(name))
	
	      validate('if (%s.length < %d) {', name, node.minLength)
	      error('has less length than allowed')
	      validate('}')
	
	      if (type !== 'string') validate('}')
	    }
	
	    if (node.minimum !== undefined) {
	      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
	      error('is less than minimum')
	      validate('}')
	    }
	
	    if (node.maximum !== undefined) {
	      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
	      error('is more than maximum')
	      validate('}')
	    }
	
	    if (properties) {
	      Object.keys(properties).forEach(function(p) {
	        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)
	
	        visit(genobj(name, p), properties[p], reporter, filter)
	
	        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')
	      })
	    }
	
	    while (indent--) validate('}')
	  }
	
	  var validate = genfun
	    ('function validate(data) {')
	      ('validate.errors = null')
	      ('var errors = 0')
	
	  visit('data', schema, reporter, opts && opts.filter)
	
	  validate
	      ('return errors === 0')
	    ('}')
	
	  validate = validate.toFunction(scope)
	  validate.errors = null
	
	  if (Object.defineProperty) {
	    Object.defineProperty(validate, 'error', {
	      get: function() {
	        if (!validate.errors) return ''
	        return validate.errors.map(function(err) {
	          return err.field + ' ' + err.message;
	        }).join('\n')
	      }
	    })
	  }
	
	  validate.toJSON = function() {
	    return schema
	  }
	
	  return validate
	}
	
	module.exports = function(schema, opts) {
	  if (typeof schema === 'string') schema = JSON.parse(schema)
	  return compile(schema, {}, schema, true, opts)
	}
	
	module.exports.filter = function(schema, opts) {
	  var validate = module.exports(schema, xtend(opts, {filter: true}))
	  return function(sch) {
	    validate(sch)
	    return sch
	  }
	}


/***/ },
/* 722 */
/*!*********************************************!*\
  !*** ./~/generate-object-property/index.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var isProperty = __webpack_require__(/*! is-property */ 723)
	
	var gen = function(obj, prop) {
	  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
	}
	
	gen.valid = isProperty
	gen.property = function (prop) {
	 return isProperty(prop) ? prop : JSON.stringify(prop)
	}
	
	module.exports = gen


/***/ },
/* 723 */
/*!**************************************!*\
  !*** ./~/is-property/is-property.js ***!
  \**************************************/
/***/ function(module, exports) {

	"use strict"
	function isProperty(str) {
	  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
	}
	module.exports = isProperty

/***/ },
/* 724 */
/*!**************************************!*\
  !*** ./~/generate-function/index.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(/*! util */ 597)
	
	var INDENT_START = /[\{\[]/
	var INDENT_END = /[\}\]]/
	
	module.exports = function() {
	  var lines = []
	  var indent = 0
	
	  var push = function(str) {
	    var spaces = ''
	    while (spaces.length < indent*2) spaces += '  '
	    lines.push(spaces+str)
	  }
	
	  var line = function(fmt) {
	    if (!fmt) return line
	
	    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_START.test(fmt[fmt.length-1])) {
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_END.test(fmt.trim()[0])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      return line
	    }
	
	    push(util.format.apply(util, arguments))
	    return line
	  }
	
	  line.toString = function() {
	    return lines.join('\n')
	  }
	
	  line.toFunction = function(scope) {
	    var src = 'return ('+line.toString()+')'
	
	    var keys = Object.keys(scope || {}).map(function(key) {
	      return key
	    })
	
	    var vals = keys.map(function(key) {
	      return scope[key]
	    })
	
	    return Function.apply(null, keys.concat(src)).apply(null, vals)
	  }
	
	  if (arguments.length) line.apply(null, arguments)
	
	  return line
	}


/***/ },
/* 725 */
/*!**************************************!*\
  !*** ./~/jsonpointer/jsonpointer.js ***!
  \**************************************/
/***/ function(module, exports) {

	var untilde = function(str) {
	  return str.replace(/~./g, function(m) {
	    switch (m) {
	      case "~0":
	        return "~";
	      case "~1":
	        return "/";
	    }
	    throw new Error("Invalid tilde escape: " + m);
	  });
	}
	
	var traverse = function(obj, pointer, value) {
	  // assert(isArray(pointer))
	  var part = untilde(pointer.shift());
	  if(!obj.hasOwnProperty(part)) {
	    return null;
	  }
	  if(pointer.length !== 0) { // keep traversin!
	    return traverse(obj[part], pointer, value);
	  }
	  // we're done
	  if(typeof value === "undefined") {
	    // just reading
	    return obj[part];
	  }
	  // set new value, return old value
	  var old_value = obj[part];
	  if(value === null) {
	    delete obj[part];
	  } else {
	    obj[part] = value;
	  }
	  return old_value;
	}
	
	var validate_input = function(obj, pointer) {
	  if(typeof obj !== "object") {
	    throw new Error("Invalid input object.");
	  }
	
	  if(pointer === "") {
	    return [];
	  }
	
	  if(!pointer) {
	    throw new Error("Invalid JSON pointer.");
	  }
	
	  pointer = pointer.split("/");
	  var first = pointer.shift();
	  if (first !== "") {
	    throw new Error("Invalid JSON pointer.");
	  }
	
	  return pointer;
	}
	
	var get = function(obj, pointer) {
	  pointer = validate_input(obj, pointer);
	  if (pointer.length === 0) {
	    return obj;
	  }
	  return traverse(obj, pointer);
	}
	
	var set = function(obj, pointer, value) {
	  pointer = validate_input(obj, pointer);
	  if (pointer.length === 0) {
	    throw new Error("Invalid JSON pointer for set.")
	  }
	  return traverse(obj, pointer, value);
	}
	
	exports.get = get
	exports.set = set


/***/ },
/* 726 */
/*!**************************!*\
  !*** ./~/xtend/index.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	var Keys = __webpack_require__(/*! object-keys */ 727)
	var hasKeys = __webpack_require__(/*! ./has-keys */ 731)
	
	module.exports = extend
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        if (!hasKeys(source)) {
	            continue
	        }
	
	        var keys = Keys(source)
	
	        for (var j = 0; j < keys.length; j++) {
	            var name = keys[j]
	            target[name] = source[name]
	        }
	    }
	
	    return target
	}


/***/ },
/* 727 */
/*!********************************!*\
  !*** ./~/object-keys/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = Object.keys || __webpack_require__(/*! ./shim */ 728);
	


/***/ },
/* 728 */
/*!*******************************!*\
  !*** ./~/object-keys/shim.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	(function () {
		"use strict";
	
		// modified from https://github.com/kriskowal/es5-shim
		var has = Object.prototype.hasOwnProperty,
			toString = Object.prototype.toString,
			forEach = __webpack_require__(/*! ./foreach */ 729),
			isArgs = __webpack_require__(/*! ./isArguments */ 730),
			hasDontEnumBug = !({'toString': null}).propertyIsEnumerable('toString'),
			hasProtoEnumBug = (function () {}).propertyIsEnumerable('prototype'),
			dontEnums = [
				"toString",
				"toLocaleString",
				"valueOf",
				"hasOwnProperty",
				"isPrototypeOf",
				"propertyIsEnumerable",
				"constructor"
			],
			keysShim;
	
		keysShim = function keys(object) {
			var isObject = object !== null && typeof object === 'object',
				isFunction = toString.call(object) === '[object Function]',
				isArguments = isArgs(object),
				theKeys = [];
	
			if (!isObject && !isFunction && !isArguments) {
				throw new TypeError("Object.keys called on a non-object");
			}
	
			if (isArguments) {
				forEach(object, function (value) {
					theKeys.push(value);
				});
			} else {
				var name,
					skipProto = hasProtoEnumBug && isFunction;
	
				for (name in object) {
					if (!(skipProto && name === 'prototype') && has.call(object, name)) {
						theKeys.push(name);
					}
				}
			}
	
			if (hasDontEnumBug) {
				var ctor = object.constructor,
					skipConstructor = ctor && ctor.prototype === object;
	
				forEach(dontEnums, function (dontEnum) {
					if (!(skipConstructor && dontEnum === 'constructor') && has.call(object, dontEnum)) {
						theKeys.push(dontEnum);
					}
				});
			}
			return theKeys;
		};
	
		module.exports = keysShim;
	}());
	


/***/ },
/* 729 */
/*!**********************************!*\
  !*** ./~/object-keys/foreach.js ***!
  \**********************************/
/***/ function(module, exports) {

	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	
	var isFunction = function (fn) {
		var isFunc = (typeof fn === 'function' && !(fn instanceof RegExp)) || toString.call(fn) === '[object Function]';
		if (!isFunc && typeof window !== 'undefined') {
			isFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;
		}
		return isFunc;
	};
	
	module.exports = function forEach(obj, fn) {
		if (!isFunction(fn)) {
			throw new TypeError('iterator must be a function');
		}
		var i, k,
			isString = typeof obj === 'string',
			l = obj.length,
			context = arguments.length > 2 ? arguments[2] : null;
		if (l === +l) {
			for (i = 0; i < l; i++) {
				if (context === null) {
					fn(isString ? obj.charAt(i) : obj[i], i, obj);
				} else {
					fn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);
				}
			}
		} else {
			for (k in obj) {
				if (hasOwn.call(obj, k)) {
					if (context === null) {
						fn(obj[k], k, obj);
					} else {
						fn.call(context, obj[k], k, obj);
					}
				}
			}
		}
	};
	


/***/ },
/* 730 */
/*!**************************************!*\
  !*** ./~/object-keys/isArguments.js ***!
  \**************************************/
/***/ function(module, exports) {

	var toString = Object.prototype.toString;
	
	module.exports = function isArguments(value) {
		var str = toString.call(value);
		var isArguments = str === '[object Arguments]';
		if (!isArguments) {
			isArguments = str !== '[object Array]'
				&& value !== null
				&& typeof value === 'object'
				&& typeof value.length === 'number'
				&& value.length >= 0
				&& toString.call(value.callee) === '[object Function]';
		}
		return isArguments;
	};
	


/***/ },
/* 731 */
/*!*****************************!*\
  !*** ./~/xtend/has-keys.js ***!
  \*****************************/
/***/ function(module, exports) {

	module.exports = hasKeys
	
	function hasKeys(source) {
	    return source !== null &&
	        (typeof source === "object" ||
	        typeof source === "function")
	}


/***/ },
/* 732 */
/*!***************************************!*\
  !*** ./~/is-my-json-valid/formats.js ***!
  \***************************************/
/***/ function(module, exports) {

	exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
	exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
	exports['time'] = /^\d{2}:\d{2}:\d{2}$/
	exports['email'] = /^\S+@\S+$/
	exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
	exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
	exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
	exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
	exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
	exports['alpha'] = /^[a-zA-Z]+$/
	exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
	exports['style'] = /\s*(.+?):\s*([^;]+);?/g
	exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
	exports['utc-millisec'] = /^[0-9]{1,15}\.?[0-9]{0,15}$/


/***/ },
/* 733 */
/*!*******************************!*\
  !*** ./~/request/lib/auth.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var caseless = __webpack_require__(/*! caseless */ 683)
	  , uuid = __webpack_require__(/*! node-uuid */ 734)
	  , helpers = __webpack_require__(/*! ./helpers */ 599)
	
	var md5 = helpers.md5
	  , toBase64 = helpers.toBase64
	
	
	function Auth (request) {
	  // define all public properties here
	  this.request = request
	  this.hasAuth = false
	  this.sentAuth = false
	  this.bearerToken = null
	  this.user = null
	  this.pass = null
	}
	
	Auth.prototype.basic = function (user, pass, sendImmediately) {
	  var self = this
	  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
	    self.request.emit('error', new Error('auth() received invalid user or password'))
	  }
	  self.user = user
	  self.pass = pass
	  self.hasAuth = true
	  var header = user + ':' + (pass || '')
	  if (sendImmediately || typeof sendImmediately === 'undefined') {
	    var authHeader = 'Basic ' + toBase64(header)
	    self.sentAuth = true
	    return authHeader
	  }
	}
	
	Auth.prototype.bearer = function (bearer, sendImmediately) {
	  var self = this
	  self.bearerToken = bearer
	  self.hasAuth = true
	  if (sendImmediately || typeof sendImmediately === 'undefined') {
	    if (typeof bearer === 'function') {
	      bearer = bearer()
	    }
	    var authHeader = 'Bearer ' + (bearer || '')
	    self.sentAuth = true
	    return authHeader
	  }
	}
	
	Auth.prototype.digest = function (method, path, authHeader) {
	  // TODO: More complete implementation of RFC 2617.
	  //   - handle challenge.domain
	  //   - support qop="auth-int" only
	  //   - handle Authentication-Info (not necessarily?)
	  //   - check challenge.stale (not necessarily?)
	  //   - increase nc (not necessarily?)
	  // For reference:
	  // http://tools.ietf.org/html/rfc2617#section-3
	  // https://github.com/bagder/curl/blob/master/lib/http_digest.c
	
	  var self = this
	
	  var challenge = {}
	  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi
	  for (;;) {
	    var match = re.exec(authHeader)
	    if (!match) {
	      break
	    }
	    challenge[match[1]] = match[2] || match[3]
	  }
	
	  /**
	   * RFC 2617: handle both MD5 and MD5-sess algorithms.
	   *
	   * If the algorithm directive's value is "MD5" or unspecified, then HA1 is
	   *   HA1=MD5(username:realm:password)
	   * If the algorithm directive's value is "MD5-sess", then HA1 is
	   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)
	   */
	  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {
	    var ha1 = md5(user + ':' + realm + ':' + pass)
	    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {
	      return md5(ha1 + ':' + nonce + ':' + cnonce)
	    } else {
	      return ha1
	    }
	  }
	
	  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth'
	  var nc = qop && '00000001'
	  var cnonce = qop && uuid().replace(/-/g, '')
	  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)
	  var ha2 = md5(method + ':' + path)
	  var digestResponse = qop
	    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
	    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)
	  var authValues = {
	    username: self.user,
	    realm: challenge.realm,
	    nonce: challenge.nonce,
	    uri: path,
	    qop: qop,
	    response: digestResponse,
	    nc: nc,
	    cnonce: cnonce,
	    algorithm: challenge.algorithm,
	    opaque: challenge.opaque
	  }
	
	  authHeader = []
	  for (var k in authValues) {
	    if (authValues[k]) {
	      if (k === 'qop' || k === 'nc' || k === 'algorithm') {
	        authHeader.push(k + '=' + authValues[k])
	      } else {
	        authHeader.push(k + '="' + authValues[k] + '"')
	      }
	    }
	  }
	  authHeader = 'Digest ' + authHeader.join(', ')
	  self.sentAuth = true
	  return authHeader
	}
	
	Auth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {
	  var self = this
	    , request = self.request
	
	  var authHeader
	  if (bearer === undefined && user === undefined) {
	    self.request.emit('error', new Error('no auth mechanism defined'))
	  } else if (bearer !== undefined) {
	    authHeader = self.bearer(bearer, sendImmediately)
	  } else {
	    authHeader = self.basic(user, pass, sendImmediately)
	  }
	  if (authHeader) {
	    request.setHeader('authorization', authHeader)
	  }
	}
	
	Auth.prototype.onResponse = function (response) {
	  var self = this
	    , request = self.request
	
	  if (!self.hasAuth || self.sentAuth) { return null }
	
	  var c = caseless(response.headers)
	
	  var authHeader = c.get('www-authenticate')
	  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()
	  request.debug('reauth', authVerb)
	
	  switch (authVerb) {
	    case 'basic':
	      return self.basic(self.user, self.pass, true)
	
	    case 'bearer':
	      return self.bearer(self.bearerToken, true)
	
	    case 'digest':
	      return self.digest(request.method, request.path, authHeader)
	  }
	}
	
	exports.Auth = Auth


/***/ },
/* 734 */
/*!*****************************!*\
  !*** ./~/node-uuid/uuid.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php
	
	/*global window, require, define */
	(function(_window) {
	  'use strict';
	
	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;
	
	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;
	
	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }
	
	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }
	
	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }
	
	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(/*! crypto */ 601).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }
	
	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }
	
	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;
	
	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }
	
	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;
	
	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });
	
	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }
	
	    return buf;
	  }
	
	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }
	
	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html
	
	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();
	
	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];
	
	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
	
	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];
	
	    options = options || {};
	
	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;
	
	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();
	
	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;
	
	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
	
	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }
	
	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }
	
	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }
	
	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;
	
	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;
	
	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;
	
	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;
	
	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;
	
	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;
	
	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;
	
	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }
	
	    return buf ? buf : unparse(b);
	  }
	
	  // **`v4()` - Generate random UUID**
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;
	
	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};
	
	    var rnds = options.random || (options.rng || _rng)();
	
	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;
	
	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }
	
	    return buf || unparse(rnds);
	  }
	
	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;
	
	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	
	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;
	
	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };
	
	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);


/***/ },
/* 735 */
/*!********************************!*\
  !*** ./~/request/lib/oauth.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var url = __webpack_require__(/*! url */ 534)
	  , qs = __webpack_require__(/*! qs */ 695)
	  , caseless = __webpack_require__(/*! caseless */ 683)
	  , uuid = __webpack_require__(/*! node-uuid */ 734)
	  , oauth = __webpack_require__(/*! oauth-sign */ 736)
	  , crypto = __webpack_require__(/*! crypto */ 601)
	
	
	function OAuth (request) {
	  this.request = request
	  this.params = null
	}
	
	OAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {
	  var oa = {}
	  for (var i in _oauth) {
	    oa['oauth_' + i] = _oauth[i]
	  }
	  if (!oa.oauth_version) {
	    oa.oauth_version = '1.0'
	  }
	  if (!oa.oauth_timestamp) {
	    oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()
	  }
	  if (!oa.oauth_nonce) {
	    oa.oauth_nonce = uuid().replace(/-/g, '')
	  }
	  if (!oa.oauth_signature_method) {
	    oa.oauth_signature_method = 'HMAC-SHA1'
	  }
	
	  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key
	  delete oa.oauth_consumer_secret
	  delete oa.oauth_private_key
	
	  var token_secret = oa.oauth_token_secret
	  delete oa.oauth_token_secret
	
	  var realm = oa.oauth_realm
	  delete oa.oauth_realm
	  delete oa.oauth_transport_method
	
	  var baseurl = uri.protocol + '//' + uri.host + uri.pathname
	  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))
	
	  oa.oauth_signature = oauth.sign(
	    oa.oauth_signature_method,
	    method,
	    baseurl,
	    params,
	    consumer_secret_or_private_key,
	    token_secret)
	
	  if (realm) {
	    oa.realm = realm
	  }
	
	  return oa
	}
	
	OAuth.prototype.buildBodyHash = function(_oauth, body) {
	  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {
	    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +
	      ' signature_method not supported with body_hash signing.'))
	  }
	
	  var shasum = crypto.createHash('sha1')
	  shasum.update(body || '')
	  var sha1 = shasum.digest('hex')
	
	  return new Buffer(sha1).toString('base64')
	}
	
	OAuth.prototype.concatParams = function (oa, sep, wrap) {
	  wrap = wrap || ''
	
	  var params = Object.keys(oa).filter(function (i) {
	    return i !== 'realm' && i !== 'oauth_signature'
	  }).sort()
	
	  if (oa.realm) {
	    params.splice(0, 0, 'realm')
	  }
	  params.push('oauth_signature')
	
	  return params.map(function (i) {
	    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap
	  }).join(sep)
	}
	
	OAuth.prototype.onRequest = function (_oauth) {
	  var self = this
	  self.params = _oauth
	
	  var uri = self.request.uri || {}
	    , method = self.request.method || ''
	    , headers = caseless(self.request.headers)
	    , body = self.request.body || ''
	    , qsLib = self.request.qsLib || qs
	
	  var form
	    , query
	    , contentType = headers.get('content-type') || ''
	    , formContentType = 'application/x-www-form-urlencoded'
	    , transport = _oauth.transport_method || 'header'
	
	  if (contentType.slice(0, formContentType.length) === formContentType) {
	    contentType = formContentType
	    form = body
	  }
	  if (uri.query) {
	    query = uri.query
	  }
	  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {
	    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +
	      'and content-type ' + formContentType))
	  }
	
	  if (!form && typeof _oauth.body_hash === 'boolean') {
	    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())
	  }
	
	  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)
	
	  switch (transport) {
	    case 'header':
	      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '"'))
	      break
	
	    case 'query':
	      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')
	      self.request.uri = url.parse(href)
	      self.request.path = self.request.uri.path
	      break
	
	    case 'body':
	      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')
	      break
	
	    default:
	      self.request.emit('error', new Error('oauth: transport_method invalid'))
	  }
	}
	
	exports.OAuth = OAuth


/***/ },
/* 736 */
/*!*******************************!*\
  !*** ./~/oauth-sign/index.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(/*! crypto */ 601)
	  , qs = __webpack_require__(/*! querystring */ 540)
	  ;
	
	function sha1 (key, body) {
	  return crypto.createHmac('sha1', key).update(body).digest('base64')
	}
	
	function rsa (key, body) {
	  return crypto.createSign("RSA-SHA1").update(body).sign(key, 'base64');
	}
	
	function rfc3986 (str) {
	  return encodeURIComponent(str)
	    .replace(/!/g,'%21')
	    .replace(/\*/g,'%2A')
	    .replace(/\(/g,'%28')
	    .replace(/\)/g,'%29')
	    .replace(/'/g,'%27')
	    ;
	}
	
	// Maps object to bi-dimensional array
	// Converts { foo: 'A', bar: [ 'b', 'B' ]} to
	// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
	function map (obj) {
	  var key, val, arr = []
	  for (key in obj) {
	    val = obj[key]
	    if (Array.isArray(val))
	      for (var i = 0; i < val.length; i++)
	        arr.push([key, val[i]])
	    else if (typeof val === "object")
	      for (var prop in val)
	        arr.push([key + '[' + prop + ']', val[prop]]);
	    else
	      arr.push([key, val])
	  }
	  return arr
	}
	
	// Compare function for sort
	function compare (a, b) {
	  return a > b ? 1 : a < b ? -1 : 0
	}
	
	function generateBase (httpMethod, base_uri, params) {
	  // adapted from https://dev.twitter.com/docs/auth/oauth and 
	  // https://dev.twitter.com/docs/auth/creating-signature
	
	  // Parameter normalization
	  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
	  var normalized = map(params)
	  // 1.  First, the name and value of each parameter are encoded
	  .map(function (p) {
	    return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
	  })
	  // 2.  The parameters are sorted by name, using ascending byte value
	  //     ordering.  If two or more parameters share the same name, they
	  //     are sorted by their value.
	  .sort(function (a, b) {
	    return compare(a[0], b[0]) || compare(a[1], b[1])
	  })
	  // 3.  The name of each parameter is concatenated to its corresponding
	  //     value using an "=" character (ASCII code 61) as a separator, even
	  //     if the value is empty.
	  .map(function (p) { return p.join('=') })
	   // 4.  The sorted name/value pairs are concatenated together into a
	   //     single string by using an "&" character (ASCII code 38) as
	   //     separator.
	  .join('&')
	
	  var base = [
	    rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
	    rfc3986(base_uri),
	    rfc3986(normalized)
	  ].join('&')
	
	  return base
	}
	
	function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
	  var base = generateBase(httpMethod, base_uri, params)
	  var key = [
	    consumer_secret || '',
	    token_secret || ''
	  ].map(rfc3986).join('&')
	
	  return sha1(key, base)
	}
	
	function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
	  var base = generateBase(httpMethod, base_uri, params)
	  var key = private_key || ''
	
	  return rsa(key, base)
	}
	
	function plaintext (consumer_secret, token_secret) {
	  var key = [
	    consumer_secret || '',
	    token_secret || ''
	  ].map(rfc3986).join('&')
	
	  return key
	}
	
	function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
	  var method
	  var skipArgs = 1
	
	  switch (signMethod) {
	    case 'RSA-SHA1':
	      method = rsasign
	      break
	    case 'HMAC-SHA1':
	      method = hmacsign
	      break
	    case 'PLAINTEXT':
	      method = plaintext
	      skipArgs = 4
	      break
	    default:
	     throw new Error("Signature method not supported: " + signMethod)
	  }
	
	  return method.apply(null, [].slice.call(arguments, skipArgs))
	}
	
	exports.hmacsign = hmacsign
	exports.rsasign = rsasign
	exports.plaintext = plaintext
	exports.sign = sign
	exports.rfc3986 = rfc3986
	exports.generateBase = generateBase
	


/***/ },
/* 737 */
/*!************************************!*\
  !*** ./~/request/lib/multipart.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var uuid = __webpack_require__(/*! node-uuid */ 734)
	  , CombinedStream = __webpack_require__(/*! combined-stream */ 687)
	  , isstream = __webpack_require__(/*! isstream */ 691)
	
	
	function Multipart (request) {
	  this.request = request
	  this.boundary = uuid()
	  this.chunked = false
	  this.body = null
	}
	
	Multipart.prototype.isChunked = function (options) {
	  var self = this
	    , chunked = false
	    , parts = options.data || options
	
	  if (!parts.forEach) {
	    self.request.emit('error', new Error('Argument error, options.multipart.'))
	  }
	
	  if (options.chunked !== undefined) {
	    chunked = options.chunked
	  }
	
	  if (self.request.getHeader('transfer-encoding') === 'chunked') {
	    chunked = true
	  }
	
	  if (!chunked) {
	    parts.forEach(function (part) {
	      if (typeof part.body === 'undefined') {
	        self.request.emit('error', new Error('Body attribute missing in multipart.'))
	      }
	      if (isstream(part.body)) {
	        chunked = true
	      }
	    })
	  }
	
	  return chunked
	}
	
	Multipart.prototype.setHeaders = function (chunked) {
	  var self = this
	
	  if (chunked && !self.request.hasHeader('transfer-encoding')) {
	    self.request.setHeader('transfer-encoding', 'chunked')
	  }
	
	  var header = self.request.getHeader('content-type')
	
	  if (!header || header.indexOf('multipart') === -1) {
	    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)
	  } else {
	    if (header.indexOf('boundary') !== -1) {
	      self.boundary = header.replace(/.*boundary=([^\s;]+).*/, '$1')
	    } else {
	      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)
	    }
	  }
	}
	
	Multipart.prototype.build = function (parts, chunked) {
	  var self = this
	  var body = chunked ? new CombinedStream() : []
	
	  function add (part) {
	    if (typeof part === 'number') {
	      part = part.toString()
	    }
	    return chunked ? body.append(part) : body.push(new Buffer(part))
	  }
	
	  if (self.request.preambleCRLF) {
	    add('\r\n')
	  }
	
	  parts.forEach(function (part) {
	    var preamble = '--' + self.boundary + '\r\n'
	    Object.keys(part).forEach(function (key) {
	      if (key === 'body') { return }
	      preamble += key + ': ' + part[key] + '\r\n'
	    })
	    preamble += '\r\n'
	    add(preamble)
	    add(part.body)
	    add('\r\n')
	  })
	  add('--' + self.boundary + '--')
	
	  if (self.request.postambleCRLF) {
	    add('\r\n')
	  }
	
	  return body
	}
	
	Multipart.prototype.onRequest = function (options) {
	  var self = this
	
	  var chunked = self.isChunked(options)
	    , parts = options.data || options
	
	  self.setHeaders(chunked)
	  self.chunked = chunked
	  self.body = self.build(parts, chunked)
	}
	
	exports.Multipart = Multipart


/***/ },
/* 738 */
/*!***********************************!*\
  !*** ./~/request/lib/redirect.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var url = __webpack_require__(/*! url */ 534)
	var isUrl = /^https?:/
	
	function Redirect (request) {
	  this.request = request
	  this.followRedirect = true
	  this.followRedirects = true
	  this.followAllRedirects = false
	  this.allowRedirect = function () {return true}
	  this.maxRedirects = 10
	  this.redirects = []
	  this.redirectsFollowed = 0
	  this.removeRefererHeader = false
	}
	
	Redirect.prototype.onRequest = function (options) {
	  var self = this
	
	  if (options.maxRedirects !== undefined) {
	    self.maxRedirects = options.maxRedirects
	  }
	  if (typeof options.followRedirect === 'function') {
	    self.allowRedirect = options.followRedirect
	  }
	  if (options.followRedirect !== undefined) {
	    self.followRedirects = !!options.followRedirect
	  }
	  if (options.followAllRedirects !== undefined) {
	    self.followAllRedirects = options.followAllRedirects
	  }
	  if (self.followRedirects || self.followAllRedirects) {
	    self.redirects = self.redirects || []
	  }
	  if (options.removeRefererHeader !== undefined) {
	    self.removeRefererHeader = options.removeRefererHeader
	  }
	}
	
	Redirect.prototype.redirectTo = function (response) {
	  var self = this
	    , request = self.request
	
	  var redirectTo = null
	  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {
	    var location = response.caseless.get('location')
	    request.debug('redirect', location)
	
	    if (self.followAllRedirects) {
	      redirectTo = location
	    } else if (self.followRedirects) {
	      switch (request.method) {
	        case 'PATCH':
	        case 'PUT':
	        case 'POST':
	        case 'DELETE':
	          // Do not follow redirects
	          break
	        default:
	          redirectTo = location
	          break
	      }
	    }
	  } else if (response.statusCode === 401) {
	    var authHeader = request._auth.onResponse(response)
	    if (authHeader) {
	      request.setHeader('authorization', authHeader)
	      redirectTo = request.uri
	    }
	  }
	  return redirectTo
	}
	
	Redirect.prototype.onResponse = function (response) {
	  var self = this
	    , request = self.request
	
	  var redirectTo = self.redirectTo(response)
	  if (!redirectTo || !self.allowRedirect.call(request, response)) {
	    return false
	  }
	
	  request.debug('redirect to', redirectTo)
	
	  // ignore any potential response body.  it cannot possibly be useful
	  // to us at this point.
	  // response.resume should be defined, but check anyway before calling. Workaround for browserify.
	  if (response.resume) {
	    response.resume()
	  }
	
	  if (self.redirectsFollowed >= self.maxRedirects) {
	    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))
	    return false
	  }
	  self.redirectsFollowed += 1
	
	  if (!isUrl.test(redirectTo)) {
	    redirectTo = url.resolve(request.uri.href, redirectTo)
	  }
	
	  var uriPrev = request.uri
	  request.uri = url.parse(redirectTo)
	
	  // handle the case where we change protocol from https to http or vice versa
	  if (request.uri.protocol !== uriPrev.protocol) {
	    delete request.agent
	  }
	
	  self.redirects.push(
	    { statusCode : response.statusCode
	    , redirectUri: redirectTo
	    }
	  )
	  if (self.followAllRedirects && request.method !== 'HEAD'
	    && response.statusCode !== 401 && response.statusCode !== 307) {
	    request.method = 'GET'
	  }
	  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215
	  delete request.src
	  delete request.req
	  delete request._started
	  if (response.statusCode !== 401 && response.statusCode !== 307) {
	    // Remove parameters from the previous response, unless this is the second request
	    // for a server that requires digest authentication.
	    delete request.body
	    delete request._form
	    if (request.headers) {
	      request.removeHeader('host')
	      request.removeHeader('content-type')
	      request.removeHeader('content-length')
	      if (request.uri.hostname !== request.originalHost.split(':')[0]) {
	        // Remove authorization if changing hostnames (but not if just
	        // changing ports or protocols).  This matches the behavior of curl:
	        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710
	        request.removeHeader('authorization')
	      }
	    }
	  }
	
	  if (!self.removeRefererHeader) {
	    request.setHeader('referer', uriPrev.href)
	  }
	
	  request.emit('redirect')
	
	  request.init()
	
	  return true
	}
	
	exports.Redirect = Redirect


/***/ },
/* 739 */
/*!*********************************!*\
  !*** ./~/request/lib/tunnel.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var url = __webpack_require__(/*! url */ 534)
	  , tunnel = __webpack_require__(/*! tunnel-agent */ 740)
	
	var defaultProxyHeaderWhiteList = [
	  'accept',
	  'accept-charset',
	  'accept-encoding',
	  'accept-language',
	  'accept-ranges',
	  'cache-control',
	  'content-encoding',
	  'content-language',
	  'content-location',
	  'content-md5',
	  'content-range',
	  'content-type',
	  'connection',
	  'date',
	  'expect',
	  'max-forwards',
	  'pragma',
	  'referer',
	  'te',
	  'user-agent',
	  'via'
	]
	
	var defaultProxyHeaderExclusiveList = [
	  'proxy-authorization'
	]
	
	function constructProxyHost(uriObject) {
	  var port = uriObject.port
	    , protocol = uriObject.protocol
	    , proxyHost = uriObject.hostname + ':'
	
	  if (port) {
	    proxyHost += port
	  } else if (protocol === 'https:') {
	    proxyHost += '443'
	  } else {
	    proxyHost += '80'
	  }
	
	  return proxyHost
	}
	
	function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
	  var whiteList = proxyHeaderWhiteList
	    .reduce(function (set, header) {
	      set[header.toLowerCase()] = true
	      return set
	    }, {})
	
	  return Object.keys(headers)
	    .filter(function (header) {
	      return whiteList[header.toLowerCase()]
	    })
	    .reduce(function (set, header) {
	      set[header] = headers[header]
	      return set
	    }, {})
	}
	
	function constructTunnelOptions (request, proxyHeaders) {
	  var proxy = request.proxy
	
	  var tunnelOptions = {
	    proxy : {
	      host      : proxy.hostname,
	      port      : +proxy.port,
	      proxyAuth : proxy.auth,
	      headers   : proxyHeaders
	    },
	    headers            : request.headers,
	    ca                 : request.ca,
	    cert               : request.cert,
	    key                : request.key,
	    passphrase         : request.passphrase,
	    pfx                : request.pfx,
	    ciphers            : request.ciphers,
	    rejectUnauthorized : request.rejectUnauthorized,
	    secureOptions      : request.secureOptions,
	    secureProtocol     : request.secureProtocol
	  }
	
	  return tunnelOptions
	}
	
	function constructTunnelFnName(uri, proxy) {
	  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')
	  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')
	  return [uriProtocol, proxyProtocol].join('Over')
	}
	
	function getTunnelFn(request) {
	  var uri = request.uri
	  var proxy = request.proxy
	  var tunnelFnName = constructTunnelFnName(uri, proxy)
	  return tunnel[tunnelFnName]
	}
	
	
	function Tunnel (request) {
	  this.request = request
	  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList
	  this.proxyHeaderExclusiveList = []
	  if (typeof request.tunnel !== 'undefined') {
	    this.tunnelOverride = request.tunnel
	  }
	}
	
	Tunnel.prototype.isEnabled = function () {
	  var self = this
	    , request = self.request
	  // Tunnel HTTPS by default. Allow the user to override this setting.
	
	  // If self.tunnelOverride is set (the user specified a value), use it.
	  if (typeof self.tunnelOverride !== 'undefined') {
	    return self.tunnelOverride
	  }
	
	  // If the destination is HTTPS, tunnel.
	  if (request.uri.protocol === 'https:') {
	    return true
	  }
	
	  // Otherwise, do not use tunnel.
	  return false
	}
	
	Tunnel.prototype.setup = function (options) {
	  var self = this
	    , request = self.request
	
	  options = options || {}
	
	  if (typeof request.proxy === 'string') {
	    request.proxy = url.parse(request.proxy)
	  }
	
	  if (!request.proxy || !request.tunnel) {
	    return false
	  }
	
	  // Setup Proxy Header Exclusive List and White List
	  if (options.proxyHeaderWhiteList) {
	    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList
	  }
	  if (options.proxyHeaderExclusiveList) {
	    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList
	  }
	
	  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)
	  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)
	
	  // Setup Proxy Headers and Proxy Headers Host
	  // Only send the Proxy White Listed Header names
	  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)
	  proxyHeaders.host = constructProxyHost(request.uri)
	
	  proxyHeaderExclusiveList.forEach(request.removeHeader, request)
	
	  // Set Agent from Tunnel Data
	  var tunnelFn = getTunnelFn(request)
	  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)
	  request.agent = tunnelFn(tunnelOptions)
	
	  return true
	}
	
	Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList
	Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList
	exports.Tunnel = Tunnel


/***/ },
/* 740 */
/*!*********************************!*\
  !*** ./~/tunnel-agent/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var net = __webpack_require__(/*! net */ 590)
	  , tls = __webpack_require__(/*! tls */ 685)
	  , http = __webpack_require__(/*! http */ 533)
	  , https = __webpack_require__(/*! https */ 603)
	  , events = __webpack_require__(/*! events */ 614)
	  , assert = __webpack_require__(/*! assert */ 635)
	  , util = __webpack_require__(/*! util */ 597)
	  ;
	
	exports.httpOverHttp = httpOverHttp
	exports.httpsOverHttp = httpsOverHttp
	exports.httpOverHttps = httpOverHttps
	exports.httpsOverHttps = httpsOverHttps
	
	
	function httpOverHttp(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = http.request
	  return agent
	}
	
	function httpsOverHttp(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = http.request
	  agent.createSocket = createSecureSocket
	  agent.defaultPort = 443
	  return agent
	}
	
	function httpOverHttps(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = https.request
	  return agent
	}
	
	function httpsOverHttps(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = https.request
	  agent.createSocket = createSecureSocket
	  agent.defaultPort = 443
	  return agent
	}
	
	
	function TunnelingAgent(options) {
	  var self = this
	  self.options = options || {}
	  self.proxyOptions = self.options.proxy || {}
	  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
	  self.requests = []
	  self.sockets = []
	
	  self.on('free', function onFree(socket, host, port) {
	    for (var i = 0, len = self.requests.length; i < len; ++i) {
	      var pending = self.requests[i]
	      if (pending.host === host && pending.port === port) {
	        // Detect the request to connect same origin server,
	        // reuse the connection.
	        self.requests.splice(i, 1)
	        pending.request.onSocket(socket)
	        return
	      }
	    }
	    socket.destroy()
	    self.removeSocket(socket)
	  })
	}
	util.inherits(TunnelingAgent, events.EventEmitter)
	
	TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
	  var self = this
	
	   // Legacy API: addRequest(req, host, port, path)
	  if (typeof options === 'string') {
	    options = {
	      host: options,
	      port: arguments[2],
	      path: arguments[3]
	    };
	  }
	
	  if (self.sockets.length >= this.maxSockets) {
	    // We are over limit so we'll add it to the queue.
	    self.requests.push({host: options.host, port: options.port, request: req})
	    return
	  }
	
	  // If we are under maxSockets create a new one.
	  self.createConnection({host: options.host, port: options.port, request: req})
	}
	
	TunnelingAgent.prototype.createConnection = function createConnection(pending) {
	  var self = this
	
	  self.createSocket(pending, function(socket) {
	    socket.on('free', onFree)
	    socket.on('close', onCloseOrRemove)
	    socket.on('agentRemove', onCloseOrRemove)
	    pending.request.onSocket(socket)
	
	    function onFree() {
	      self.emit('free', socket, pending.host, pending.port)
	    }
	
	    function onCloseOrRemove(err) {
	      self.removeSocket(socket)
	      socket.removeListener('free', onFree)
	      socket.removeListener('close', onCloseOrRemove)
	      socket.removeListener('agentRemove', onCloseOrRemove)
	    }
	  })
	}
	
	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
	  var self = this
	  var placeholder = {}
	  self.sockets.push(placeholder)
	
	  var connectOptions = mergeOptions({}, self.proxyOptions, 
	    { method: 'CONNECT'
	    , path: options.host + ':' + options.port
	    , agent: false
	    }
	  )
	  if (connectOptions.proxyAuth) {
	    connectOptions.headers = connectOptions.headers || {}
	    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
	        new Buffer(connectOptions.proxyAuth).toString('base64')
	  }
	
	  debug('making CONNECT request')
	  var connectReq = self.request(connectOptions)
	  connectReq.useChunkedEncodingByDefault = false // for v0.6
	  connectReq.once('response', onResponse) // for v0.6
	  connectReq.once('upgrade', onUpgrade)   // for v0.6
	  connectReq.once('connect', onConnect)   // for v0.7 or later
	  connectReq.once('error', onError)
	  connectReq.end()
	
	  function onResponse(res) {
	    // Very hacky. This is necessary to avoid http-parser leaks.
	    res.upgrade = true
	  }
	
	  function onUpgrade(res, socket, head) {
	    // Hacky.
	    process.nextTick(function() {
	      onConnect(res, socket, head)
	    })
	  }
	
	  function onConnect(res, socket, head) {
	    connectReq.removeAllListeners()
	    socket.removeAllListeners()
	
	    if (res.statusCode === 200) {
	      assert.equal(head.length, 0)
	      debug('tunneling connection has established')
	      self.sockets[self.sockets.indexOf(placeholder)] = socket
	      cb(socket)
	    } else {
	      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
	      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
	      error.code = 'ECONNRESET'
	      options.request.emit('error', error)
	      self.removeSocket(placeholder)
	    }
	  }
	
	  function onError(cause) {
	    connectReq.removeAllListeners()
	
	    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
	    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
	    error.code = 'ECONNRESET'
	    options.request.emit('error', error)
	    self.removeSocket(placeholder)
	  }
	}
	
	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
	  var pos = this.sockets.indexOf(socket)
	  if (pos === -1) return
	  
	  this.sockets.splice(pos, 1)
	
	  var pending = this.requests.shift()
	  if (pending) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createConnection(pending)
	  }
	}
	
	function createSecureSocket(options, cb) {
	  var self = this
	  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
	    // 0 is dummy port for v0.6
	    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
	      { servername: options.host
	      , socket: socket
	      }
	    ))
	    self.sockets[self.sockets.indexOf(socket)] = secureSocket
	    cb(secureSocket)
	  })
	}
	
	
	function mergeOptions(target) {
	  for (var i = 1, len = arguments.length; i < len; ++i) {
	    var overrides = arguments[i]
	    if (typeof overrides === 'object') {
	      var keys = Object.keys(overrides)
	      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
	        var k = keys[j]
	        if (overrides[k] !== undefined) {
	          target[k] = overrides[k]
	        }
	      }
	    }
	  }
	  return target
	}
	
	
	var debug
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
	  debug = function() {
	    var args = Array.prototype.slice.call(arguments)
	    if (typeof args[0] === 'string') {
	      args[0] = 'TUNNEL: ' + args[0]
	    } else {
	      args.unshift('TUNNEL:')
	    }
	    console.error.apply(console, args)
	  }
	} else {
	  debug = function() {}
	}
	exports.debug = debug // for test


/***/ },
/* 741 */
/*!************************!*\
  !*** ./~/aws4/aws4.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var aws4 = exports,
	    url = __webpack_require__(/*! url */ 534),
	    querystring = __webpack_require__(/*! querystring */ 540),
	    crypto = __webpack_require__(/*! crypto */ 601),
	    lru = __webpack_require__(/*! ./lru */ 742),
	    credentialsCache = lru(1000)
	
	// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html
	
	function hmac(key, string, encoding) {
	  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)
	}
	
	function hash(string, encoding) {
	  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)
	}
	
	// This function assumes the string has already been percent encoded
	function encodeRfc3986(urlEncodedString) {
	  return urlEncodedString.replace(/[!'()*]/g, function(c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}
	
	// request: { path | body, [host], [method], [headers], [service], [region] }
	// credentials: { accessKeyId, secretAccessKey, [sessionToken] }
	function RequestSigner(request, credentials) {
	
	  if (typeof request === 'string') request = url.parse(request)
	
	  var headers = request.headers = (request.headers || {}),
	      hostParts = this.matchHost(request.hostname || request.host || headers.Host || headers.host)
	
	  this.request = request
	  this.credentials = credentials || this.defaultCredentials()
	
	  this.service = request.service || hostParts[0] || ''
	  this.region = request.region || hostParts[1] || 'us-east-1'
	
	  // SES uses a different domain from the service name
	  if (this.service === 'email') this.service = 'ses'
	
	  if (!request.method && request.body)
	    request.method = 'POST'
	
	  if (!headers.Host && !headers.host) {
	    headers.Host = request.hostname || request.host || this.createHost()
	
	    // If a port is specified explicitly, use it as is
	    if (request.port)
	      headers.Host += ':' + request.port
	  }
	  if (!request.hostname && !request.host)
	    request.hostname = headers.Host || headers.host
	}
	
	RequestSigner.prototype.matchHost = function(host) {
	  var match = (host || '').match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com$/)
	  var hostParts = (match || []).slice(1, 3)
	
	  // ES's hostParts are sometimes the other way round, if the value that is expected
	  // to be region equals ‘es’ switch them back
	  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com
	  if (hostParts[1] === 'es')
	    hostParts = hostParts.reverse()
	
	  return hostParts
	}
	
	// http://docs.aws.amazon.com/general/latest/gr/rande.html
	RequestSigner.prototype.isSingleRegion = function() {
	  // Special case for S3 and SimpleDB in us-east-1
	  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true
	
	  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']
	    .indexOf(this.service) >= 0
	}
	
	RequestSigner.prototype.createHost = function() {
	  var region = this.isSingleRegion() ? '' :
	        (this.service === 's3' && this.region !== 'us-east-1' ? '-' : '.') + this.region,
	      service = this.service === 'ses' ? 'email' : this.service
	  return service + region + '.amazonaws.com'
	}
	
	RequestSigner.prototype.prepareRequest = function() {
	  this.parsePath()
	
	  var request = this.request, headers = request.headers, query
	
	  if (request.signQuery) {
	
	    this.parsedPath.query = query = this.parsedPath.query || {}
	
	    if (this.credentials.sessionToken)
	      query['X-Amz-Security-Token'] = this.credentials.sessionToken
	
	    if (this.service === 's3' && !query['X-Amz-Expires'])
	      query['X-Amz-Expires'] = 86400
	
	    if (query['X-Amz-Date'])
	      this.datetime = query['X-Amz-Date']
	    else
	      query['X-Amz-Date'] = this.getDateTime()
	
	    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'
	    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()
	    query['X-Amz-SignedHeaders'] = this.signedHeaders()
	
	  } else {
	
	    if (!request.doNotModifyHeaders) {
	      if (request.body && !headers['Content-Type'] && !headers['content-type'])
	        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'
	
	      if (request.body && !headers['Content-Length'] && !headers['content-length'])
	        headers['Content-Length'] = Buffer.byteLength(request.body)
	
	      if (this.credentials.sessionToken)
	        headers['X-Amz-Security-Token'] = this.credentials.sessionToken
	
	      if (this.service === 's3')
	        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex')
	
	      if (headers['X-Amz-Date'])
	        this.datetime = headers['X-Amz-Date']
	      else
	        headers['X-Amz-Date'] = this.getDateTime()
	    }
	
	    delete headers.Authorization
	    delete headers.authorization
	  }
	}
	
	RequestSigner.prototype.sign = function() {
	  if (!this.parsedPath) this.prepareRequest()
	
	  if (this.request.signQuery) {
	    this.parsedPath.query['X-Amz-Signature'] = this.signature()
	  } else {
	    this.request.headers.Authorization = this.authHeader()
	  }
	
	  this.request.path = this.formatPath()
	
	  return this.request
	}
	
	RequestSigner.prototype.getDateTime = function() {
	  if (!this.datetime) {
	    var headers = this.request.headers,
	      date = new Date(headers.Date || headers.date || new Date)
	
	    this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, '')
	  }
	  return this.datetime
	}
	
	RequestSigner.prototype.getDate = function() {
	  return this.getDateTime().substr(0, 8)
	}
	
	RequestSigner.prototype.authHeader = function() {
	  return [
	    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),
	    'SignedHeaders=' + this.signedHeaders(),
	    'Signature=' + this.signature(),
	  ].join(', ')
	}
	
	RequestSigner.prototype.signature = function() {
	  var date = this.getDate(),
	      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),
	      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey)
	  if (!kCredentials) {
	    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)
	    kRegion = hmac(kDate, this.region)
	    kService = hmac(kRegion, this.service)
	    kCredentials = hmac(kService, 'aws4_request')
	    credentialsCache.set(cacheKey, kCredentials)
	  }
	  return hmac(kCredentials, this.stringToSign(), 'hex')
	}
	
	RequestSigner.prototype.stringToSign = function() {
	  return [
	    'AWS4-HMAC-SHA256',
	    this.getDateTime(),
	    this.credentialString(),
	    hash(this.canonicalString(), 'hex'),
	  ].join('\n')
	}
	
	RequestSigner.prototype.canonicalString = function() {
	  if (!this.parsedPath) this.prepareRequest()
	
	  var pathStr = this.parsedPath.path,
	      query = this.parsedPath.query,
	      queryStr = '',
	      normalizePath = this.service !== 's3',
	      decodePath = this.service === 's3' || this.request.doNotEncodePath,
	      decodeSlashesInPath = this.service === 's3',
	      firstValOnly = this.service === 's3',
	      bodyHash = this.service === 's3' && this.request.signQuery ?
	        'UNSIGNED-PAYLOAD' : hash(this.request.body || '', 'hex')
	
	  if (query) {
	    queryStr = encodeRfc3986(querystring.stringify(Object.keys(query).sort().reduce(function(obj, key) {
	      if (!key) return obj
	      obj[key] = !Array.isArray(query[key]) ? query[key] :
	        (firstValOnly ? query[key][0] : query[key].slice().sort())
	      return obj
	    }, {})))
	  }
	  if (pathStr !== '/') {
	    if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, '/')
	    pathStr = pathStr.split('/').reduce(function(path, piece) {
	      if (normalizePath && piece === '..') {
	        path.pop()
	      } else if (!normalizePath || piece !== '.') {
	        if (decodePath) piece = querystring.unescape(piece)
	        path.push(encodeRfc3986(querystring.escape(piece)))
	      }
	      return path
	    }, []).join('/')
	    if (pathStr[0] !== '/') pathStr = '/' + pathStr
	    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')
	  }
	
	  return [
	    this.request.method || 'GET',
	    pathStr,
	    queryStr,
	    this.canonicalHeaders() + '\n',
	    this.signedHeaders(),
	    bodyHash,
	  ].join('\n')
	}
	
	RequestSigner.prototype.canonicalHeaders = function() {
	  var headers = this.request.headers
	  function trimAll(header) {
	    return header.toString().trim().replace(/\s+/g, ' ')
	  }
	  return Object.keys(headers)
	    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })
	    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })
	    .join('\n')
	}
	
	RequestSigner.prototype.signedHeaders = function() {
	  return Object.keys(this.request.headers)
	    .map(function(key) { return key.toLowerCase() })
	    .sort()
	    .join(';')
	}
	
	RequestSigner.prototype.credentialString = function() {
	  return [
	    this.getDate(),
	    this.region,
	    this.service,
	    'aws4_request',
	  ].join('/')
	}
	
	RequestSigner.prototype.defaultCredentials = function() {
	  var env = process.env
	  return {
	    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
	    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
	    sessionToken: env.AWS_SESSION_TOKEN,
	  }
	}
	
	RequestSigner.prototype.parsePath = function() {
	  var path = this.request.path || '/',
	      queryIx = path.indexOf('?'),
	      query = null
	
	  if (queryIx >= 0) {
	    query = querystring.parse(path.slice(queryIx + 1))
	    path = path.slice(0, queryIx)
	  }
	
	  // S3 doesn't always encode characters > 127 correctly and
	  // all services don't encode characters > 255 correctly
	  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all
	  if (/[^0-9A-Za-z!'()*\-._~%/]/.test(path)) {
	    path = path.split('/').map(function(piece) {
	      return querystring.escape(querystring.unescape(piece))
	    }).join('/')
	  }
	
	  this.parsedPath = {
	    path: path,
	    query: query,
	  }
	}
	
	RequestSigner.prototype.formatPath = function() {
	  var path = this.parsedPath.path,
	      query = this.parsedPath.query
	
	  if (!query) return path
	
	  // Services don't support empty query string keys
	  if (query[''] != null) delete query['']
	
	  return path + '?' + encodeRfc3986(querystring.stringify(query))
	}
	
	aws4.RequestSigner = RequestSigner
	
	aws4.sign = function(request, credentials) {
	  return new RequestSigner(request, credentials).sign()
	}


/***/ },
/* 742 */
/*!***********************!*\
  !*** ./~/aws4/lru.js ***!
  \***********************/
/***/ function(module, exports) {

	module.exports = function(size) {
	  return new LruCache(size)
	}
	
	function LruCache(size) {
	  this.capacity = size | 0
	  this.map = Object.create(null)
	  this.list = new DoublyLinkedList()
	}
	
	LruCache.prototype.get = function(key) {
	  var node = this.map[key]
	  if (node == null) return undefined
	  this.used(node)
	  return node.val
	}
	
	LruCache.prototype.set = function(key, val) {
	  var node = this.map[key]
	  if (node != null) {
	    node.val = val
	  } else {
	    if (!this.capacity) this.prune()
	    if (!this.capacity) return false
	    node = new DoublyLinkedNode(key, val)
	    this.map[key] = node
	    this.capacity--
	  }
	  this.used(node)
	  return true
	}
	
	LruCache.prototype.used = function(node) {
	  this.list.moveToFront(node)
	}
	
	LruCache.prototype.prune = function() {
	  var node = this.list.pop()
	  if (node != null) {
	    delete this.map[node.key]
	    this.capacity++
	  }
	}
	
	
	function DoublyLinkedList() {
	  this.firstNode = null
	  this.lastNode = null
	}
	
	DoublyLinkedList.prototype.moveToFront = function(node) {
	  if (this.firstNode == node) return
	
	  this.remove(node)
	
	  if (this.firstNode == null) {
	    this.firstNode = node
	    this.lastNode = node
	    node.prev = null
	    node.next = null
	  } else {
	    node.prev = null
	    node.next = this.firstNode
	    node.next.prev = node
	    this.firstNode = node
	  }
	}
	
	DoublyLinkedList.prototype.pop = function() {
	  var lastNode = this.lastNode
	  if (lastNode != null) {
	    this.remove(lastNode)
	  }
	  return lastNode
	}
	
	DoublyLinkedList.prototype.remove = function(node) {
	  if (this.firstNode == node) {
	    this.firstNode = node.next
	  } else if (node.prev != null) {
	    node.prev.next = node.next
	  }
	  if (this.lastNode == node) {
	    this.lastNode = node.prev
	  } else if (node.next != null) {
	    node.next.prev = node.prev
	  }
	}
	
	
	function DoublyLinkedNode(key, val) {
	  this.key = key
	  this.val = val
	  this.prev = null
	  this.next = null
	}


/***/ },
/* 743 */
/*!*********************************!*\
  !*** ./~/sia.js/js/download.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	// Libraries
	var fs = __webpack_require__(/*! fs */ 531)
	var path = __webpack_require__(/*! path */ 521)
	var zlib = __webpack_require__(/*! zlib */ 605) // for gunzip
	var request = __webpack_require__(/*! request */ 586)
	var extract = process.platform === 'linux' ? __webpack_require__(/*! tar */ 744) : __webpack_require__(/*! unzip */ 791)
	
	// Hard coded download details
	const config = {
	  baseUrl: 'https://github.com/NebulousLabs/Sia/releases/download/',
	  siaVersion: 'v0.4.8-beta'
	}
	
	// Helper to quit process and output error
	function handleError (error) {
	  if (!error) return
	
	  var message = error.message || error
	  console.error('Download failed: ' + message)
	  process.exit(1)
	}
	
	// Function to download Sia release
	module.exports = function (output, callback) {
	  // Get target directory and filepath
	  var outputDir, outputPath
	  var lastIndex = output.lastIndexOf('/')
	  outputPath = output.substring(0, lastIndex)
	  outputDir = output.substring(lastIndex)
	
	  // Interpret filename from process environment variables
	  var platform, arch, extension
	  platform = process.platform === 'win32' ? 'windows' : process.platform
	  extension = process.platform === 'linux' ? '.tar.gz' : '.zip'
	  switch (process.arch) {
	    case 'x64':
	      arch = 'amd64'
	      break
	    case 'ia32':
	      arch = '386'
	      break
	    default:
	      arch = process.arch
	  }
	  var extractedDirName = 'Sia-' + config.siaVersion + '-' + platform + '-' + arch
	  var fileName = extractedDirName + extension
	  var fullUrl = config.baseUrl + config.siaVersion + '/' + fileName
	
	  // Setup download stream
	  var requestStream = request(fullUrl)
	  requestStream.on('error', handleError)
	
	  // Setup extract stream
	  var extractStream = extract.Extract({path: outputPath})
	  extractStream.on('error', handleError)
	  extractStream.on('close', function () {
	    if (process.platform !== 'win32') {
	      fs.chmod(outputPath, '755', handleError)
	    }
	  })
	
	  // Pipe download stream to extract stream
	  var download
	  if (process.platform === 'linux') {
	    download = requestStream.pipe(zlib.createGunzip()).pipe(extractStream)
	  } else {
	    download = requestStream.pipe(extractStream)
	  }
	
	  // On finish download, execute callback or handle an error if one came up
	  callback = callback || handleError
	  download.on('close', function () {
	    fs.rename(path.join(outputPath, extractedDirName),
	              path.join(outputPath, outputDir),
	              callback)
	  })
	  return true
	}
	


/***/ },
/* 744 */
/*!**********************!*\
  !*** ./~/tar/tar.js ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	// field paths that every tar file must have.
	// header is padded to 512 bytes.
	var f = 0
	  , fields = {}
	  , path = fields.path = f++
	  , mode = fields.mode = f++
	  , uid = fields.uid = f++
	  , gid = fields.gid = f++
	  , size = fields.size = f++
	  , mtime = fields.mtime = f++
	  , cksum = fields.cksum = f++
	  , type = fields.type = f++
	  , linkpath = fields.linkpath = f++
	  , headerSize = 512
	  , blockSize = 512
	  , fieldSize = []
	
	fieldSize[path] = 100
	fieldSize[mode] = 8
	fieldSize[uid] = 8
	fieldSize[gid] = 8
	fieldSize[size] = 12
	fieldSize[mtime] = 12
	fieldSize[cksum] = 8
	fieldSize[type] = 1
	fieldSize[linkpath] = 100
	
	// "ustar\0" may introduce another bunch of headers.
	// these are optional, and will be nulled out if not present.
	
	var ustar = fields.ustar = f++
	  , ustarver = fields.ustarver = f++
	  , uname = fields.uname = f++
	  , gname = fields.gname = f++
	  , devmaj = fields.devmaj = f++
	  , devmin = fields.devmin = f++
	  , prefix = fields.prefix = f++
	  , fill = fields.fill = f++
	
	// terminate fields.
	fields[f] = null
	
	fieldSize[ustar] = 6
	fieldSize[ustarver] = 2
	fieldSize[uname] = 32
	fieldSize[gname] = 32
	fieldSize[devmaj] = 8
	fieldSize[devmin] = 8
	fieldSize[prefix] = 155
	fieldSize[fill] = 12
	
	// nb: prefix field may in fact be 130 bytes of prefix,
	// a null char, 12 bytes for atime, 12 bytes for ctime.
	//
	// To recognize this format:
	// 1. prefix[130] === ' ' or '\0'
	// 2. atime and ctime are octal numeric values
	// 3. atime and ctime have ' ' in their last byte
	
	var fieldEnds = {}
	  , fieldOffs = {}
	  , fe = 0
	for (var i = 0; i < f; i ++) {
	  fieldOffs[i] = fe
	  fieldEnds[i] = (fe += fieldSize[i])
	}
	
	// build a translation table of field paths.
	Object.keys(fields).forEach(function (f) {
	  if (fields[f] !== null) fields[fields[f]] = f
	})
	
	// different values of the 'type' field
	// paths match the values of Stats.isX() functions, where appropriate
	var types =
	  { 0: "File"
	  , "\0": "OldFile" // like 0
	  , "": "OldFile"
	  , 1: "Link"
	  , 2: "SymbolicLink"
	  , 3: "CharacterDevice"
	  , 4: "BlockDevice"
	  , 5: "Directory"
	  , 6: "FIFO"
	  , 7: "ContiguousFile" // like 0
	  // posix headers
	  , g: "GlobalExtendedHeader" // k=v for the rest of the archive
	  , x: "ExtendedHeader" // k=v for the next file
	  // vendor-specific stuff
	  , A: "SolarisACL" // skip
	  , D: "GNUDumpDir" // like 5, but with data, which should be skipped
	  , I: "Inode" // metadata only, skip
	  , K: "NextFileHasLongLinkpath" // data = link path of next file
	  , L: "NextFileHasLongPath" // data = path of next file
	  , M: "ContinuationFile" // skip
	  , N: "OldGnuLongPath" // like L
	  , S: "SparseFile" // skip
	  , V: "TapeVolumeHeader" // skip
	  , X: "OldExtendedHeader" // like x
	  }
	
	Object.keys(types).forEach(function (t) {
	  types[types[t]] = types[types[t]] || t
	})
	
	// values for the mode field
	var modes =
	  { suid: 04000 // set uid on extraction
	  , sgid: 02000 // set gid on extraction
	  , svtx: 01000 // set restricted deletion flag on dirs on extraction
	  , uread:  0400
	  , uwrite: 0200
	  , uexec:  0100
	  , gread:  040
	  , gwrite: 020
	  , gexec:  010
	  , oread:  4
	  , owrite: 2
	  , oexec:  1
	  , all: 07777
	  }
	
	var numeric =
	  { mode: true
	  , uid: true
	  , gid: true
	  , size: true
	  , mtime: true
	  , devmaj: true
	  , devmin: true
	  , cksum: true
	  , atime: true
	  , ctime: true
	  , dev: true
	  , ino: true
	  , nlink: true
	  }
	
	Object.keys(modes).forEach(function (t) {
	  modes[modes[t]] = modes[modes[t]] || t
	})
	
	var knownExtended =
	  { atime: true
	  , charset: true
	  , comment: true
	  , ctime: true
	  , gid: true
	  , gname: true
	  , linkpath: true
	  , mtime: true
	  , path: true
	  , realtime: true
	  , security: true
	  , size: true
	  , uid: true
	  , uname: true }
	
	
	exports.fields = fields
	exports.fieldSize = fieldSize
	exports.fieldOffs = fieldOffs
	exports.fieldEnds = fieldEnds
	exports.types = types
	exports.modes = modes
	exports.numeric = numeric
	exports.headerSize = headerSize
	exports.blockSize = blockSize
	exports.knownExtended = knownExtended
	
	exports.Pack = __webpack_require__(/*! ./lib/pack.js */ 745)
	exports.Parse = __webpack_require__(/*! ./lib/parse.js */ 787)
	exports.Extract = __webpack_require__(/*! ./lib/extract.js */ 790)


/***/ },
/* 745 */
/*!***************************!*\
  !*** ./~/tar/lib/pack.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	// pipe in an fstream, and it'll make a tarball.
	// key-value pair argument is global extended header props.
	
	module.exports = Pack
	
	var EntryWriter = __webpack_require__(/*! ./entry-writer.js */ 746)
	  , Stream = __webpack_require__(/*! stream */ 604).Stream
	  , path = __webpack_require__(/*! path */ 521)
	  , inherits = __webpack_require__(/*! inherits */ 610)
	  , GlobalHeaderWriter = __webpack_require__(/*! ./global-header-writer.js */ 786)
	  , collect = __webpack_require__(/*! fstream */ 749).collect
	  , eof = new Buffer(512)
	
	for (var i = 0; i < 512; i ++) eof[i] = 0
	
	inherits(Pack, Stream)
	
	function Pack (props) {
	  // console.error("-- p ctor")
	  var me = this
	  if (!(me instanceof Pack)) return new Pack(props)
	
	  if (props) me._noProprietary = props.noProprietary
	  else me._noProprietary = false
	
	  me._global = props
	
	  me.readable = true
	  me.writable = true
	  me._buffer = []
	  // console.error("-- -- set current to null in ctor")
	  me._currentEntry = null
	  me._processing = false
	
	  me._pipeRoot = null
	  me.on("pipe", function (src) {
	    if (src.root === me._pipeRoot) return
	    me._pipeRoot = src
	    src.on("end", function () {
	      me._pipeRoot = null
	    })
	    me.add(src)
	  })
	}
	
	Pack.prototype.addGlobal = function (props) {
	  // console.error("-- p addGlobal")
	  if (this._didGlobal) return
	  this._didGlobal = true
	
	  var me = this
	  GlobalHeaderWriter(props)
	    .on("data", function (c) {
	      me.emit("data", c)
	    })
	    .end()
	}
	
	Pack.prototype.add = function (stream) {
	  if (this._global && !this._didGlobal) this.addGlobal(this._global)
	
	  if (this._ended) return this.emit("error", new Error("add after end"))
	
	  collect(stream)
	  this._buffer.push(stream)
	  this._process()
	  this._needDrain = this._buffer.length > 0
	  return !this._needDrain
	}
	
	Pack.prototype.pause = function () {
	  this._paused = true
	  if (this._currentEntry) this._currentEntry.pause()
	  this.emit("pause")
	}
	
	Pack.prototype.resume = function () {
	  this._paused = false
	  if (this._currentEntry) this._currentEntry.resume()
	  this.emit("resume")
	  this._process()
	}
	
	Pack.prototype.end = function () {
	  this._ended = true
	  this._buffer.push(eof)
	  this._process()
	}
	
	Pack.prototype._process = function () {
	  var me = this
	  if (me._paused || me._processing) {
	    return
	  }
	
	  var entry = me._buffer.shift()
	
	  if (!entry) {
	    if (me._needDrain) {
	      me.emit("drain")
	    }
	    return
	  }
	
	  if (entry.ready === false) {
	    // console.error("-- entry is not ready", entry)
	    me._buffer.unshift(entry)
	    entry.on("ready", function () {
	      // console.error("-- -- ready!", entry)
	      me._process()
	    })
	    return
	  }
	
	  me._processing = true
	
	  if (entry === eof) {
	    // need 2 ending null blocks.
	    me.emit("data", eof)
	    me.emit("data", eof)
	    me.emit("end")
	    me.emit("close")
	    return
	  }
	
	  // Change the path to be relative to the root dir that was
	  // added to the tarball.
	  //
	  // XXX This should be more like how -C works, so you can
	  // explicitly set a root dir, and also explicitly set a pathname
	  // in the tarball to use.  That way we can skip a lot of extra
	  // work when resolving symlinks for bundled dependencies in npm.
	
	  var root = path.dirname((entry.root || entry).path);
	  if (me._global && me._global.fromBase && entry.root && entry.root.path) {
	    // user set 'fromBase: true' indicating tar root should be directory itself
	    root = entry.root.path;
	  }
	
	  var wprops = {}
	
	  Object.keys(entry.props || {}).forEach(function (k) {
	    wprops[k] = entry.props[k]
	  })
	
	  if (me._noProprietary) wprops.noProprietary = true
	
	  wprops.path = path.relative(root, entry.path || '')
	
	  // actually not a matter of opinion or taste.
	  if (process.platform === "win32") {
	    wprops.path = wprops.path.replace(/\\/g, "/")
	  }
	
	  if (!wprops.type)
	    wprops.type = 'Directory'
	
	  switch (wprops.type) {
	    // sockets not supported
	    case "Socket":
	      return
	
	    case "Directory":
	      wprops.path += "/"
	      wprops.size = 0
	      break
	
	    case "Link":
	      var lp = path.resolve(path.dirname(entry.path), entry.linkpath)
	      wprops.linkpath = path.relative(root, lp) || "."
	      wprops.size = 0
	      break
	
	    case "SymbolicLink":
	      var lp = path.resolve(path.dirname(entry.path), entry.linkpath)
	      wprops.linkpath = path.relative(path.dirname(entry.path), lp) || "."
	      wprops.size = 0
	      break
	  }
	
	  // console.error("-- new writer", wprops)
	  // if (!wprops.type) {
	  //   // console.error("-- no type?", entry.constructor.name, entry)
	  // }
	
	  // console.error("-- -- set current to new writer", wprops.path)
	  var writer = me._currentEntry = EntryWriter(wprops)
	
	  writer.parent = me
	
	  // writer.on("end", function () {
	  //   // console.error("-- -- writer end", writer.path)
	  // })
	
	  writer.on("data", function (c) {
	    me.emit("data", c)
	  })
	
	  writer.on("header", function () {
	    Buffer.prototype.toJSON = function () {
	      return this.toString().split(/\0/).join(".")
	    }
	    // console.error("-- -- writer header %j", writer.props)
	    if (writer.props.size === 0) nextEntry()
	  })
	  writer.on("close", nextEntry)
	
	  var ended = false
	  function nextEntry () {
	    if (ended) return
	    ended = true
	
	    // console.error("-- -- writer close", writer.path)
	    // console.error("-- -- set current to null", wprops.path)
	    me._currentEntry = null
	    me._processing = false
	    me._process()
	  }
	
	  writer.on("error", function (er) {
	    // console.error("-- -- writer error", writer.path)
	    me.emit("error", er)
	  })
	
	  // if it's the root, then there's no need to add its entries,
	  // or data, since they'll be added directly.
	  if (entry === me._pipeRoot) {
	    // console.error("-- is the root, don't auto-add")
	    writer.add = null
	  }
	
	  entry.pipe(writer)
	}
	
	Pack.prototype.destroy = function () {}
	Pack.prototype.write = function () {}


/***/ },
/* 746 */
/*!***********************************!*\
  !*** ./~/tar/lib/entry-writer.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = EntryWriter
	
	var tar = __webpack_require__(/*! ../tar.js */ 744)
	  , TarHeader = __webpack_require__(/*! ./header.js */ 747)
	  , Entry = __webpack_require__(/*! ./entry.js */ 748)
	  , inherits = __webpack_require__(/*! inherits */ 610)
	  , BlockStream = __webpack_require__(/*! block-stream */ 784)
	  , ExtendedHeaderWriter
	  , Stream = __webpack_require__(/*! stream */ 604).Stream
	  , EOF = {}
	
	inherits(EntryWriter, Stream)
	
	function EntryWriter (props) {
	  var me = this
	
	  if (!(me instanceof EntryWriter)) {
	    return new EntryWriter(props)
	  }
	
	  Stream.apply(this)
	
	  me.writable = true
	  me.readable = true
	
	  me._stream = new BlockStream(512)
	
	  me._stream.on("data", function (c) {
	    me.emit("data", c)
	  })
	
	  me._stream.on("drain", function () {
	    me.emit("drain")
	  })
	
	  me._stream.on("end", function () {
	    me.emit("end")
	    me.emit("close")
	  })
	
	  me.props = props
	  if (props.type === "Directory") {
	    props.size = 0
	  }
	  props.ustar = "ustar\0"
	  props.ustarver = "00"
	  me.path = props.path
	
	  me._buffer = []
	  me._didHeader = false
	  me._meta = false
	
	  me.on("pipe", function () {
	    me._process()
	  })
	}
	
	EntryWriter.prototype.write = function (c) {
	  // console.error(".. ew write")
	  if (this._ended) return this.emit("error", new Error("write after end"))
	  this._buffer.push(c)
	  this._process()
	  this._needDrain = this._buffer.length > 0
	  return !this._needDrain
	}
	
	EntryWriter.prototype.end = function (c) {
	  // console.error(".. ew end")
	  if (c) this._buffer.push(c)
	  this._buffer.push(EOF)
	  this._ended = true
	  this._process()
	  this._needDrain = this._buffer.length > 0
	}
	
	EntryWriter.prototype.pause = function () {
	  // console.error(".. ew pause")
	  this._paused = true
	  this.emit("pause")
	}
	
	EntryWriter.prototype.resume = function () {
	  // console.error(".. ew resume")
	  this._paused = false
	  this.emit("resume")
	  this._process()
	}
	
	EntryWriter.prototype.add = function (entry) {
	  // console.error(".. ew add")
	  if (!this.parent) return this.emit("error", new Error("no parent"))
	
	  // make sure that the _header and such is emitted, and clear out
	  // the _currentEntry link on the parent.
	  if (!this._ended) this.end()
	
	  return this.parent.add(entry)
	}
	
	EntryWriter.prototype._header = function () {
	  // console.error(".. ew header")
	  if (this._didHeader) return
	  this._didHeader = true
	
	  var headerBlock = TarHeader.encode(this.props)
	
	  if (this.props.needExtended && !this._meta) {
	    var me = this
	
	    ExtendedHeaderWriter = ExtendedHeaderWriter ||
	      __webpack_require__(/*! ./extended-header-writer.js */ 785)
	
	    ExtendedHeaderWriter(this.props)
	      .on("data", function (c) {
	        me.emit("data", c)
	      })
	      .on("error", function (er) {
	        me.emit("error", er)
	      })
	      .end()
	  }
	
	  // console.error(".. .. ew headerBlock emitting")
	  this.emit("data", headerBlock)
	  this.emit("header")
	}
	
	EntryWriter.prototype._process = function () {
	  // console.error(".. .. ew process")
	  if (!this._didHeader && !this._meta) {
	    this._header()
	  }
	
	  if (this._paused || this._processing) {
	    // console.error(".. .. .. paused=%j, processing=%j", this._paused, this._processing)
	    return
	  }
	
	  this._processing = true
	
	  var buf = this._buffer
	  for (var i = 0; i < buf.length; i ++) {
	    // console.error(".. .. .. i=%d", i)
	
	    var c = buf[i]
	
	    if (c === EOF) this._stream.end()
	    else this._stream.write(c)
	
	    if (this._paused) {
	      // console.error(".. .. .. paused mid-emission")
	      this._processing = false
	      if (i < buf.length) {
	        this._needDrain = true
	        this._buffer = buf.slice(i + 1)
	      }
	      return
	    }
	  }
	
	  // console.error(".. .. .. emitted")
	  this._buffer.length = 0
	  this._processing = false
	
	  // console.error(".. .. .. emitting drain")
	  this.emit("drain")
	}
	
	EntryWriter.prototype.destroy = function () {}


/***/ },
/* 747 */
/*!*****************************!*\
  !*** ./~/tar/lib/header.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	// parse a 512-byte header block to a data object, or vice-versa
	// If the data won't fit nicely in a simple header, then generate
	// the appropriate extended header file, and return that.
	
	module.exports = TarHeader
	
	var tar = __webpack_require__(/*! ../tar.js */ 744)
	  , fields = tar.fields
	  , fieldOffs = tar.fieldOffs
	  , fieldEnds = tar.fieldEnds
	  , fieldSize = tar.fieldSize
	  , numeric = tar.numeric
	  , assert = __webpack_require__(/*! assert */ 635).ok
	  , space = " ".charCodeAt(0)
	  , slash = "/".charCodeAt(0)
	  , bslash = process.platform === "win32" ? "\\".charCodeAt(0) : null
	
	function TarHeader (block) {
	  if (!(this instanceof TarHeader)) return new TarHeader(block)
	  if (block) this.decode(block)
	}
	
	TarHeader.prototype =
	  { decode : decode
	  , encode: encode
	  , calcSum: calcSum
	  , checkSum: checkSum
	  }
	
	TarHeader.parseNumeric = parseNumeric
	TarHeader.encode = encode
	TarHeader.decode = decode
	
	// note that this will only do the normal ustar header, not any kind
	// of extended posix header file.  If something doesn't fit comfortably,
	// then it will set obj.needExtended = true, and set the block to
	// the closest approximation.
	function encode (obj) {
	  if (!obj && !(this instanceof TarHeader)) throw new Error(
	    "encode must be called on a TarHeader, or supplied an object")
	
	  obj = obj || this
	  var block = obj.block = new Buffer(512)
	
	  // if the object has a "prefix", then that's actually an extension of
	  // the path field.
	  if (obj.prefix) {
	    // console.error("%% header encoding, got a prefix", obj.prefix)
	    obj.path = obj.prefix + "/" + obj.path
	    // console.error("%% header encoding, prefixed path", obj.path)
	    obj.prefix = ""
	  }
	
	  obj.needExtended = false
	
	  if (obj.mode) {
	    if (typeof obj.mode === "string") obj.mode = parseInt(obj.mode, 8)
	    obj.mode = obj.mode & 0777
	  }
	
	  for (var f = 0; fields[f] !== null; f ++) {
	    var field = fields[f]
	      , off = fieldOffs[f]
	      , end = fieldEnds[f]
	      , ret
	
	    switch (field) {
	      case "cksum":
	        // special, done below, after all the others
	        break
	
	      case "prefix":
	        // special, this is an extension of the "path" field.
	        // console.error("%% header encoding, skip prefix later")
	        break
	
	      case "type":
	        // convert from long name to a single char.
	        var type = obj.type || "0"
	        if (type.length > 1) {
	          type = tar.types[obj.type]
	          if (!type) type = "0"
	        }
	        writeText(block, off, end, type)
	        break
	
	      case "path":
	        // uses the "prefix" field if > 100 bytes, but <= 255
	        var pathLen = Buffer.byteLength(obj.path)
	          , pathFSize = fieldSize[fields.path]
	          , prefFSize = fieldSize[fields.prefix]
	
	        // paths between 100 and 255 should use the prefix field.
	        // longer than 255
	        if (pathLen > pathFSize &&
	            pathLen <= pathFSize + prefFSize) {
	          // need to find a slash somewhere in the middle so that
	          // path and prefix both fit in their respective fields
	          var searchStart = pathLen - 1 - pathFSize
	            , searchEnd = prefFSize
	            , found = false
	            , pathBuf = new Buffer(obj.path)
	
	          for ( var s = searchStart
	              ; (s <= searchEnd)
	              ; s ++ ) {
	            if (pathBuf[s] === slash || pathBuf[s] === bslash) {
	              found = s
	              break
	            }
	          }
	
	          if (found !== false) {
	            prefix = pathBuf.slice(0, found).toString("utf8")
	            path = pathBuf.slice(found + 1).toString("utf8")
	
	            ret = writeText(block, off, end, path)
	            off = fieldOffs[fields.prefix]
	            end = fieldEnds[fields.prefix]
	            // console.error("%% header writing prefix", off, end, prefix)
	            ret = writeText(block, off, end, prefix) || ret
	            break
	          }
	        }
	
	        // paths less than 100 chars don't need a prefix
	        // and paths longer than 255 need an extended header and will fail
	        // on old implementations no matter what we do here.
	        // Null out the prefix, and fallthrough to default.
	        // console.error("%% header writing no prefix")
	        var poff = fieldOffs[fields.prefix]
	          , pend = fieldEnds[fields.prefix]
	        writeText(block, poff, pend, "")
	        // fallthrough
	
	      // all other fields are numeric or text
	      default:
	        ret = numeric[field]
	            ? writeNumeric(block, off, end, obj[field])
	            : writeText(block, off, end, obj[field] || "")
	        break
	    }
	    obj.needExtended = obj.needExtended || ret
	  }
	
	  var off = fieldOffs[fields.cksum]
	    , end = fieldEnds[fields.cksum]
	
	  writeNumeric(block, off, end, calcSum.call(this, block))
	
	  return block
	}
	
	// if it's a negative number, or greater than will fit,
	// then use write256.
	var MAXNUM = { 12: 077777777777
	             , 11: 07777777777
	             , 8 : 07777777
	             , 7 : 0777777 }
	function writeNumeric (block, off, end, num) {
	  var writeLen = end - off
	    , maxNum = MAXNUM[writeLen] || 0
	
	  num = num || 0
	  // console.error("  numeric", num)
	
	  if (num instanceof Date ||
	      Object.prototype.toString.call(num) === "[object Date]") {
	    num = num.getTime() / 1000
	  }
	
	  if (num > maxNum || num < 0) {
	    write256(block, off, end, num)
	    // need an extended header if negative or too big.
	    return true
	  }
	
	  // god, tar is so annoying
	  // if the string is small enough, you should put a space
	  // between the octal string and the \0, but if it doesn't
	  // fit, then don't.
	  var numStr = Math.floor(num).toString(8)
	  if (num < MAXNUM[writeLen - 1]) numStr += " "
	
	  // pad with "0" chars
	  if (numStr.length < writeLen) {
	    numStr = (new Array(writeLen - numStr.length).join("0")) + numStr
	  }
	
	  if (numStr.length !== writeLen - 1) {
	    throw new Error("invalid length: " + JSON.stringify(numStr) + "\n" +
	                    "expected: "+writeLen)
	  }
	  block.write(numStr, off, writeLen, "utf8")
	  block[end - 1] = 0
	}
	
	function write256 (block, off, end, num) {
	  var buf = block.slice(off, end)
	  var positive = num >= 0
	  buf[0] = positive ? 0x80 : 0xFF
	
	  // get the number as a base-256 tuple
	  if (!positive) num *= -1
	  var tuple = []
	  do {
	    var n = num % 256
	    tuple.push(n)
	    num = (num - n) / 256
	  } while (num)
	
	  var bytes = tuple.length
	
	  var fill = buf.length - bytes
	  for (var i = 1; i < fill; i ++) {
	    buf[i] = positive ? 0 : 0xFF
	  }
	
	  // tuple is a base256 number, with [0] as the *least* significant byte
	  // if it's negative, then we need to flip all the bits once we hit the
	  // first non-zero bit.  The 2's-complement is (0x100 - n), and the 1's-
	  // complement is (0xFF - n).
	  var zero = true
	  for (i = bytes; i > 0; i --) {
	    var byte = tuple[bytes - i]
	    if (positive) buf[fill + i] = byte
	    else if (zero && byte === 0) buf[fill + i] = 0
	    else if (zero) {
	      zero = false
	      buf[fill + i] = 0x100 - byte
	    } else buf[fill + i] = 0xFF - byte
	  }
	}
	
	function writeText (block, off, end, str) {
	  // strings are written as utf8, then padded with \0
	  var strLen = Buffer.byteLength(str)
	    , writeLen = Math.min(strLen, end - off)
	    // non-ascii fields need extended headers
	    // long fields get truncated
	    , needExtended = strLen !== str.length || strLen > writeLen
	
	  // write the string, and null-pad
	  if (writeLen > 0) block.write(str, off, writeLen, "utf8")
	  for (var i = off + writeLen; i < end; i ++) block[i] = 0
	
	  return needExtended
	}
	
	function calcSum (block) {
	  block = block || this.block
	  assert(Buffer.isBuffer(block) && block.length === 512)
	
	  if (!block) throw new Error("Need block to checksum")
	
	  // now figure out what it would be if the cksum was "        "
	  var sum = 0
	    , start = fieldOffs[fields.cksum]
	    , end = fieldEnds[fields.cksum]
	
	  for (var i = 0; i < fieldOffs[fields.cksum]; i ++) {
	    sum += block[i]
	  }
	
	  for (var i = start; i < end; i ++) {
	    sum += space
	  }
	
	  for (var i = end; i < 512; i ++) {
	    sum += block[i]
	  }
	
	  return sum
	}
	
	
	function checkSum (block) {
	  var sum = calcSum.call(this, block)
	  block = block || this.block
	
	  var cksum = block.slice(fieldOffs[fields.cksum], fieldEnds[fields.cksum])
	  cksum = parseNumeric(cksum)
	
	  return cksum === sum
	}
	
	function decode (block) {
	  block = block || this.block
	  assert(Buffer.isBuffer(block) && block.length === 512)
	
	  this.block = block
	  this.cksumValid = this.checkSum()
	
	  var prefix = null
	
	  // slice off each field.
	  for (var f = 0; fields[f] !== null; f ++) {
	    var field = fields[f]
	      , val = block.slice(fieldOffs[f], fieldEnds[f])
	
	    switch (field) {
	      case "ustar":
	        // if not ustar, then everything after that is just padding.
	        if (val.toString() !== "ustar\0") {
	          this.ustar = false
	          return
	        } else {
	          // console.error("ustar:", val, val.toString())
	          this.ustar = val.toString()
	        }
	        break
	
	      // prefix is special, since it might signal the xstar header
	      case "prefix":
	        var atime = parseNumeric(val.slice(131, 131 + 12))
	          , ctime = parseNumeric(val.slice(131 + 12, 131 + 12 + 12))
	        if ((val[130] === 0 || val[130] === space) &&
	            typeof atime === "number" &&
	            typeof ctime === "number" &&
	            val[131 + 12] === space &&
	            val[131 + 12 + 12] === space) {
	          this.atime = atime
	          this.ctime = ctime
	          val = val.slice(0, 130)
	        }
	        prefix = val.toString("utf8").replace(/\0+$/, "")
	        // console.error("%% header reading prefix", prefix)
	        break
	
	      // all other fields are null-padding text
	      // or a number.
	      default:
	        if (numeric[field]) {
	          this[field] = parseNumeric(val)
	        } else {
	          this[field] = val.toString("utf8").replace(/\0+$/, "")
	        }
	        break
	    }
	  }
	
	  // if we got a prefix, then prepend it to the path.
	  if (prefix) {
	    this.path = prefix + "/" + this.path
	    // console.error("%% header got a prefix", this.path)
	  }
	}
	
	function parse256 (buf) {
	  // first byte MUST be either 80 or FF
	  // 80 for positive, FF for 2's comp
	  var positive
	  if (buf[0] === 0x80) positive = true
	  else if (buf[0] === 0xFF) positive = false
	  else return null
	
	  // build up a base-256 tuple from the least sig to the highest
	  var zero = false
	    , tuple = []
	  for (var i = buf.length - 1; i > 0; i --) {
	    var byte = buf[i]
	    if (positive) tuple.push(byte)
	    else if (zero && byte === 0) tuple.push(0)
	    else if (zero) {
	      zero = false
	      tuple.push(0x100 - byte)
	    } else tuple.push(0xFF - byte)
	  }
	
	  for (var sum = 0, i = 0, l = tuple.length; i < l; i ++) {
	    sum += tuple[i] * Math.pow(256, i)
	  }
	
	  return positive ? sum : -1 * sum
	}
	
	function parseNumeric (f) {
	  if (f[0] & 0x80) return parse256(f)
	
	  var str = f.toString("utf8").split("\0")[0].trim()
	    , res = parseInt(str, 8)
	
	  return isNaN(res) ? null : res
	}
	


/***/ },
/* 748 */
/*!****************************!*\
  !*** ./~/tar/lib/entry.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	// A passthrough read/write stream that sets its properties
	// based on a header, extendedHeader, and globalHeader
	//
	// Can be either a file system object of some sort, or
	// a pax/ustar metadata entry.
	
	module.exports = Entry
	
	var TarHeader = __webpack_require__(/*! ./header.js */ 747)
	  , tar = __webpack_require__(/*! ../tar */ 744)
	  , assert = __webpack_require__(/*! assert */ 635).ok
	  , Stream = __webpack_require__(/*! stream */ 604).Stream
	  , inherits = __webpack_require__(/*! inherits */ 610)
	  , fstream = __webpack_require__(/*! fstream */ 749).Abstract
	
	function Entry (header, extended, global) {
	  Stream.call(this)
	  this.readable = true
	  this.writable = true
	
	  this._needDrain = false
	  this._paused = false
	  this._reading = false
	  this._ending = false
	  this._ended = false
	  this._remaining = 0
	  this._abort = false
	  this._queue = []
	  this._index = 0
	  this._queueLen = 0
	
	  this._read = this._read.bind(this)
	
	  this.props = {}
	  this._header = header
	  this._extended = extended || {}
	
	  // globals can change throughout the course of
	  // a file parse operation.  Freeze it at its current state.
	  this._global = {}
	  var me = this
	  Object.keys(global || {}).forEach(function (g) {
	    me._global[g] = global[g]
	  })
	
	  this._setProps()
	}
	
	inherits(Entry, Stream)
	
	Entry.prototype.write = function (c) {
	  if (this._ending) this.error("write() after end()", null, true)
	  if (this._remaining === 0) {
	    this.error("invalid bytes past eof")
	  }
	
	  // often we'll get a bunch of \0 at the end of the last write,
	  // since chunks will always be 512 bytes when reading a tarball.
	  if (c.length > this._remaining) {
	    c = c.slice(0, this._remaining)
	  }
	  this._remaining -= c.length
	
	  // put it on the stack.
	  var ql = this._queueLen
	  this._queue.push(c)
	  this._queueLen ++
	
	  this._read()
	
	  // either paused, or buffered
	  if (this._paused || ql > 0) {
	    this._needDrain = true
	    return false
	  }
	
	  return true
	}
	
	Entry.prototype.end = function (c) {
	  if (c) this.write(c)
	  this._ending = true
	  this._read()
	}
	
	Entry.prototype.pause = function () {
	  this._paused = true
	  this.emit("pause")
	}
	
	Entry.prototype.resume = function () {
	  // console.error("    Tar Entry resume", this.path)
	  this.emit("resume")
	  this._paused = false
	  this._read()
	  return this._queueLen - this._index > 1
	}
	
	  // This is bound to the instance
	Entry.prototype._read = function () {
	  // console.error("    Tar Entry _read", this.path)
	
	  if (this._paused || this._reading || this._ended) return
	
	  // set this flag so that event handlers don't inadvertently
	  // get multiple _read() calls running.
	  this._reading = true
	
	  // have any data to emit?
	  while (this._index < this._queueLen && !this._paused) {
	    var chunk = this._queue[this._index ++]
	    this.emit("data", chunk)
	  }
	
	  // check if we're drained
	  if (this._index >= this._queueLen) {
	    this._queue.length = this._queueLen = this._index = 0
	    if (this._needDrain) {
	      this._needDrain = false
	      this.emit("drain")
	    }
	    if (this._ending) {
	      this._ended = true
	      this.emit("end")
	    }
	  }
	
	  // if the queue gets too big, then pluck off whatever we can.
	  // this should be fairly rare.
	  var mql = this._maxQueueLen
	  if (this._queueLen > mql && this._index > 0) {
	    mql = Math.min(this._index, mql)
	    this._index -= mql
	    this._queueLen -= mql
	    this._queue = this._queue.slice(mql)
	  }
	
	  this._reading = false
	}
	
	Entry.prototype._setProps = function () {
	  // props = extended->global->header->{}
	  var header = this._header
	    , extended = this._extended
	    , global = this._global
	    , props = this.props
	
	  // first get the values from the normal header.
	  var fields = tar.fields
	  for (var f = 0; fields[f] !== null; f ++) {
	    var field = fields[f]
	      , val = header[field]
	    if (typeof val !== "undefined") props[field] = val
	  }
	
	  // next, the global header for this file.
	  // numeric values, etc, will have already been parsed.
	  ;[global, extended].forEach(function (p) {
	    Object.keys(p).forEach(function (f) {
	      if (typeof p[f] !== "undefined") props[f] = p[f]
	    })
	  })
	
	  // no nulls allowed in path or linkpath
	  ;["path", "linkpath"].forEach(function (p) {
	    if (props.hasOwnProperty(p)) {
	      props[p] = props[p].split("\0")[0]
	    }
	  })
	
	
	  // set date fields to be a proper date
	  ;["mtime", "ctime", "atime"].forEach(function (p) {
	    if (props.hasOwnProperty(p)) {
	      props[p] = new Date(props[p] * 1000)
	    }
	  })
	
	  // set the type so that we know what kind of file to create
	  var type
	  switch (tar.types[props.type]) {
	    case "OldFile":
	    case "ContiguousFile":
	      type = "File"
	      break
	
	    case "GNUDumpDir":
	      type = "Directory"
	      break
	
	    case undefined:
	      type = "Unknown"
	      break
	
	    case "Link":
	    case "SymbolicLink":
	    case "CharacterDevice":
	    case "BlockDevice":
	    case "Directory":
	    case "FIFO":
	    default:
	      type = tar.types[props.type]
	  }
	
	  this.type = type
	  this.path = props.path
	  this.size = props.size
	
	  // size is special, since it signals when the file needs to end.
	  this._remaining = props.size
	}
	
	// the parser may not call write if _abort is true. 
	// useful for skipping data from some files quickly.
	Entry.prototype.abort = function(){
	  this._abort = true
	}
	
	Entry.prototype.warn = fstream.warn
	Entry.prototype.error = fstream.error


/***/ },
/* 749 */
/*!******************************!*\
  !*** ./~/fstream/fstream.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	exports.Abstract = __webpack_require__(/*! ./lib/abstract.js */ 750)
	exports.Reader = __webpack_require__(/*! ./lib/reader.js */ 751)
	exports.Writer = __webpack_require__(/*! ./lib/writer.js */ 763)
	
	exports.File = {
	  Reader: __webpack_require__(/*! ./lib/file-reader.js */ 760),
	  Writer: __webpack_require__(/*! ./lib/file-writer.js */ 782)
	}
	
	exports.Dir = {
	  Reader: __webpack_require__(/*! ./lib/dir-reader.js */ 759),
	  Writer: __webpack_require__(/*! ./lib/dir-writer.js */ 779)
	}
	
	exports.Link = {
	  Reader: __webpack_require__(/*! ./lib/link-reader.js */ 758),
	  Writer: __webpack_require__(/*! ./lib/link-writer.js */ 781)
	}
	
	exports.Proxy = {
	  Reader: __webpack_require__(/*! ./lib/proxy-reader.js */ 762),
	  Writer: __webpack_require__(/*! ./lib/proxy-writer.js */ 783)
	}
	
	exports.Reader.Dir = exports.DirReader = exports.Dir.Reader
	exports.Reader.File = exports.FileReader = exports.File.Reader
	exports.Reader.Link = exports.LinkReader = exports.Link.Reader
	exports.Reader.Proxy = exports.ProxyReader = exports.Proxy.Reader
	
	exports.Writer.Dir = exports.DirWriter = exports.Dir.Writer
	exports.Writer.File = exports.FileWriter = exports.File.Writer
	exports.Writer.Link = exports.LinkWriter = exports.Link.Writer
	exports.Writer.Proxy = exports.ProxyWriter = exports.Proxy.Writer
	
	exports.collect = __webpack_require__(/*! ./lib/collect.js */ 780)


/***/ },
/* 750 */
/*!***********************************!*\
  !*** ./~/fstream/lib/abstract.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	// the parent class for all fstreams.
	
	module.exports = Abstract
	
	var Stream = __webpack_require__(/*! stream */ 604).Stream
	var inherits = __webpack_require__(/*! inherits */ 610)
	
	function Abstract () {
	  Stream.call(this)
	}
	
	inherits(Abstract, Stream)
	
	Abstract.prototype.on = function (ev, fn) {
	  if (ev === 'ready' && this.ready) {
	    process.nextTick(fn.bind(this))
	  } else {
	    Stream.prototype.on.call(this, ev, fn)
	  }
	  return this
	}
	
	Abstract.prototype.abort = function () {
	  this._aborted = true
	  this.emit('abort')
	}
	
	Abstract.prototype.destroy = function () {}
	
	Abstract.prototype.warn = function (msg, code) {
	  var self = this
	  var er = decorate(msg, code, self)
	  if (!self.listeners('warn')) {
	    console.error('%s %s\n' +
	    'path = %s\n' +
	    'syscall = %s\n' +
	    'fstream_type = %s\n' +
	    'fstream_path = %s\n' +
	    'fstream_unc_path = %s\n' +
	    'fstream_class = %s\n' +
	    'fstream_stack =\n%s\n',
	      code || 'UNKNOWN',
	      er.stack,
	      er.path,
	      er.syscall,
	      er.fstream_type,
	      er.fstream_path,
	      er.fstream_unc_path,
	      er.fstream_class,
	      er.fstream_stack.join('\n'))
	  } else {
	    self.emit('warn', er)
	  }
	}
	
	Abstract.prototype.info = function (msg, code) {
	  this.emit('info', msg, code)
	}
	
	Abstract.prototype.error = function (msg, code, th) {
	  var er = decorate(msg, code, this)
	  if (th) throw er
	  else this.emit('error', er)
	}
	
	function decorate (er, code, self) {
	  if (!(er instanceof Error)) er = new Error(er)
	  er.code = er.code || code
	  er.path = er.path || self.path
	  er.fstream_type = er.fstream_type || self.type
	  er.fstream_path = er.fstream_path || self.path
	  if (self._path !== self.path) {
	    er.fstream_unc_path = er.fstream_unc_path || self._path
	  }
	  if (self.linkpath) {
	    er.fstream_linkpath = er.fstream_linkpath || self.linkpath
	  }
	  er.fstream_class = er.fstream_class || self.constructor.name
	  er.fstream_stack = er.fstream_stack ||
	    new Error().stack.split(/\n/).slice(3).map(function (s) {
	      return s.replace(/^ {4}at /, '')
	    })
	
	  return er
	}


/***/ },
/* 751 */
/*!*********************************!*\
  !*** ./~/fstream/lib/reader.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = Reader
	
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	var Stream = __webpack_require__(/*! stream */ 604).Stream
	var inherits = __webpack_require__(/*! inherits */ 610)
	var path = __webpack_require__(/*! path */ 521)
	var getType = __webpack_require__(/*! ./get-type.js */ 757)
	var hardLinks = Reader.hardLinks = {}
	var Abstract = __webpack_require__(/*! ./abstract.js */ 750)
	
	// Must do this *before* loading the child classes
	inherits(Reader, Abstract)
	
	var LinkReader = __webpack_require__(/*! ./link-reader.js */ 758)
	
	function Reader (props, currentStat) {
	  var self = this
	  if (!(self instanceof Reader)) return new Reader(props, currentStat)
	
	  if (typeof props === 'string') {
	    props = { path: props }
	  }
	
	  if (!props.path) {
	    self.error('Must provide a path', null, true)
	  }
	
	  // polymorphism.
	  // call fstream.Reader(dir) to get a DirReader object, etc.
	  // Note that, unlike in the Writer case, ProxyReader is going
	  // to be the *normal* state of affairs, since we rarely know
	  // the type of a file prior to reading it.
	
	  var type
	  var ClassType
	
	  if (props.type && typeof props.type === 'function') {
	    type = props.type
	    ClassType = type
	  } else {
	    type = getType(props)
	    ClassType = Reader
	  }
	
	  if (currentStat && !type) {
	    type = getType(currentStat)
	    props[type] = true
	    props.type = type
	  }
	
	  switch (type) {
	    case 'Directory':
	      ClassType = __webpack_require__(/*! ./dir-reader.js */ 759)
	      break
	
	    case 'Link':
	    // XXX hard links are just files.
	    // However, it would be good to keep track of files' dev+inode
	    // and nlink values, and create a HardLinkReader that emits
	    // a linkpath value of the original copy, so that the tar
	    // writer can preserve them.
	    // ClassType = HardLinkReader
	    // break
	
	    case 'File':
	      ClassType = __webpack_require__(/*! ./file-reader.js */ 760)
	      break
	
	    case 'SymbolicLink':
	      ClassType = LinkReader
	      break
	
	    case 'Socket':
	      ClassType = __webpack_require__(/*! ./socket-reader.js */ 761)
	      break
	
	    case null:
	      ClassType = __webpack_require__(/*! ./proxy-reader.js */ 762)
	      break
	  }
	
	  if (!(self instanceof ClassType)) {
	    return new ClassType(props)
	  }
	
	  Abstract.call(self)
	
	  self.readable = true
	  self.writable = false
	
	  self.type = type
	  self.props = props
	  self.depth = props.depth = props.depth || 0
	  self.parent = props.parent || null
	  self.root = props.root || (props.parent && props.parent.root) || self
	
	  self._path = self.path = path.resolve(props.path)
	  if (process.platform === 'win32') {
	    self.path = self._path = self.path.replace(/\?/g, '_')
	    if (self._path.length >= 260) {
	      // how DOES one create files on the moon?
	      // if the path has spaces in it, then UNC will fail.
	      self._swallowErrors = true
	      // if (self._path.indexOf(" ") === -1) {
	      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
	    // }
	    }
	  }
	  self.basename = props.basename = path.basename(self.path)
	  self.dirname = props.dirname = path.dirname(self.path)
	
	  // these have served their purpose, and are now just noisy clutter
	  props.parent = props.root = null
	
	  // console.error("\n\n\n%s setting size to", props.path, props.size)
	  self.size = props.size
	  self.filter = typeof props.filter === 'function' ? props.filter : null
	  if (props.sort === 'alpha') props.sort = alphasort
	
	  // start the ball rolling.
	  // this will stat the thing, and then call self._read()
	  // to start reading whatever it is.
	  // console.error("calling stat", props.path, currentStat)
	  self._stat(currentStat)
	}
	
	function alphasort (a, b) {
	  return a === b ? 0
	    : a.toLowerCase() > b.toLowerCase() ? 1
	      : a.toLowerCase() < b.toLowerCase() ? -1
	        : a > b ? 1
	          : -1
	}
	
	Reader.prototype._stat = function (currentStat) {
	  var self = this
	  var props = self.props
	  var stat = props.follow ? 'stat' : 'lstat'
	  // console.error("Reader._stat", self._path, currentStat)
	  if (currentStat) process.nextTick(statCb.bind(null, null, currentStat))
	  else fs[stat](self._path, statCb)
	
	  function statCb (er, props_) {
	    // console.error("Reader._stat, statCb", self._path, props_, props_.nlink)
	    if (er) return self.error(er)
	
	    Object.keys(props_).forEach(function (k) {
	      props[k] = props_[k]
	    })
	
	    // if it's not the expected size, then abort here.
	    if (undefined !== self.size && props.size !== self.size) {
	      return self.error('incorrect size')
	    }
	    self.size = props.size
	
	    var type = getType(props)
	    var handleHardlinks = props.hardlinks !== false
	
	    // special little thing for handling hardlinks.
	    if (handleHardlinks && type !== 'Directory' && props.nlink && props.nlink > 1) {
	      var k = props.dev + ':' + props.ino
	      // console.error("Reader has nlink", self._path, k)
	      if (hardLinks[k] === self._path || !hardLinks[k]) {
	        hardLinks[k] = self._path
	      } else {
	        // switch into hardlink mode.
	        type = self.type = self.props.type = 'Link'
	        self.Link = self.props.Link = true
	        self.linkpath = self.props.linkpath = hardLinks[k]
	        // console.error("Hardlink detected, switching mode", self._path, self.linkpath)
	        // Setting __proto__ would arguably be the "correct"
	        // approach here, but that just seems too wrong.
	        self._stat = self._read = LinkReader.prototype._read
	      }
	    }
	
	    if (self.type && self.type !== type) {
	      self.error('Unexpected type: ' + type)
	    }
	
	    // if the filter doesn't pass, then just skip over this one.
	    // still have to emit end so that dir-walking can move on.
	    if (self.filter) {
	      var who = self._proxy || self
	      // special handling for ProxyReaders
	      if (!self.filter.call(who, who, props)) {
	        if (!self._disowned) {
	          self.abort()
	          self.emit('end')
	          self.emit('close')
	        }
	        return
	      }
	    }
	
	    // last chance to abort or disown before the flow starts!
	    var events = ['_stat', 'stat', 'ready']
	    var e = 0
	    ;(function go () {
	      if (self._aborted) {
	        self.emit('end')
	        self.emit('close')
	        return
	      }
	
	      if (self._paused && self.type !== 'Directory') {
	        self.once('resume', go)
	        return
	      }
	
	      var ev = events[e++]
	      if (!ev) {
	        return self._read()
	      }
	      self.emit(ev, props)
	      go()
	    })()
	  }
	}
	
	Reader.prototype.pipe = function (dest) {
	  var self = this
	  if (typeof dest.add === 'function') {
	    // piping to a multi-compatible, and we've got directory entries.
	    self.on('entry', function (entry) {
	      var ret = dest.add(entry)
	      if (ret === false) {
	        self.pause()
	      }
	    })
	  }
	
	  // console.error("R Pipe apply Stream Pipe")
	  return Stream.prototype.pipe.apply(this, arguments)
	}
	
	Reader.prototype.pause = function (who) {
	  this._paused = true
	  who = who || this
	  this.emit('pause', who)
	  if (this._stream) this._stream.pause(who)
	}
	
	Reader.prototype.resume = function (who) {
	  this._paused = false
	  who = who || this
	  this.emit('resume', who)
	  if (this._stream) this._stream.resume(who)
	  this._read()
	}
	
	Reader.prototype._read = function () {
	  this.error('Cannot read unknown type: ' + this.type)
	}


/***/ },
/* 752 */
/*!**************************************!*\
  !*** ./~/graceful-fs/graceful-fs.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(/*! fs */ 531)
	var polyfills = __webpack_require__(/*! ./polyfills.js */ 753)
	var legacy = __webpack_require__(/*! ./legacy-streams.js */ 756)
	var queue = []
	
	var util = __webpack_require__(/*! util */ 597)
	
	function noop () {}
	
	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs4')
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
	    console.error(m)
	  }
	
	if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug(queue)
	    __webpack_require__(/*! assert */ 635).equal(queue.length, 0)
	  })
	}
	
	module.exports = patch(__webpack_require__(/*! ./fs.js */ 754))
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
	  module.exports = patch(fs)
	}
	
	// Always patch fs.close/closeSync, because we want to
	// retry() whenever a close happens *anywhere* in the program.
	// This is essential when multiple graceful-fs instances are
	// in play at the same time.
	module.exports.close =
	fs.close = (function (fs$close) { return function (fd, cb) {
	  return fs$close.call(fs, fd, function (err) {
	    if (!err)
	      retry()
	
	    if (typeof cb === 'function')
	      cb.apply(this, arguments)
	  })
	}})(fs.close)
	
	module.exports.closeSync =
	fs.closeSync = (function (fs$closeSync) { return function (fd) {
	  // Note that graceful-fs also retries when fs.closeSync() fails.
	  // Looks like a bug to me, although it's probably a harmless one.
	  var rval = fs$closeSync.apply(fs, arguments)
	  retry()
	  return rval
	}})(fs.closeSync)
	
	function patch (fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs)
	  fs.gracefulify = patch
	  fs.FileReadStream = ReadStream;  // Legacy name.
	  fs.FileWriteStream = WriteStream;  // Legacy name.
	  fs.createReadStream = createReadStream
	  fs.createWriteStream = createWriteStream
	  var fs$readFile = fs.readFile
	  fs.readFile = readFile
	  function readFile (path, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$readFile(path, options, cb)
	
	    function go$readFile (path, options, cb) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readFile, [path, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$writeFile = fs.writeFile
	  fs.writeFile = writeFile
	  function writeFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$writeFile(path, data, options, cb)
	
	    function go$writeFile (path, data, options, cb) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$writeFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$appendFile = fs.appendFile
	  if (fs$appendFile)
	    fs.appendFile = appendFile
	  function appendFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$appendFile(path, data, options, cb)
	
	    function go$appendFile (path, data, options, cb) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$appendFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$readdir = fs.readdir
	  fs.readdir = readdir
	  function readdir (path, cb) {
	    return go$readdir(path, cb)
	
	    function go$readdir () {
	      return fs$readdir(path, function (err, files) {
	        if (files && files.sort)
	          files.sort();  // Backwards compatibility with graceful-fs.
	
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readdir, [path, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	
	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs)
	    ReadStream = legStreams.ReadStream
	    WriteStream = legStreams.WriteStream
	  }
	
	  var fs$ReadStream = fs.ReadStream
	  ReadStream.prototype = Object.create(fs$ReadStream.prototype)
	  ReadStream.prototype.open = ReadStream$open
	
	  var fs$WriteStream = fs.WriteStream
	  WriteStream.prototype = Object.create(fs$WriteStream.prototype)
	  WriteStream.prototype.open = WriteStream$open
	
	  fs.ReadStream = ReadStream
	  fs.WriteStream = WriteStream
	
	  function ReadStream (path, options) {
	    if (this instanceof ReadStream)
	      return fs$ReadStream.apply(this, arguments), this
	    else
	      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
	  }
	
	  function ReadStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose)
	          that.destroy()
	
	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	        that.read()
	      }
	    })
	  }
	
	  function WriteStream (path, options) {
	    if (this instanceof WriteStream)
	      return fs$WriteStream.apply(this, arguments), this
	    else
	      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
	  }
	
	  function WriteStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy()
	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	      }
	    })
	  }
	
	  function createReadStream (path, options) {
	    return new ReadStream(path, options)
	  }
	
	  function createWriteStream (path, options) {
	    return new WriteStream(path, options)
	  }
	
	  var fs$open = fs.open
	  fs.open = open
	  function open (path, flags, mode, cb) {
	    if (typeof mode === 'function')
	      cb = mode, mode = null
	
	    return go$open(path, flags, mode, cb)
	
	    function go$open (path, flags, mode, cb) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$open, [path, flags, mode, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  return fs
	}
	
	function enqueue (elem) {
	  debug('ENQUEUE', elem[0].name, elem[1])
	  queue.push(elem)
	}
	
	function retry () {
	  var elem = queue.shift()
	  if (elem) {
	    debug('RETRY', elem[0].name, elem[1])
	    elem[0].apply(null, elem[1])
	  }
	}


/***/ },
/* 753 */
/*!************************************!*\
  !*** ./~/graceful-fs/polyfills.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var fs = __webpack_require__(/*! ./fs.js */ 754)
	var constants = __webpack_require__(/*! constants */ 755)
	
	var origCwd = process.cwd
	var cwd = null
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	try {
	  process.cwd()
	} catch (er) {}
	
	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}
	
	module.exports = patch
	
	function patch (fs) {
	  // (re-)implement some things that are known busted or missing.
	
	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') &&
	      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs)
	  }
	
	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs)
	  }
	
	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.
	
	  fs.chown = chownFix(fs.chown)
	  fs.fchown = chownFix(fs.fchown)
	  fs.lchown = chownFix(fs.lchown)
	
	  fs.chmod = chownFix(fs.chmod)
	  fs.fchmod = chownFix(fs.fchmod)
	  fs.lchmod = chownFix(fs.lchmod)
	
	  fs.chownSync = chownFixSync(fs.chownSync)
	  fs.fchownSync = chownFixSync(fs.fchownSync)
	  fs.lchownSync = chownFixSync(fs.lchownSync)
	
	  fs.chmodSync = chownFix(fs.chmodSync)
	  fs.fchmodSync = chownFix(fs.fchmodSync)
	  fs.lchmodSync = chownFix(fs.lchmodSync)
	
	  // if lchmod/lchown do not exist, then make them no-ops
	  if (!fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      process.nextTick(cb)
	    }
	    fs.lchmodSync = function () {}
	  }
	  if (!fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      process.nextTick(cb)
	    }
	    fs.lchownSync = function () {}
	  }
	
	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 1 second.
	  if (process.platform === "win32") {
	    fs.rename = (function (fs$rename) { return function (from, to, cb) {
	      var start = Date.now()
	      fs$rename(from, to, function CB (er) {
	        if (er
	            && (er.code === "EACCES" || er.code === "EPERM")
	            && Date.now() - start < 1000) {
	          return fs$rename(from, to, CB)
	        }
	        if (cb) cb(er)
	      })
	    }})(fs.rename)
	  }
	
	  // if read() returns EAGAIN, then just try it again.
	  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
	    var callback
	    if (callback_ && typeof callback_ === 'function') {
	      var eagCounter = 0
	      callback = function (er, _, __) {
	        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	        }
	        callback_.apply(this, arguments)
	      }
	    }
	    return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	  }})(fs.read)
	
	  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
	    var eagCounter = 0
	    while (true) {
	      try {
	        return fs$readSync.call(fs, fd, buffer, offset, length, position)
	      } catch (er) {
	        if (er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          continue
	        }
	        throw er
	      }
	    }
	  }})(fs.readSync)
	}
	
	function patchLchmod (fs) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          callback(err || err2)
	        })
	      })
	    })
	  }
	
	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
	
	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var threw = true
	    var ret
	    try {
	      ret = fs.fchmodSync(fd, mode)
	      threw = false
	    } finally {
	      if (threw) {
	        try {
	          fs.closeSync(fd)
	        } catch (er) {}
	      } else {
	        fs.closeSync(fd)
	      }
	    }
	    return ret
	  }
	}
	
	function patchLutimes (fs) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop
	        if (er) return cb(er)
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2)
	          })
	        })
	      })
	    }
	
	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	      var ret
	      var threw = true
	      try {
	        ret = fs.futimesSync(fd, at, mt)
	        threw = false
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd)
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd)
	        }
	      }
	      return ret
	    }
	
	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}
	
	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null
	      cb(er, res)
	    })
	  }
	}
	
	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}
	
	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk (er) {
	  if (!er)
	    return true
	
	  if (er.code === "ENOSYS")
	    return true
	
	  var nonroot = !process.getuid || process.getuid() !== 0
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM")
	      return true
	  }
	
	  return false
	}


/***/ },
/* 754 */
/*!*****************************!*\
  !*** ./~/graceful-fs/fs.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var fs = __webpack_require__(/*! fs */ 531)
	
	module.exports = clone(fs)
	
	function clone (obj) {
	  if (obj === null || typeof obj !== 'object')
	    return obj
	
	  if (obj instanceof Object)
	    var copy = { __proto__: obj.__proto__ }
	  else
	    var copy = Object.create(null)
	
	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
	  })
	
	  return copy
	}


/***/ },
/* 755 */
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ function(module, exports) {

	module.exports = require("constants");

/***/ },
/* 756 */
/*!*****************************************!*\
  !*** ./~/graceful-fs/legacy-streams.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(/*! stream */ 604).Stream
	
	module.exports = legacy
	
	function legacy (fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  }
	
	  function ReadStream (path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);
	
	    Stream.call(this);
	
	    var self = this;
	
	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;
	
	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;
	
	    options = options || {};
	
	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	
	    if (this.encoding) this.setEncoding(this.encoding);
	
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }
	
	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }
	
	      this.pos = this.start;
	    }
	
	    if (this.fd !== null) {
	      process.nextTick(function() {
	        self._read();
	      });
	      return;
	    }
	
	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }
	
	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    })
	  }
	
	  function WriteStream (path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);
	
	    Stream.call(this);
	
	    this.path = path;
	    this.fd = null;
	    this.writable = true;
	
	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;
	
	    options = options || {};
	
	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }
	
	      this.pos = this.start;
	    }
	
	    this.busy = false;
	    this._queue = [];
	
	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}


/***/ },
/* 757 */
/*!***********************************!*\
  !*** ./~/fstream/lib/get-type.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = getType
	
	function getType (st) {
	  var types = [
	    'Directory',
	    'File',
	    'SymbolicLink',
	    'Link', // special for hardlinks from tarballs
	    'BlockDevice',
	    'CharacterDevice',
	    'FIFO',
	    'Socket'
	  ]
	  var type
	
	  if (st.type && types.indexOf(st.type) !== -1) {
	    st[st.type] = true
	    return st.type
	  }
	
	  for (var i = 0, l = types.length; i < l; i++) {
	    type = types[i]
	    var is = st[type] || st['is' + type]
	    if (typeof is === 'function') is = is.call(st)
	    if (is) {
	      st[type] = true
	      st.type = type
	      return type
	    }
	  }
	
	  return null
	}


/***/ },
/* 758 */
/*!**************************************!*\
  !*** ./~/fstream/lib/link-reader.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	// Basically just a wrapper around an fs.readlink
	//
	// XXX: Enhance this to support the Link type, by keeping
	// a lookup table of {<dev+inode>:<path>}, so that hardlinks
	// can be preserved in tarballs.
	
	module.exports = LinkReader
	
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var Reader = __webpack_require__(/*! ./reader.js */ 751)
	
	inherits(LinkReader, Reader)
	
	function LinkReader (props) {
	  var self = this
	  if (!(self instanceof LinkReader)) {
	    throw new Error('LinkReader must be called as constructor.')
	  }
	
	  if (!((props.type === 'Link' && props.Link) ||
	    (props.type === 'SymbolicLink' && props.SymbolicLink))) {
	    throw new Error('Non-link type ' + props.type)
	  }
	
	  Reader.call(self, props)
	}
	
	// When piping a LinkReader into a LinkWriter, we have to
	// already have the linkpath property set, so that has to
	// happen *before* the "ready" event, which means we need to
	// override the _stat method.
	LinkReader.prototype._stat = function (currentStat) {
	  var self = this
	  fs.readlink(self._path, function (er, linkpath) {
	    if (er) return self.error(er)
	    self.linkpath = self.props.linkpath = linkpath
	    self.emit('linkpath', linkpath)
	    Reader.prototype._stat.call(self, currentStat)
	  })
	}
	
	LinkReader.prototype._read = function () {
	  var self = this
	  if (self._paused) return
	  // basically just a no-op, since we got all the info we need
	  // from the _stat method
	  if (!self._ended) {
	    self.emit('end')
	    self.emit('close')
	    self._ended = true
	  }
	}


/***/ },
/* 759 */
/*!*************************************!*\
  !*** ./~/fstream/lib/dir-reader.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	// A thing that emits "entry" events with Reader objects
	// Pausing it causes it to stop emitting entry events, and also
	// pauses the current entry if there is one.
	
	module.exports = DirReader
	
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var path = __webpack_require__(/*! path */ 521)
	var Reader = __webpack_require__(/*! ./reader.js */ 751)
	var assert = __webpack_require__(/*! assert */ 635).ok
	
	inherits(DirReader, Reader)
	
	function DirReader (props) {
	  var self = this
	  if (!(self instanceof DirReader)) {
	    throw new Error('DirReader must be called as constructor.')
	  }
	
	  // should already be established as a Directory type
	  if (props.type !== 'Directory' || !props.Directory) {
	    throw new Error('Non-directory type ' + props.type)
	  }
	
	  self.entries = null
	  self._index = -1
	  self._paused = false
	  self._length = -1
	
	  if (props.sort) {
	    this.sort = props.sort
	  }
	
	  Reader.call(this, props)
	}
	
	DirReader.prototype._getEntries = function () {
	  var self = this
	
	  // race condition.  might pause() before calling _getEntries,
	  // and then resume, and try to get them a second time.
	  if (self._gotEntries) return
	  self._gotEntries = true
	
	  fs.readdir(self._path, function (er, entries) {
	    if (er) return self.error(er)
	
	    self.entries = entries
	
	    self.emit('entries', entries)
	    if (self._paused) self.once('resume', processEntries)
	    else processEntries()
	
	    function processEntries () {
	      self._length = self.entries.length
	      if (typeof self.sort === 'function') {
	        self.entries = self.entries.sort(self.sort.bind(self))
	      }
	      self._read()
	    }
	  })
	}
	
	// start walking the dir, and emit an "entry" event for each one.
	DirReader.prototype._read = function () {
	  var self = this
	
	  if (!self.entries) return self._getEntries()
	
	  if (self._paused || self._currentEntry || self._aborted) {
	    // console.error('DR paused=%j, current=%j, aborted=%j', self._paused, !!self._currentEntry, self._aborted)
	    return
	  }
	
	  self._index++
	  if (self._index >= self.entries.length) {
	    if (!self._ended) {
	      self._ended = true
	      self.emit('end')
	      self.emit('close')
	    }
	    return
	  }
	
	  // ok, handle this one, then.
	
	  // save creating a proxy, by stat'ing the thing now.
	  var p = path.resolve(self._path, self.entries[self._index])
	  assert(p !== self._path)
	  assert(self.entries[self._index])
	
	  // set this to prevent trying to _read() again in the stat time.
	  self._currentEntry = p
	  fs[ self.props.follow ? 'stat' : 'lstat' ](p, function (er, stat) {
	    if (er) return self.error(er)
	
	    var who = self._proxy || self
	
	    stat.path = p
	    stat.basename = path.basename(p)
	    stat.dirname = path.dirname(p)
	    var childProps = self.getChildProps.call(who, stat)
	    childProps.path = p
	    childProps.basename = path.basename(p)
	    childProps.dirname = path.dirname(p)
	
	    var entry = Reader(childProps, stat)
	
	    // console.error("DR Entry", p, stat.size)
	
	    self._currentEntry = entry
	
	    // "entry" events are for direct entries in a specific dir.
	    // "child" events are for any and all children at all levels.
	    // This nomenclature is not completely final.
	
	    entry.on('pause', function (who) {
	      if (!self._paused && !entry._disowned) {
	        self.pause(who)
	      }
	    })
	
	    entry.on('resume', function (who) {
	      if (self._paused && !entry._disowned) {
	        self.resume(who)
	      }
	    })
	
	    entry.on('stat', function (props) {
	      self.emit('_entryStat', entry, props)
	      if (entry._aborted) return
	      if (entry._paused) {
	        entry.once('resume', function () {
	          self.emit('entryStat', entry, props)
	        })
	      } else self.emit('entryStat', entry, props)
	    })
	
	    entry.on('ready', function EMITCHILD () {
	      // console.error("DR emit child", entry._path)
	      if (self._paused) {
	        // console.error("  DR emit child - try again later")
	        // pause the child, and emit the "entry" event once we drain.
	        // console.error("DR pausing child entry")
	        entry.pause(self)
	        return self.once('resume', EMITCHILD)
	      }
	
	      // skip over sockets.  they can't be piped around properly,
	      // so there's really no sense even acknowledging them.
	      // if someone really wants to see them, they can listen to
	      // the "socket" events.
	      if (entry.type === 'Socket') {
	        self.emit('socket', entry)
	      } else {
	        self.emitEntry(entry)
	      }
	    })
	
	    var ended = false
	    entry.on('close', onend)
	    entry.on('disown', onend)
	    function onend () {
	      if (ended) return
	      ended = true
	      self.emit('childEnd', entry)
	      self.emit('entryEnd', entry)
	      self._currentEntry = null
	      if (!self._paused) {
	        self._read()
	      }
	    }
	
	    // XXX Remove this.  Works in node as of 0.6.2 or so.
	    // Long filenames should not break stuff.
	    entry.on('error', function (er) {
	      if (entry._swallowErrors) {
	        self.warn(er)
	        entry.emit('end')
	        entry.emit('close')
	      } else {
	        self.emit('error', er)
	      }
	    })
	
	    // proxy up some events.
	    ;[
	      'child',
	      'childEnd',
	      'warn'
	    ].forEach(function (ev) {
	      entry.on(ev, self.emit.bind(self, ev))
	    })
	  })
	}
	
	DirReader.prototype.disown = function (entry) {
	  entry.emit('beforeDisown')
	  entry._disowned = true
	  entry.parent = entry.root = null
	  if (entry === this._currentEntry) {
	    this._currentEntry = null
	  }
	  entry.emit('disown')
	}
	
	DirReader.prototype.getChildProps = function () {
	  return {
	    depth: this.depth + 1,
	    root: this.root || this,
	    parent: this,
	    follow: this.follow,
	    filter: this.filter,
	    sort: this.props.sort,
	    hardlinks: this.props.hardlinks
	  }
	}
	
	DirReader.prototype.pause = function (who) {
	  var self = this
	  if (self._paused) return
	  who = who || self
	  self._paused = true
	  if (self._currentEntry && self._currentEntry.pause) {
	    self._currentEntry.pause(who)
	  }
	  self.emit('pause', who)
	}
	
	DirReader.prototype.resume = function (who) {
	  var self = this
	  if (!self._paused) return
	  who = who || self
	
	  self._paused = false
	  // console.error('DR Emit Resume', self._path)
	  self.emit('resume', who)
	  if (self._paused) {
	    // console.error('DR Re-paused', self._path)
	    return
	  }
	
	  if (self._currentEntry) {
	    if (self._currentEntry.resume) self._currentEntry.resume(who)
	  } else self._read()
	}
	
	DirReader.prototype.emitEntry = function (entry) {
	  this.emit('entry', entry)
	  this.emit('child', entry)
	}


/***/ },
/* 760 */
/*!**************************************!*\
  !*** ./~/fstream/lib/file-reader.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	// Basically just a wrapper around an fs.ReadStream
	
	module.exports = FileReader
	
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var Reader = __webpack_require__(/*! ./reader.js */ 751)
	var EOF = {EOF: true}
	var CLOSE = {CLOSE: true}
	
	inherits(FileReader, Reader)
	
	function FileReader (props) {
	  // console.error("    FR create", props.path, props.size, new Error().stack)
	  var self = this
	  if (!(self instanceof FileReader)) {
	    throw new Error('FileReader must be called as constructor.')
	  }
	
	  // should already be established as a File type
	  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,
	  // with a HardLinkReader class.
	  if (!((props.type === 'Link' && props.Link) ||
	    (props.type === 'File' && props.File))) {
	    throw new Error('Non-file type ' + props.type)
	  }
	
	  self._buffer = []
	  self._bytesEmitted = 0
	  Reader.call(self, props)
	}
	
	FileReader.prototype._getStream = function () {
	  var self = this
	  var stream = self._stream = fs.createReadStream(self._path, self.props)
	
	  if (self.props.blksize) {
	    stream.bufferSize = self.props.blksize
	  }
	
	  stream.on('open', self.emit.bind(self, 'open'))
	
	  stream.on('data', function (c) {
	    // console.error('\t\t%d %s', c.length, self.basename)
	    self._bytesEmitted += c.length
	    // no point saving empty chunks
	    if (!c.length) {
	      return
	    } else if (self._paused || self._buffer.length) {
	      self._buffer.push(c)
	      self._read()
	    } else self.emit('data', c)
	  })
	
	  stream.on('end', function () {
	    if (self._paused || self._buffer.length) {
	      // console.error('FR Buffering End', self._path)
	      self._buffer.push(EOF)
	      self._read()
	    } else {
	      self.emit('end')
	    }
	
	    if (self._bytesEmitted !== self.props.size) {
	      self.error("Didn't get expected byte count\n" +
	        'expect: ' + self.props.size + '\n' +
	        'actual: ' + self._bytesEmitted)
	    }
	  })
	
	  stream.on('close', function () {
	    if (self._paused || self._buffer.length) {
	      // console.error('FR Buffering Close', self._path)
	      self._buffer.push(CLOSE)
	      self._read()
	    } else {
	      // console.error('FR close 1', self._path)
	      self.emit('close')
	    }
	  })
	
	  stream.on('error', function (e) {
	    self.emit('error', e)
	  })
	
	  self._read()
	}
	
	FileReader.prototype._read = function () {
	  var self = this
	  // console.error('FR _read', self._path)
	  if (self._paused) {
	    // console.error('FR _read paused', self._path)
	    return
	  }
	
	  if (!self._stream) {
	    // console.error('FR _getStream calling', self._path)
	    return self._getStream()
	  }
	
	  // clear out the buffer, if there is one.
	  if (self._buffer.length) {
	    // console.error('FR _read has buffer', self._buffer.length, self._path)
	    var buf = self._buffer
	    for (var i = 0, l = buf.length; i < l; i++) {
	      var c = buf[i]
	      if (c === EOF) {
	        // console.error('FR Read emitting buffered end', self._path)
	        self.emit('end')
	      } else if (c === CLOSE) {
	        // console.error('FR Read emitting buffered close', self._path)
	        self.emit('close')
	      } else {
	        // console.error('FR Read emitting buffered data', self._path)
	        self.emit('data', c)
	      }
	
	      if (self._paused) {
	        // console.error('FR Read Re-pausing at '+i, self._path)
	        self._buffer = buf.slice(i)
	        return
	      }
	    }
	    self._buffer.length = 0
	  }
	// console.error("FR _read done")
	// that's about all there is to it.
	}
	
	FileReader.prototype.pause = function (who) {
	  var self = this
	  // console.error('FR Pause', self._path)
	  if (self._paused) return
	  who = who || self
	  self._paused = true
	  if (self._stream) self._stream.pause()
	  self.emit('pause', who)
	}
	
	FileReader.prototype.resume = function (who) {
	  var self = this
	  // console.error('FR Resume', self._path)
	  if (!self._paused) return
	  who = who || self
	  self.emit('resume', who)
	  self._paused = false
	  if (self._stream) self._stream.resume()
	  self._read()
	}


/***/ },
/* 761 */
/*!****************************************!*\
  !*** ./~/fstream/lib/socket-reader.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// Just get the stats, and then don't do anything.
	// You can't really "read" from a socket.  You "connect" to it.
	// Mostly, this is here so that reading a dir with a socket in it
	// doesn't blow up.
	
	module.exports = SocketReader
	
	var inherits = __webpack_require__(/*! inherits */ 610)
	var Reader = __webpack_require__(/*! ./reader.js */ 751)
	
	inherits(SocketReader, Reader)
	
	function SocketReader (props) {
	  var self = this
	  if (!(self instanceof SocketReader)) {
	    throw new Error('SocketReader must be called as constructor.')
	  }
	
	  if (!(props.type === 'Socket' && props.Socket)) {
	    throw new Error('Non-socket type ' + props.type)
	  }
	
	  Reader.call(self, props)
	}
	
	SocketReader.prototype._read = function () {
	  var self = this
	  if (self._paused) return
	  // basically just a no-op, since we got all the info we have
	  // from the _stat method
	  if (!self._ended) {
	    self.emit('end')
	    self.emit('close')
	    self._ended = true
	  }
	}


/***/ },
/* 762 */
/*!***************************************!*\
  !*** ./~/fstream/lib/proxy-reader.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// A reader for when we don't yet know what kind of thing
	// the thing is.
	
	module.exports = ProxyReader
	
	var Reader = __webpack_require__(/*! ./reader.js */ 751)
	var getType = __webpack_require__(/*! ./get-type.js */ 757)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	
	inherits(ProxyReader, Reader)
	
	function ProxyReader (props) {
	  var self = this
	  if (!(self instanceof ProxyReader)) {
	    throw new Error('ProxyReader must be called as constructor.')
	  }
	
	  self.props = props
	  self._buffer = []
	  self.ready = false
	
	  Reader.call(self, props)
	}
	
	ProxyReader.prototype._stat = function () {
	  var self = this
	  var props = self.props
	  // stat the thing to see what the proxy should be.
	  var stat = props.follow ? 'stat' : 'lstat'
	
	  fs[stat](props.path, function (er, current) {
	    var type
	    if (er || !current) {
	      type = 'File'
	    } else {
	      type = getType(current)
	    }
	
	    props[type] = true
	    props.type = self.type = type
	
	    self._old = current
	    self._addProxy(Reader(props, current))
	  })
	}
	
	ProxyReader.prototype._addProxy = function (proxy) {
	  var self = this
	  if (self._proxyTarget) {
	    return self.error('proxy already set')
	  }
	
	  self._proxyTarget = proxy
	  proxy._proxy = self
	
	  ;[
	    'error',
	    'data',
	    'end',
	    'close',
	    'linkpath',
	    'entry',
	    'entryEnd',
	    'child',
	    'childEnd',
	    'warn',
	    'stat'
	  ].forEach(function (ev) {
	    // console.error('~~ proxy event', ev, self.path)
	    proxy.on(ev, self.emit.bind(self, ev))
	  })
	
	  self.emit('proxy', proxy)
	
	  proxy.on('ready', function () {
	    // console.error("~~ proxy is ready!", self.path)
	    self.ready = true
	    self.emit('ready')
	  })
	
	  var calls = self._buffer
	  self._buffer.length = 0
	  calls.forEach(function (c) {
	    proxy[c[0]].apply(proxy, c[1])
	  })
	}
	
	ProxyReader.prototype.pause = function () {
	  return this._proxyTarget ? this._proxyTarget.pause() : false
	}
	
	ProxyReader.prototype.resume = function () {
	  return this._proxyTarget ? this._proxyTarget.resume() : false
	}


/***/ },
/* 763 */
/*!*********************************!*\
  !*** ./~/fstream/lib/writer.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = Writer
	
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var rimraf = __webpack_require__(/*! rimraf */ 764)
	var mkdir = __webpack_require__(/*! mkdirp */ 778)
	var path = __webpack_require__(/*! path */ 521)
	var umask = process.platform === 'win32' ? 0 : process.umask()
	var getType = __webpack_require__(/*! ./get-type.js */ 757)
	var Abstract = __webpack_require__(/*! ./abstract.js */ 750)
	
	// Must do this *before* loading the child classes
	inherits(Writer, Abstract)
	
	Writer.dirmode = parseInt('0777', 8) & (~umask)
	Writer.filemode = parseInt('0666', 8) & (~umask)
	
	var DirWriter = __webpack_require__(/*! ./dir-writer.js */ 779)
	var LinkWriter = __webpack_require__(/*! ./link-writer.js */ 781)
	var FileWriter = __webpack_require__(/*! ./file-writer.js */ 782)
	var ProxyWriter = __webpack_require__(/*! ./proxy-writer.js */ 783)
	
	// props is the desired state.  current is optionally the current stat,
	// provided here so that subclasses can avoid statting the target
	// more than necessary.
	function Writer (props, current) {
	  var self = this
	
	  if (typeof props === 'string') {
	    props = { path: props }
	  }
	
	  if (!props.path) self.error('Must provide a path', null, true)
	
	  // polymorphism.
	  // call fstream.Writer(dir) to get a DirWriter object, etc.
	  var type = getType(props)
	  var ClassType = Writer
	
	  switch (type) {
	    case 'Directory':
	      ClassType = DirWriter
	      break
	    case 'File':
	      ClassType = FileWriter
	      break
	    case 'Link':
	    case 'SymbolicLink':
	      ClassType = LinkWriter
	      break
	    case null:
	    default:
	      // Don't know yet what type to create, so we wrap in a proxy.
	      ClassType = ProxyWriter
	      break
	  }
	
	  if (!(self instanceof ClassType)) return new ClassType(props)
	
	  // now get down to business.
	
	  Abstract.call(self)
	
	  // props is what we want to set.
	  // set some convenience properties as well.
	  self.type = props.type
	  self.props = props
	  self.depth = props.depth || 0
	  self.clobber = props.clobber === false ? props.clobber : true
	  self.parent = props.parent || null
	  self.root = props.root || (props.parent && props.parent.root) || self
	
	  self._path = self.path = path.resolve(props.path)
	  if (process.platform === 'win32') {
	    self.path = self._path = self.path.replace(/\?/g, '_')
	    if (self._path.length >= 260) {
	      self._swallowErrors = true
	      self._path = '\\\\?\\' + self.path.replace(/\//g, '\\')
	    }
	  }
	  self.basename = path.basename(props.path)
	  self.dirname = path.dirname(props.path)
	  self.linkpath = props.linkpath || null
	
	  props.parent = props.root = null
	
	  // console.error("\n\n\n%s setting size to", props.path, props.size)
	  self.size = props.size
	
	  if (typeof props.mode === 'string') {
	    props.mode = parseInt(props.mode, 8)
	  }
	
	  self.readable = false
	  self.writable = true
	
	  // buffer until ready, or while handling another entry
	  self._buffer = []
	  self.ready = false
	
	  self.filter = typeof props.filter === 'function' ? props.filter : null
	
	  // start the ball rolling.
	  // this checks what's there already, and then calls
	  // self._create() to call the impl-specific creation stuff.
	  self._stat(current)
	}
	
	// Calling this means that it's something we can't create.
	// Just assert that it's already there, otherwise raise a warning.
	Writer.prototype._create = function () {
	  var self = this
	  fs[self.props.follow ? 'stat' : 'lstat'](self._path, function (er) {
	    if (er) {
	      return self.warn('Cannot create ' + self._path + '\n' +
	        'Unsupported type: ' + self.type, 'ENOTSUP')
	    }
	    self._finish()
	  })
	}
	
	Writer.prototype._stat = function (current) {
	  var self = this
	  var props = self.props
	  var stat = props.follow ? 'stat' : 'lstat'
	  var who = self._proxy || self
	
	  if (current) statCb(null, current)
	  else fs[stat](self._path, statCb)
	
	  function statCb (er, current) {
	    if (self.filter && !self.filter.call(who, who, current)) {
	      self._aborted = true
	      self.emit('end')
	      self.emit('close')
	      return
	    }
	
	    // if it's not there, great.  We'll just create it.
	    // if it is there, then we'll need to change whatever differs
	    if (er || !current) {
	      return create(self)
	    }
	
	    self._old = current
	    var currentType = getType(current)
	
	    // if it's a type change, then we need to clobber or error.
	    // if it's not a type change, then let the impl take care of it.
	    if (currentType !== self.type) {
	      return rimraf(self._path, function (er) {
	        if (er) return self.error(er)
	        self._old = null
	        create(self)
	      })
	    }
	
	    // otherwise, just handle in the app-specific way
	    // this creates a fs.WriteStream, or mkdir's, or whatever
	    create(self)
	  }
	}
	
	function create (self) {
	  // console.error("W create", self._path, Writer.dirmode)
	
	  // XXX Need to clobber non-dirs that are in the way,
	  // unless { clobber: false } in the props.
	  mkdir(path.dirname(self._path), Writer.dirmode, function (er, made) {
	    // console.error("W created", path.dirname(self._path), er)
	    if (er) return self.error(er)
	
	    // later on, we have to set the mode and owner for these
	    self._madeDir = made
	    return self._create()
	  })
	}
	
	function endChmod (self, want, current, path, cb) {
	  var wantMode = want.mode
	  var chmod = want.follow || self.type !== 'SymbolicLink'
	    ? 'chmod' : 'lchmod'
	
	  if (!fs[chmod]) return cb()
	  if (typeof wantMode !== 'number') return cb()
	
	  var curMode = current.mode & parseInt('0777', 8)
	  wantMode = wantMode & parseInt('0777', 8)
	  if (wantMode === curMode) return cb()
	
	  fs[chmod](path, wantMode, cb)
	}
	
	function endChown (self, want, current, path, cb) {
	  // Don't even try it unless root.  Too easy to EPERM.
	  if (process.platform === 'win32') return cb()
	  if (!process.getuid || process.getuid() !== 0) return cb()
	  if (typeof want.uid !== 'number' &&
	    typeof want.gid !== 'number') return cb()
	
	  if (current.uid === want.uid &&
	    current.gid === want.gid) return cb()
	
	  var chown = (self.props.follow || self.type !== 'SymbolicLink')
	    ? 'chown' : 'lchown'
	  if (!fs[chown]) return cb()
	
	  if (typeof want.uid !== 'number') want.uid = current.uid
	  if (typeof want.gid !== 'number') want.gid = current.gid
	
	  fs[chown](path, want.uid, want.gid, cb)
	}
	
	function endUtimes (self, want, current, path, cb) {
	  if (!fs.utimes || process.platform === 'win32') return cb()
	
	  var utimes = (want.follow || self.type !== 'SymbolicLink')
	    ? 'utimes' : 'lutimes'
	
	  if (utimes === 'lutimes' && !fs[utimes]) {
	    utimes = 'utimes'
	  }
	
	  if (!fs[utimes]) return cb()
	
	  var curA = current.atime
	  var curM = current.mtime
	  var meA = want.atime
	  var meM = want.mtime
	
	  if (meA === undefined) meA = curA
	  if (meM === undefined) meM = curM
	
	  if (!isDate(meA)) meA = new Date(meA)
	  if (!isDate(meM)) meA = new Date(meM)
	
	  if (meA.getTime() === curA.getTime() &&
	    meM.getTime() === curM.getTime()) return cb()
	
	  fs[utimes](path, meA, meM, cb)
	}
	
	// XXX This function is beastly.  Break it up!
	Writer.prototype._finish = function () {
	  var self = this
	
	  if (self._finishing) return
	  self._finishing = true
	
	  // console.error(" W Finish", self._path, self.size)
	
	  // set up all the things.
	  // At this point, we're already done writing whatever we've gotta write,
	  // adding files to the dir, etc.
	  var todo = 0
	  var errState = null
	  var done = false
	
	  if (self._old) {
	    // the times will almost *certainly* have changed.
	    // adds the utimes syscall, but remove another stat.
	    self._old.atime = new Date(0)
	    self._old.mtime = new Date(0)
	    // console.error(" W Finish Stale Stat", self._path, self.size)
	    setProps(self._old)
	  } else {
	    var stat = self.props.follow ? 'stat' : 'lstat'
	    // console.error(" W Finish Stating", self._path, self.size)
	    fs[stat](self._path, function (er, current) {
	      // console.error(" W Finish Stated", self._path, self.size, current)
	      if (er) {
	        // if we're in the process of writing out a
	        // directory, it's very possible that the thing we're linking to
	        // doesn't exist yet (especially if it was intended as a symlink),
	        // so swallow ENOENT errors here and just soldier on.
	        if (er.code === 'ENOENT' &&
	          (self.type === 'Link' || self.type === 'SymbolicLink') &&
	          process.platform === 'win32') {
	          self.ready = true
	          self.emit('ready')
	          self.emit('end')
	          self.emit('close')
	          self.end = self._finish = function () {}
	          return
	        } else return self.error(er)
	      }
	      setProps(self._old = current)
	    })
	  }
	
	  return
	
	  function setProps (current) {
	    todo += 3
	    endChmod(self, self.props, current, self._path, next('chmod'))
	    endChown(self, self.props, current, self._path, next('chown'))
	    endUtimes(self, self.props, current, self._path, next('utimes'))
	  }
	
	  function next (what) {
	    return function (er) {
	      // console.error("   W Finish", what, todo)
	      if (errState) return
	      if (er) {
	        er.fstream_finish_call = what
	        return self.error(errState = er)
	      }
	      if (--todo > 0) return
	      if (done) return
	      done = true
	
	      // we may still need to set the mode/etc. on some parent dirs
	      // that were created previously.  delay end/close until then.
	      if (!self._madeDir) return end()
	      else endMadeDir(self, self._path, end)
	
	      function end (er) {
	        if (er) {
	          er.fstream_finish_call = 'setupMadeDir'
	          return self.error(er)
	        }
	        // all the props have been set, so we're completely done.
	        self.emit('end')
	        self.emit('close')
	      }
	    }
	  }
	}
	
	function endMadeDir (self, p, cb) {
	  var made = self._madeDir
	  // everything *between* made and path.dirname(self._path)
	  // needs to be set up.  Note that this may just be one dir.
	  var d = path.dirname(p)
	
	  endMadeDir_(self, d, function (er) {
	    if (er) return cb(er)
	    if (d === made) {
	      return cb()
	    }
	    endMadeDir(self, d, cb)
	  })
	}
	
	function endMadeDir_ (self, p, cb) {
	  var dirProps = {}
	  Object.keys(self.props).forEach(function (k) {
	    dirProps[k] = self.props[k]
	
	    // only make non-readable dirs if explicitly requested.
	    if (k === 'mode' && self.type !== 'Directory') {
	      dirProps[k] = dirProps[k] | parseInt('0111', 8)
	    }
	  })
	
	  var todo = 3
	  var errState = null
	  fs.stat(p, function (er, current) {
	    if (er) return cb(errState = er)
	    endChmod(self, dirProps, current, p, next)
	    endChown(self, dirProps, current, p, next)
	    endUtimes(self, dirProps, current, p, next)
	  })
	
	  function next (er) {
	    if (errState) return
	    if (er) return cb(errState = er)
	    if (--todo === 0) return cb()
	  }
	}
	
	Writer.prototype.pipe = function () {
	  this.error("Can't pipe from writable stream")
	}
	
	Writer.prototype.add = function () {
	  this.error("Can't add to non-Directory type")
	}
	
	Writer.prototype.write = function () {
	  return true
	}
	
	function objectToString (d) {
	  return Object.prototype.toString.call(d)
	}
	
	function isDate (d) {
	  return typeof d === 'object' && objectToString(d) === '[object Date]'
	}


/***/ },
/* 764 */
/*!****************************!*\
  !*** ./~/rimraf/rimraf.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = rimraf
	rimraf.sync = rimrafSync
	
	var assert = __webpack_require__(/*! assert */ 635)
	var path = __webpack_require__(/*! path */ 521)
	var fs = __webpack_require__(/*! fs */ 531)
	var glob = __webpack_require__(/*! glob */ 765)
	
	var globOpts = {
	  nosort: true,
	  nocomment: true,
	  nonegate: true,
	  silent: true
	}
	
	// for EMFILE handling
	var timeout = 0
	
	var isWindows = (process.platform === "win32")
	
	function defaults (options) {
	  var methods = [
	    'unlink',
	    'chmod',
	    'stat',
	    'lstat',
	    'rmdir',
	    'readdir'
	  ]
	  methods.forEach(function(m) {
	    options[m] = options[m] || fs[m]
	    m = m + 'Sync'
	    options[m] = options[m] || fs[m]
	  })
	
	  options.maxBusyTries = options.maxBusyTries || 3
	  options.emfileWait = options.emfileWait || 1000
	  options.disableGlob = options.disableGlob || false
	}
	
	function rimraf (p, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = {}
	  }
	
	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert(options, 'rimraf: missing options')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')
	  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
	
	  defaults(options)
	
	  var busyTries = 0
	  var errState = null
	  var n = 0
	
	  if (options.disableGlob || !glob.hasMagic(p))
	    return afterGlob(null, [p])
	
	  fs.lstat(p, function (er, stat) {
	    if (!er)
	      return afterGlob(null, [p])
	
	    glob(p, globOpts, afterGlob)
	  })
	
	  function next (er) {
	    errState = errState || er
	    if (--n === 0)
	      cb(errState)
	  }
	
	  function afterGlob (er, results) {
	    if (er)
	      return cb(er)
	
	    n = results.length
	    if (n === 0)
	      return cb()
	
	    results.forEach(function (p) {
	      rimraf_(p, options, function CB (er) {
	        if (er) {
	          if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
	              busyTries < options.maxBusyTries) {
	            busyTries ++
	            var time = busyTries * 100
	            // try again, with the same exact callback as this one.
	            return setTimeout(function () {
	              rimraf_(p, options, CB)
	            }, time)
	          }
	
	          // this one won't happen if graceful-fs is used.
	          if (er.code === "EMFILE" && timeout < options.emfileWait) {
	            return setTimeout(function () {
	              rimraf_(p, options, CB)
	            }, timeout ++)
	          }
	
	          // already gone
	          if (er.code === "ENOENT") er = null
	        }
	
	        timeout = 0
	        next(er)
	      })
	    })
	  }
	}
	
	// Two possible strategies.
	// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
	// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
	//
	// Both result in an extra syscall when you guess wrong.  However, there
	// are likely far more normal files in the world than directories.  This
	// is based on the assumption that a the average number of files per
	// directory is >= 1.
	//
	// If anyone ever complains about this, then I guess the strategy could
	// be made configurable somehow.  But until then, YAGNI.
	function rimraf_ (p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')
	
	  // sunos lets the root user unlink directories, which is... weird.
	  // so we have to lstat here and make sure it's not a dir.
	  options.lstat(p, function (er, st) {
	    if (er && er.code === "ENOENT")
	      return cb(null)
	
	    if (st && st.isDirectory())
	      return rmdir(p, options, er, cb)
	
	    options.unlink(p, function (er) {
	      if (er) {
	        if (er.code === "ENOENT")
	          return cb(null)
	        if (er.code === "EPERM")
	          return (isWindows)
	            ? fixWinEPERM(p, options, er, cb)
	            : rmdir(p, options, er, cb)
	        if (er.code === "EISDIR")
	          return rmdir(p, options, er, cb)
	      }
	      return cb(er)
	    })
	  })
	}
	
	function fixWinEPERM (p, options, er, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')
	  if (er)
	    assert(er instanceof Error)
	
	  options.chmod(p, 666, function (er2) {
	    if (er2)
	      cb(er2.code === "ENOENT" ? null : er)
	    else
	      options.stat(p, function(er3, stats) {
	        if (er3)
	          cb(er3.code === "ENOENT" ? null : er)
	        else if (stats.isDirectory())
	          rmdir(p, options, er, cb)
	        else
	          options.unlink(p, cb)
	      })
	  })
	}
	
	function fixWinEPERMSync (p, options, er) {
	  assert(p)
	  assert(options)
	  if (er)
	    assert(er instanceof Error)
	
	  try {
	    options.chmodSync(p, 666)
	  } catch (er2) {
	    if (er2.code === "ENOENT")
	      return
	    else
	      throw er
	  }
	
	  try {
	    var stats = options.statSync(p)
	  } catch (er3) {
	    if (er3.code === "ENOENT")
	      return
	    else
	      throw er
	  }
	
	  if (stats.isDirectory())
	    rmdirSync(p, options, er)
	  else
	    options.unlinkSync(p)
	}
	
	function rmdir (p, options, originalEr, cb) {
	  assert(p)
	  assert(options)
	  if (originalEr)
	    assert(originalEr instanceof Error)
	  assert(typeof cb === 'function')
	
	  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
	  // if we guessed wrong, and it's not a directory, then
	  // raise the original error.
	  options.rmdir(p, function (er) {
	    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
	      rmkids(p, options, cb)
	    else if (er && er.code === "ENOTDIR")
	      cb(originalEr)
	    else
	      cb(er)
	  })
	}
	
	function rmkids(p, options, cb) {
	  assert(p)
	  assert(options)
	  assert(typeof cb === 'function')
	
	  options.readdir(p, function (er, files) {
	    if (er)
	      return cb(er)
	    var n = files.length
	    if (n === 0)
	      return options.rmdir(p, cb)
	    var errState
	    files.forEach(function (f) {
	      rimraf(path.join(p, f), options, function (er) {
	        if (errState)
	          return
	        if (er)
	          return cb(errState = er)
	        if (--n === 0)
	          options.rmdir(p, cb)
	      })
	    })
	  })
	}
	
	// this looks simpler, and is strictly *faster*, but will
	// tie up the JavaScript thread and fail on excessively
	// deep directory trees.
	function rimrafSync (p, options) {
	  options = options || {}
	  defaults(options)
	
	  assert(p, 'rimraf: missing path')
	  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
	  assert(options, 'rimraf: missing options')
	  assert.equal(typeof options, 'object', 'rimraf: options should be object')
	
	  var results
	
	  if (options.disableGlob || !glob.hasMagic(p)) {
	    results = [p]
	  } else {
	    try {
	      fs.lstatSync(p)
	      results = [p]
	    } catch (er) {
	      results = glob.sync(p, globOpts)
	    }
	  }
	
	  if (!results.length)
	    return
	
	  for (var i = 0; i < results.length; i++) {
	    var p = results[i]
	
	    try {
	      var st = options.lstatSync(p)
	    } catch (er) {
	      if (er.code === "ENOENT")
	        return
	    }
	
	    try {
	      // sunos lets the root user unlink directories, which is... weird.
	      if (st && st.isDirectory())
	        rmdirSync(p, options, null)
	      else
	        options.unlinkSync(p)
	    } catch (er) {
	      if (er.code === "ENOENT")
	        return
	      if (er.code === "EPERM")
	        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
	      if (er.code !== "EISDIR")
	        throw er
	      rmdirSync(p, options, er)
	    }
	  }
	}
	
	function rmdirSync (p, options, originalEr) {
	  assert(p)
	  assert(options)
	  if (originalEr)
	    assert(originalEr instanceof Error)
	
	  try {
	    options.rmdirSync(p)
	  } catch (er) {
	    if (er.code === "ENOENT")
	      return
	    if (er.code === "ENOTDIR")
	      throw originalEr
	    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
	      rmkidsSync(p, options)
	  }
	}
	
	function rmkidsSync (p, options) {
	  assert(p)
	  assert(options)
	  options.readdirSync(p).forEach(function (f) {
	    rimrafSync(path.join(p, f), options)
	  })
	  options.rmdirSync(p, options)
	}


/***/ },
/* 765 */
/*!************************!*\
  !*** ./~/glob/glob.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern, false)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern, inGlobStar)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	//
	// If inGlobStar and PREFIX is symlink and points to dir
	//   set ENTRIES = []
	// else readdir(PREFIX) as ENTRIES
	//   If fail, END
	//
	// with ENTRIES
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       // Mark that this entry is a globstar match
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.
	
	module.exports = glob
	
	var fs = __webpack_require__(/*! fs */ 531)
	var rp = __webpack_require__(/*! fs.realpath */ 766)
	var minimatch = __webpack_require__(/*! minimatch */ 768)
	var Minimatch = minimatch.Minimatch
	var inherits = __webpack_require__(/*! inherits */ 610)
	var EE = __webpack_require__(/*! events */ 614).EventEmitter
	var path = __webpack_require__(/*! path */ 521)
	var assert = __webpack_require__(/*! assert */ 635)
	var isAbsolute = __webpack_require__(/*! path-is-absolute */ 772)
	var globSync = __webpack_require__(/*! ./sync.js */ 773)
	var common = __webpack_require__(/*! ./common.js */ 774)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var inflight = __webpack_require__(/*! inflight */ 775)
	var util = __webpack_require__(/*! util */ 597)
	var childrenIgnored = common.childrenIgnored
	var isIgnored = common.isIgnored
	
	var once = __webpack_require__(/*! once */ 777)
	
	function glob (pattern, options, cb) {
	  if (typeof options === 'function') cb = options, options = {}
	  if (!options) options = {}
	
	  if (options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return globSync(pattern, options)
	  }
	
	  return new Glob(pattern, options, cb)
	}
	
	glob.sync = globSync
	var GlobSync = glob.GlobSync = globSync.GlobSync
	
	// old api surface
	glob.glob = glob
	
	function extend (origin, add) {
	  if (add === null || typeof add !== 'object') {
	    return origin
	  }
	
	  var keys = Object.keys(add)
	  var i = keys.length
	  while (i--) {
	    origin[keys[i]] = add[keys[i]]
	  }
	  return origin
	}
	
	glob.hasMagic = function (pattern, options_) {
	  var options = extend({}, options_)
	  options.noprocess = true
	
	  var g = new Glob(pattern, options)
	  var set = g.minimatch.set
	  if (set.length > 1)
	    return true
	
	  for (var j = 0; j < set[0].length; j++) {
	    if (typeof set[0][j] !== 'string')
	      return true
	  }
	
	  return false
	}
	
	glob.Glob = Glob
	inherits(Glob, EE)
	function Glob (pattern, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = null
	  }
	
	  if (options && options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return new GlobSync(pattern, options)
	  }
	
	  if (!(this instanceof Glob))
	    return new Glob(pattern, options, cb)
	
	  setopts(this, pattern, options)
	  this._didRealPath = false
	
	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length
	
	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n)
	
	  if (typeof cb === 'function') {
	    cb = once(cb)
	    this.on('error', cb)
	    this.on('end', function (matches) {
	      cb(null, matches)
	    })
	  }
	
	  var self = this
	  var n = this.minimatch.set.length
	  this._processing = 0
	  this.matches = new Array(n)
	
	  this._emitQueue = []
	  this._processQueue = []
	  this.paused = false
	
	  if (this.noprocess)
	    return this
	
	  if (n === 0)
	    return done()
	
	  var sync = true
	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false, done)
	  }
	  sync = false
	
	  function done () {
	    --self._processing
	    if (self._processing <= 0) {
	      if (sync) {
	        process.nextTick(function () {
	          self._finish()
	        })
	      } else {
	        self._finish()
	      }
	    }
	  }
	}
	
	Glob.prototype._finish = function () {
	  assert(this instanceof Glob)
	  if (this.aborted)
	    return
	
	  if (this.realpath && !this._didRealpath)
	    return this._realpath()
	
	  common.finish(this)
	  this.emit('end', this.found)
	}
	
	Glob.prototype._realpath = function () {
	  if (this._didRealpath)
	    return
	
	  this._didRealpath = true
	
	  var n = this.matches.length
	  if (n === 0)
	    return this._finish()
	
	  var self = this
	  for (var i = 0; i < this.matches.length; i++)
	    this._realpathSet(i, next)
	
	  function next () {
	    if (--n === 0)
	      self._finish()
	  }
	}
	
	Glob.prototype._realpathSet = function (index, cb) {
	  var matchset = this.matches[index]
	  if (!matchset)
	    return cb()
	
	  var found = Object.keys(matchset)
	  var self = this
	  var n = found.length
	
	  if (n === 0)
	    return cb()
	
	  var set = this.matches[index] = Object.create(null)
	  found.forEach(function (p, i) {
	    // If there's a problem with the stat, then it means that
	    // one or more of the links in the realpath couldn't be
	    // resolved.  just return the abs value in that case.
	    p = self._makeAbs(p)
	    rp.realpath(p, self.realpathCache, function (er, real) {
	      if (!er)
	        set[real] = true
	      else if (er.syscall === 'stat')
	        set[p] = true
	      else
	        self.emit('error', er) // srsly wtf right here
	
	      if (--n === 0) {
	        self.matches[index] = set
	        cb()
	      }
	    })
	  })
	}
	
	Glob.prototype._mark = function (p) {
	  return common.mark(this, p)
	}
	
	Glob.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}
	
	Glob.prototype.abort = function () {
	  this.aborted = true
	  this.emit('abort')
	}
	
	Glob.prototype.pause = function () {
	  if (!this.paused) {
	    this.paused = true
	    this.emit('pause')
	  }
	}
	
	Glob.prototype.resume = function () {
	  if (this.paused) {
	    this.emit('resume')
	    this.paused = false
	    if (this._emitQueue.length) {
	      var eq = this._emitQueue.slice(0)
	      this._emitQueue.length = 0
	      for (var i = 0; i < eq.length; i ++) {
	        var e = eq[i]
	        this._emitMatch(e[0], e[1])
	      }
	    }
	    if (this._processQueue.length) {
	      var pq = this._processQueue.slice(0)
	      this._processQueue.length = 0
	      for (var i = 0; i < pq.length; i ++) {
	        var p = pq[i]
	        this._processing--
	        this._process(p[0], p[1], p[2], p[3])
	      }
	    }
	  }
	}
	
	Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
	  assert(this instanceof Glob)
	  assert(typeof cb === 'function')
	
	  if (this.aborted)
	    return
	
	  this._processing++
	  if (this.paused) {
	    this._processQueue.push([pattern, index, inGlobStar, cb])
	    return
	  }
	
	  //console.error('PROCESS %d', this._processing, pattern)
	
	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.
	
	  // see if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index, cb)
	      return
	
	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break
	
	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }
	
	  var remain = pattern.slice(n)
	
	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix
	
	  var abs = this._makeAbs(read)
	
	  //if ignored, skip _processing
	  if (childrenIgnored(this, read))
	    return cb()
	
	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
	}
	
	Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}
	
	Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
	
	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return cb()
	
	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'
	
	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }
	
	  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
	
	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return cb()
	
	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.
	
	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)
	
	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }
	
	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this._emitMatch(index, e)
	    }
	    // This was the last one, and no stats were needed
	    return cb()
	  }
	
	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix) {
	      if (prefix !== '/')
	        e = prefix + '/' + e
	      else
	        e = prefix + e
	    }
	    this._process([e].concat(remain), index, inGlobStar, cb)
	  }
	  cb()
	}
	
	Glob.prototype._emitMatch = function (index, e) {
	  if (this.aborted)
	    return
	
	  if (this.matches[index][e])
	    return
	
	  if (isIgnored(this, e))
	    return
	
	  if (this.paused) {
	    this._emitQueue.push([index, e])
	    return
	  }
	
	  var abs = this._makeAbs(e)
	
	  if (this.nodir) {
	    var c = this.cache[abs]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }
	
	  if (this.mark)
	    e = this._mark(e)
	
	  this.matches[index][e] = true
	
	  var st = this.statCache[abs]
	  if (st)
	    this.emit('stat', e, st)
	
	  this.emit('match', e)
	}
	
	Glob.prototype._readdirInGlobStar = function (abs, cb) {
	  if (this.aborted)
	    return
	
	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false, cb)
	
	  var lstatkey = 'lstat\0' + abs
	  var self = this
	  var lstatcb = inflight(lstatkey, lstatcb_)
	
	  if (lstatcb)
	    fs.lstat(abs, lstatcb)
	
	  function lstatcb_ (er, lstat) {
	    if (er)
	      return cb()
	
	    var isSym = lstat.isSymbolicLink()
	    self.symlinks[abs] = isSym
	
	    // If it's not a symlink or a dir, then it's definitely a regular file.
	    // don't bother doing a readdir in that case.
	    if (!isSym && !lstat.isDirectory()) {
	      self.cache[abs] = 'FILE'
	      cb()
	    } else
	      self._readdir(abs, false, cb)
	  }
	}
	
	Glob.prototype._readdir = function (abs, inGlobStar, cb) {
	  if (this.aborted)
	    return
	
	  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
	  if (!cb)
	    return
	
	  //console.error('RD %j %j', +inGlobStar, abs)
	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs, cb)
	
	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return cb()
	
	    if (Array.isArray(c))
	      return cb(null, c)
	  }
	
	  var self = this
	  fs.readdir(abs, readdirCb(this, abs, cb))
	}
	
	function readdirCb (self, abs, cb) {
	  return function (er, entries) {
	    if (er)
	      self._readdirError(abs, er, cb)
	    else
	      self._readdirEntries(abs, entries, cb)
	  }
	}
	
	Glob.prototype._readdirEntries = function (abs, entries, cb) {
	  if (this.aborted)
	    return
	
	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }
	
	  this.cache[abs] = entries
	  return cb(null, entries)
	}
	
	Glob.prototype._readdirError = function (f, er, cb) {
	  if (this.aborted)
	    return
	
	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      var abs = this._makeAbs(f)
	      this.cache[abs] = 'FILE'
	      if (abs === this.cwdAbs) {
	        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
	        error.path = this.cwd
	        error.code = er.code
	        this.emit('error', error)
	        this.abort()
	      }
	      break
	
	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break
	
	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict) {
	        this.emit('error', er)
	        // If the error is handled, then we abort
	        // if not, we threw out of here
	        this.abort()
	      }
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }
	
	  return cb()
	}
	
	Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}
	
	
	Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
	  //console.error('pgs2', prefix, remain[0], entries)
	
	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return cb()
	
	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)
	
	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false, cb)
	
	  var isSym = this.symlinks[abs]
	  var len = entries.length
	
	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return cb()
	
	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue
	
	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true, cb)
	
	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true, cb)
	  }
	
	  cb()
	}
	
	Glob.prototype._processSimple = function (prefix, index, cb) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var self = this
	  this._stat(prefix, function (er, exists) {
	    self._processSimple2(prefix, index, er, exists, cb)
	  })
	}
	Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
	
	  //console.error('ps2', prefix, exists)
	
	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)
	
	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return cb()
	
	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }
	
	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')
	
	  // Mark this as a match
	  this._emitMatch(index, prefix)
	  cb()
	}
	
	// Returns either 'DIR', 'FILE', or false
	Glob.prototype._stat = function (f, cb) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'
	
	  if (f.length > this.maxLength)
	    return cb()
	
	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	
	    if (Array.isArray(c))
	      c = 'DIR'
	
	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return cb(null, c)
	
	    if (needDir && c === 'FILE')
	      return cb()
	
	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }
	
	  var exists
	  var stat = this.statCache[abs]
	  if (stat !== undefined) {
	    if (stat === false)
	      return cb(null, stat)
	    else {
	      var type = stat.isDirectory() ? 'DIR' : 'FILE'
	      if (needDir && type === 'FILE')
	        return cb()
	      else
	        return cb(null, type, stat)
	    }
	  }
	
	  var self = this
	  var statcb = inflight('stat\0' + abs, lstatcb_)
	  if (statcb)
	    fs.lstat(abs, statcb)
	
	  function lstatcb_ (er, lstat) {
	    if (lstat && lstat.isSymbolicLink()) {
	      // If it's a symlink, then treat it as the target, unless
	      // the target does not exist, then treat it as a file.
	      return fs.stat(abs, function (er, stat) {
	        if (er)
	          self._stat2(f, abs, null, lstat, cb)
	        else
	          self._stat2(f, abs, er, stat, cb)
	      })
	    } else {
	      self._stat2(f, abs, er, lstat, cb)
	    }
	  }
	}
	
	Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
	  if (er) {
	    this.statCache[abs] = false
	    return cb()
	  }
	
	  var needDir = f.slice(-1) === '/'
	  this.statCache[abs] = stat
	
	  if (abs.slice(-1) === '/' && !stat.isDirectory())
	    return cb(null, false, stat)
	
	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c
	
	  if (needDir && c !== 'DIR')
	    return cb()
	
	  return cb(null, c, stat)
	}


/***/ },
/* 766 */
/*!********************************!*\
  !*** ./~/fs.realpath/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = realpath
	realpath.realpath = realpath
	realpath.sync = realpathSync
	realpath.realpathSync = realpathSync
	realpath.monkeypatch = monkeypatch
	realpath.unmonkeypatch = unmonkeypatch
	
	var fs = __webpack_require__(/*! fs */ 531)
	var origRealpath = fs.realpath
	var origRealpathSync = fs.realpathSync
	
	var version = process.version
	var ok = /^v[0-5]\./.test(version)
	var old = __webpack_require__(/*! ./old.js */ 767)
	
	function newError (er) {
	  return er && er.syscall === 'realpath' && (
	    er.code === 'ELOOP' ||
	    er.code === 'ENOMEM' ||
	    er.code === 'ENAMETOOLONG'
	  )
	}
	
	function realpath (p, cache, cb) {
	  if (ok) {
	    return origRealpath(p, cache, cb)
	  }
	
	  if (typeof cache === 'function') {
	    cb = cache
	    cache = null
	  }
	  origRealpath(p, cache, function (er, result) {
	    if (newError(er)) {
	      old.realpath(p, cache, cb)
	    } else {
	      cb(er, result)
	    }
	  })
	}
	
	function realpathSync (p, cache) {
	  if (ok) {
	    return origRealpathSync(p, cache)
	  }
	
	  try {
	    return origRealpathSync(p, cache)
	  } catch (er) {
	    if (newError(er)) {
	      return old.realpathSync(p, cache)
	    } else {
	      throw er
	    }
	  }
	}
	
	function monkeypatch () {
	  fs.realpath = realpath
	  fs.realpathSync = realpathSync
	}
	
	function unmonkeypatch () {
	  fs.realpath = origRealpath
	  fs.realpathSync = origRealpathSync
	}


/***/ },
/* 767 */
/*!******************************!*\
  !*** ./~/fs.realpath/old.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var pathModule = __webpack_require__(/*! path */ 521);
	var isWindows = process.platform === 'win32';
	var fs = __webpack_require__(/*! fs */ 531);
	
	// JavaScript implementation of realpath, ported from node pre-v6
	
	var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
	
	function rethrow() {
	  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
	  // is fairly slow to generate.
	  var callback;
	  if (DEBUG) {
	    var backtrace = new Error;
	    callback = debugCallback;
	  } else
	    callback = missingCallback;
	
	  return callback;
	
	  function debugCallback(err) {
	    if (err) {
	      backtrace.message = err.message;
	      err = backtrace;
	      missingCallback(err);
	    }
	  }
	
	  function missingCallback(err) {
	    if (err) {
	      if (process.throwDeprecation)
	        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
	      else if (!process.noDeprecation) {
	        var msg = 'fs: missing callback ' + (err.stack || err.message);
	        if (process.traceDeprecation)
	          console.trace(msg);
	        else
	          console.error(msg);
	      }
	    }
	  }
	}
	
	function maybeCallback(cb) {
	  return typeof cb === 'function' ? cb : rethrow();
	}
	
	var normalize = pathModule.normalize;
	
	// Regexp that finds the next partion of a (partial) path
	// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
	if (isWindows) {
	  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
	} else {
	  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
	}
	
	// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
	if (isWindows) {
	  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
	} else {
	  var splitRootRe = /^[\/]*/;
	}
	
	exports.realpathSync = function realpathSync(p, cache) {
	  // make p is absolute
	  p = pathModule.resolve(p);
	
	  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
	    return cache[p];
	  }
	
	  var original = p,
	      seenLinks = {},
	      knownHard = {};
	
	  // current character position in p
	  var pos;
	  // the partial path so far, including a trailing slash if any
	  var current;
	  // the partial path without a trailing slash (except when pointing at a root)
	  var base;
	  // the partial path scanned in the previous round, with slash
	  var previous;
	
	  start();
	
	  function start() {
	    // Skip over roots
	    var m = splitRootRe.exec(p);
	    pos = m[0].length;
	    current = m[0];
	    base = m[0];
	    previous = '';
	
	    // On windows, check that the root exists. On unix there is no need.
	    if (isWindows && !knownHard[base]) {
	      fs.lstatSync(base);
	      knownHard[base] = true;
	    }
	  }
	
	  // walk down the path, swapping out linked pathparts for their real
	  // values
	  // NB: p.length changes.
	  while (pos < p.length) {
	    // find the next part
	    nextPartRe.lastIndex = pos;
	    var result = nextPartRe.exec(p);
	    previous = current;
	    current += result[0];
	    base = previous + result[1];
	    pos = nextPartRe.lastIndex;
	
	    // continue if not a symlink
	    if (knownHard[base] || (cache && cache[base] === base)) {
	      continue;
	    }
	
	    var resolvedLink;
	    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
	      // some known symbolic link.  no need to stat again.
	      resolvedLink = cache[base];
	    } else {
	      var stat = fs.lstatSync(base);
	      if (!stat.isSymbolicLink()) {
	        knownHard[base] = true;
	        if (cache) cache[base] = base;
	        continue;
	      }
	
	      // read the link if it wasn't read before
	      // dev/ino always return 0 on windows, so skip the check.
	      var linkTarget = null;
	      if (!isWindows) {
	        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
	        if (seenLinks.hasOwnProperty(id)) {
	          linkTarget = seenLinks[id];
	        }
	      }
	      if (linkTarget === null) {
	        fs.statSync(base);
	        linkTarget = fs.readlinkSync(base);
	      }
	      resolvedLink = pathModule.resolve(previous, linkTarget);
	      // track this, if given a cache.
	      if (cache) cache[base] = resolvedLink;
	      if (!isWindows) seenLinks[id] = linkTarget;
	    }
	
	    // resolve the link, then start over
	    p = pathModule.resolve(resolvedLink, p.slice(pos));
	    start();
	  }
	
	  if (cache) cache[original] = p;
	
	  return p;
	};
	
	
	exports.realpath = function realpath(p, cache, cb) {
	  if (typeof cb !== 'function') {
	    cb = maybeCallback(cache);
	    cache = null;
	  }
	
	  // make p is absolute
	  p = pathModule.resolve(p);
	
	  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
	    return process.nextTick(cb.bind(null, null, cache[p]));
	  }
	
	  var original = p,
	      seenLinks = {},
	      knownHard = {};
	
	  // current character position in p
	  var pos;
	  // the partial path so far, including a trailing slash if any
	  var current;
	  // the partial path without a trailing slash (except when pointing at a root)
	  var base;
	  // the partial path scanned in the previous round, with slash
	  var previous;
	
	  start();
	
	  function start() {
	    // Skip over roots
	    var m = splitRootRe.exec(p);
	    pos = m[0].length;
	    current = m[0];
	    base = m[0];
	    previous = '';
	
	    // On windows, check that the root exists. On unix there is no need.
	    if (isWindows && !knownHard[base]) {
	      fs.lstat(base, function(err) {
	        if (err) return cb(err);
	        knownHard[base] = true;
	        LOOP();
	      });
	    } else {
	      process.nextTick(LOOP);
	    }
	  }
	
	  // walk down the path, swapping out linked pathparts for their real
	  // values
	  function LOOP() {
	    // stop if scanned past end of path
	    if (pos >= p.length) {
	      if (cache) cache[original] = p;
	      return cb(null, p);
	    }
	
	    // find the next part
	    nextPartRe.lastIndex = pos;
	    var result = nextPartRe.exec(p);
	    previous = current;
	    current += result[0];
	    base = previous + result[1];
	    pos = nextPartRe.lastIndex;
	
	    // continue if not a symlink
	    if (knownHard[base] || (cache && cache[base] === base)) {
	      return process.nextTick(LOOP);
	    }
	
	    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
	      // known symbolic link.  no need to stat again.
	      return gotResolvedLink(cache[base]);
	    }
	
	    return fs.lstat(base, gotStat);
	  }
	
	  function gotStat(err, stat) {
	    if (err) return cb(err);
	
	    // if not a symlink, skip to the next path part
	    if (!stat.isSymbolicLink()) {
	      knownHard[base] = true;
	      if (cache) cache[base] = base;
	      return process.nextTick(LOOP);
	    }
	
	    // stat & read the link if not read before
	    // call gotTarget as soon as the link target is known
	    // dev/ino always return 0 on windows, so skip the check.
	    if (!isWindows) {
	      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
	      if (seenLinks.hasOwnProperty(id)) {
	        return gotTarget(null, seenLinks[id], base);
	      }
	    }
	    fs.stat(base, function(err) {
	      if (err) return cb(err);
	
	      fs.readlink(base, function(err, target) {
	        if (!isWindows) seenLinks[id] = target;
	        gotTarget(err, target);
	      });
	    });
	  }
	
	  function gotTarget(err, target, base) {
	    if (err) return cb(err);
	
	    var resolvedLink = pathModule.resolve(previous, target);
	    if (cache) cache[base] = resolvedLink;
	    gotResolvedLink(resolvedLink);
	  }
	
	  function gotResolvedLink(resolvedLink) {
	    // resolve the link, then start over
	    p = pathModule.resolve(resolvedLink, p.slice(pos));
	    start();
	  }
	};


/***/ },
/* 768 */
/*!**********************************!*\
  !*** ./~/minimatch/minimatch.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = minimatch
	minimatch.Minimatch = Minimatch
	
	var path = { sep: '/' }
	try {
	  path = __webpack_require__(/*! path */ 521)
	} catch (er) {}
	
	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	var expand = __webpack_require__(/*! brace-expansion */ 769)
	
	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]'
	
	// * => any number of characters
	var star = qmark + '*?'
	
	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
	
	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
	
	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!')
	
	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}
	
	// normalizes slashes.
	var slashSplit = /\/+/
	
	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}
	
	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}
	
	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch
	
	  var orig = minimatch
	
	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }
	
	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }
	
	  return m
	}
	
	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}
	
	function minimatch (p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }
	
	  if (!options) options = {}
	
	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false
	  }
	
	  // "" only matches ""
	  if (pattern.trim() === '') return p === ''
	
	  return new Minimatch(pattern, options).match(p)
	}
	
	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options)
	  }
	
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }
	
	  if (!options) options = {}
	  pattern = pattern.trim()
	
	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/')
	  }
	
	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false
	
	  // make the set of regexps etc.
	  this.make()
	}
	
	Minimatch.prototype.debug = function () {}
	
	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return
	
	  var pattern = this.pattern
	  var options = this.options
	
	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }
	
	  // step 1: figure out negation, etc.
	  this.parseNegate()
	
	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()
	
	  if (options.debug) this.debug = console.error
	
	  this.debug(this.pattern, set)
	
	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })
	
	  this.debug(this.pattern, set)
	
	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)
	
	  this.debug(this.pattern, set)
	
	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1
	  })
	
	  this.debug(this.pattern, set)
	
	  this.set = set
	}
	
	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	  var negate = false
	  var options = this.options
	  var negateOffset = 0
	
	  if (options.nonegate) return
	
	  for (var i = 0, l = pattern.length
	    ; i < l && pattern.charAt(i) === '!'
	    ; i++) {
	    negate = !negate
	    negateOffset++
	  }
	
	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}
	
	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options)
	}
	
	Minimatch.prototype.braceExpand = braceExpand
	
	function braceExpand (pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options
	    } else {
	      options = {}
	    }
	  }
	
	  pattern = typeof pattern === 'undefined'
	    ? this.pattern : pattern
	
	  if (typeof pattern === 'undefined') {
	    throw new Error('undefined pattern')
	  }
	
	  if (options.nobrace ||
	    !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }
	
	  return expand(pattern)
	}
	
	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  var options = this.options
	
	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR
	  if (pattern === '') return ''
	
	  var re = ''
	  var hasMagic = !!options.nocase
	  var escaping = false
	  // ? => one single character
	  var patternListStack = []
	  var negativeLists = []
	  var plType
	  var stateChar
	  var inClass = false
	  var reClassStart = -1
	  var classStart = -1
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
	  : '(?!\\.)'
	  var self = this
	
	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star
	          hasMagic = true
	        break
	        case '?':
	          re += qmark
	          hasMagic = true
	        break
	        default:
	          re += '\\' + stateChar
	        break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }
	
	  for (var i = 0, len = pattern.length, c
	    ; (i < len) && (c = pattern.charAt(i))
	    ; i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c)
	
	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c
	      escaping = false
	      continue
	    }
	
	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false
	
	      case '\\':
	        clearStateChar()
	        escaping = true
	      continue
	
	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
	
	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === '!' && i === classStart + 1) c = '^'
	          re += c
	          continue
	        }
	
	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	      continue
	
	      case '(':
	        if (inClass) {
	          re += '('
	          continue
	        }
	
	        if (!stateChar) {
	          re += '\\('
	          continue
	        }
	
	        plType = stateChar
	        patternListStack.push({
	          type: plType,
	          start: i - 1,
	          reStart: re.length
	        })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	      continue
	
	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)'
	          continue
	        }
	
	        clearStateChar()
	        hasMagic = true
	        re += ')'
	        var pl = patternListStack.pop()
	        plType = pl.type
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        switch (plType) {
	          case '!':
	            negativeLists.push(pl)
	            re += ')[^/]*?)'
	            pl.reEnd = re.length
	            break
	          case '?':
	          case '+':
	          case '*':
	            re += plType
	            break
	          case '@': break // the default anyway
	        }
	      continue
	
	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|'
	          escaping = false
	          continue
	        }
	
	        clearStateChar()
	        re += '|'
	      continue
	
	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar()
	
	        if (inClass) {
	          re += '\\' + c
	          continue
	        }
	
	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	      continue
	
	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c
	          escaping = false
	          continue
	        }
	
	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i)
	          try {
	            RegExp('[' + cs + ']')
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE)
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
	            hasMagic = hasMagic || sp[1]
	            inClass = false
	            continue
	          }
	        }
	
	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	      continue
	
	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()
	
	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	          && !(c === '^' && inClass)) {
	          re += '\\'
	        }
	
	        re += c
	
	    } // switch
	  } // for
	
	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1)
	    sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + '\\[' + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }
	
	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + 3)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\'
	      }
	
	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|'
	    })
	
	    this.debug('tail=%j\n   %s', tail, tail)
	    var t = pl.type === '*' ? star
	      : pl.type === '?' ? qmark
	      : '\\' + pl.type
	
	    hasMagic = true
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail
	  }
	
	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += '\\\\'
	  }
	
	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(': addPatternStart = true
	  }
	
	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n]
	
	    var nlBefore = re.slice(0, nl.reStart)
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
	    var nlAfter = re.slice(nl.reEnd)
	
	    nlLast += nlAfter
	
	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1
	    var cleanAfter = nlAfter
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
	    }
	    nlAfter = cleanAfter
	
	    var dollar = ''
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$'
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
	    re = newRe
	  }
	
	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re
	  }
	
	  if (addPatternStart) {
	    re = patternStart + re
	  }
	
	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic]
	  }
	
	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }
	
	  var flags = options.nocase ? 'i' : ''
	  var regExp = new RegExp('^' + re + '$', flags)
	
	  regExp._glob = pattern
	  regExp._src = re
	
	  return regExp
	}
	
	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}
	
	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp
	
	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set
	
	  if (!set.length) {
	    this.regexp = false
	    return this.regexp
	  }
	  var options = this.options
	
	  var twoStar = options.noglobstar ? star
	    : options.dot ? twoStarDot
	    : twoStarNoDot
	  var flags = options.nocase ? 'i' : ''
	
	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	      : (typeof p === 'string') ? regExpEscape(p)
	      : p._src
	    }).join('\\\/')
	  }).join('|')
	
	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$'
	
	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$'
	
	  try {
	    this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    this.regexp = false
	  }
	  return this.regexp
	}
	
	minimatch.match = function (list, pattern, options) {
	  options = options || {}
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}
	
	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug('match', f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ''
	
	  if (f === '/' && partial) return true
	
	  var options = this.options
	
	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/')
	  }
	
	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, 'split', f)
	
	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.
	
	  var set = this.set
	  this.debug(this.pattern, 'set', set)
	
	  // Find the basename of the path by looking for the last non-empty segment
	  var filename
	  var i
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i]
	    if (filename) break
	  }
	
	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i]
	    var file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename]
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }
	
	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}
	
	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options
	
	  this.debug('matchOne',
	    { 'this': this, file: file, pattern: pattern })
	
	  this.debug('matchOne', file.length, pattern.length)
	
	  for (var fi = 0,
	      pi = 0,
	      fl = file.length,
	      pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi++, pi++) {
	    this.debug('matchOne loop')
	    var p = pattern[pi]
	    var f = file[fi]
	
	    this.debug(pattern, p, f)
	
	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false
	
	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])
	
	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	      var pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' ||
	            (!options.dot && file[fi].charAt(0) === '.')) return false
	        }
	        return true
	      }
	
	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr]
	
	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
	
	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' ||
	            (!options.dot && swallowee.charAt(0) === '.')) {
	            this.debug('dot detected!', file, fr, pattern, pr)
	            break
	          }
	
	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr++
	        }
	      }
	
	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }
	
	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug('string match', p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug('pattern match', p, f, hit)
	    }
	
	    if (!hit) return false
	  }
	
	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*
	
	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
	    return emptyFileEnd
	  }
	
	  // should be unreachable.
	  throw new Error('wtf?')
	}
	
	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, '$1')
	}
	
	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
	}


/***/ },
/* 769 */
/*!************************************!*\
  !*** ./~/brace-expansion/index.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var concatMap = __webpack_require__(/*! concat-map */ 770);
	var balanced = __webpack_require__(/*! balanced-match */ 771);
	
	module.exports = expandTop;
	
	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';
	
	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}
	
	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}
	
	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}
	
	
	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];
	
	  var parts = [];
	  var m = balanced('{', '}', str);
	
	  if (!m)
	    return str.split(',');
	
	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');
	
	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }
	
	  parts.push.apply(parts, p);
	
	  return parts;
	}
	
	function expandTop(str) {
	  if (!str)
	    return [];
	
	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}
	
	function identity(e) {
	  return e;
	}
	
	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}
	
	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}
	
	function expand(str, isTop) {
	  var expansions = [];
	
	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];
	
	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }
	
	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length
	          ? expand(m.post, false)
	          : [''];
	        return post.map(function(p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }
	
	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.
	
	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];
	
	  var N;
	
	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length)
	    var incr = n.length == 3
	      ? Math.abs(numeric(n[2]))
	      : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);
	
	    N = [];
	
	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\')
	          c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0)
	              c = '-' + z + c.slice(1);
	            else
	              c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function(el) { return expand(el, false) });
	  }
	
	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion)
	        expansions.push(expansion);
	    }
	  }
	
	  return expansions;
	}
	


/***/ },
/* 770 */
/*!*******************************!*\
  !*** ./~/concat-map/index.js ***!
  \*******************************/
/***/ function(module, exports) {

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);
	        else res.push(x);
	    }
	    return res;
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 771 */
/*!***********************************!*\
  !*** ./~/balanced-match/index.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);
	
	  var r = range(a, b, str);
	
	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}
	
	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}
	
	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;
	
	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;
	
	    while (i < str.length && i >= 0 && ! result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }
	
	        bi = str.indexOf(b, i + 1);
	      }
	
	      i = ai < bi && ai >= 0 ? ai : bi;
	    }
	
	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }
	
	  return result;
	}


/***/ },
/* 772 */
/*!*************************************!*\
  !*** ./~/path-is-absolute/index.js ***!
  \*************************************/
/***/ function(module, exports) {

	'use strict';
	
	function posix(path) {
		return path.charAt(0) === '/';
	};
	
	function win32(path) {
		// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path);
		var device = result[1] || '';
		var isUnc = !!device && device.charAt(1) !== ':';
	
		// UNC paths are always absolute
		return !!result[2] || isUnc;
	};
	
	module.exports = process.platform === 'win32' ? win32 : posix;
	module.exports.posix = posix;
	module.exports.win32 = win32;


/***/ },
/* 773 */
/*!************************!*\
  !*** ./~/glob/sync.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = globSync
	globSync.GlobSync = GlobSync
	
	var fs = __webpack_require__(/*! fs */ 531)
	var rp = __webpack_require__(/*! fs.realpath */ 766)
	var minimatch = __webpack_require__(/*! minimatch */ 768)
	var Minimatch = minimatch.Minimatch
	var Glob = __webpack_require__(/*! ./glob.js */ 765).Glob
	var util = __webpack_require__(/*! util */ 597)
	var path = __webpack_require__(/*! path */ 521)
	var assert = __webpack_require__(/*! assert */ 635)
	var isAbsolute = __webpack_require__(/*! path-is-absolute */ 772)
	var common = __webpack_require__(/*! ./common.js */ 774)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var setopts = common.setopts
	var ownProp = common.ownProp
	var childrenIgnored = common.childrenIgnored
	
	function globSync (pattern, options) {
	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')
	
	  return new GlobSync(pattern, options).found
	}
	
	function GlobSync (pattern, options) {
	  if (!pattern)
	    throw new Error('must provide pattern')
	
	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')
	
	  if (!(this instanceof GlobSync))
	    return new GlobSync(pattern, options)
	
	  setopts(this, pattern, options)
	
	  if (this.noprocess)
	    return this
	
	  var n = this.minimatch.set.length
	  this.matches = new Array(n)
	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false)
	  }
	  this._finish()
	}
	
	GlobSync.prototype._finish = function () {
	  assert(this instanceof GlobSync)
	  if (this.realpath) {
	    var self = this
	    this.matches.forEach(function (matchset, index) {
	      var set = self.matches[index] = Object.create(null)
	      for (var p in matchset) {
	        try {
	          p = self._makeAbs(p)
	          var real = rp.realpathSync(p, self.realpathCache)
	          set[real] = true
	        } catch (er) {
	          if (er.syscall === 'stat')
	            set[self._makeAbs(p)] = true
	          else
	            throw er
	        }
	      }
	    })
	  }
	  common.finish(this)
	}
	
	
	GlobSync.prototype._process = function (pattern, index, inGlobStar) {
	  assert(this instanceof GlobSync)
	
	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.
	
	  // See if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index)
	      return
	
	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break
	
	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }
	
	  var remain = pattern.slice(n)
	
	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix
	
	  var abs = this._makeAbs(read)
	
	  //if ignored, skip processing
	  if (childrenIgnored(this, read))
	    return
	
	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
	}
	
	
	GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
	  var entries = this._readdir(abs, inGlobStar)
	
	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return
	
	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'
	
	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }
	
	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return
	
	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.
	
	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)
	
	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix.slice(-1) !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }
	
	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this.matches[index][e] = true
	    }
	    // This was the last one, and no stats were needed
	    return
	  }
	
	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix)
	      newPattern = [prefix, e]
	    else
	      newPattern = [e]
	    this._process(newPattern.concat(remain), index, inGlobStar)
	  }
	}
	
	
	GlobSync.prototype._emitMatch = function (index, e) {
	  var abs = this._makeAbs(e)
	  if (this.mark)
	    e = this._mark(e)
	
	  if (this.matches[index][e])
	    return
	
	  if (this.nodir) {
	    var c = this.cache[this._makeAbs(e)]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }
	
	  this.matches[index][e] = true
	  if (this.stat)
	    this._stat(e)
	}
	
	
	GlobSync.prototype._readdirInGlobStar = function (abs) {
	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false)
	
	  var entries
	  var lstat
	  var stat
	  try {
	    lstat = fs.lstatSync(abs)
	  } catch (er) {
	    // lstat failed, doesn't exist
	    return null
	  }
	
	  var isSym = lstat.isSymbolicLink()
	  this.symlinks[abs] = isSym
	
	  // If it's not a symlink or a dir, then it's definitely a regular file.
	  // don't bother doing a readdir in that case.
	  if (!isSym && !lstat.isDirectory())
	    this.cache[abs] = 'FILE'
	  else
	    entries = this._readdir(abs, false)
	
	  return entries
	}
	
	GlobSync.prototype._readdir = function (abs, inGlobStar) {
	  var entries
	
	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs)
	
	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return null
	
	    if (Array.isArray(c))
	      return c
	  }
	
	  try {
	    return this._readdirEntries(abs, fs.readdirSync(abs))
	  } catch (er) {
	    this._readdirError(abs, er)
	    return null
	  }
	}
	
	GlobSync.prototype._readdirEntries = function (abs, entries) {
	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }
	
	  this.cache[abs] = entries
	
	  // mark and cache dir-ness
	  return entries
	}
	
	GlobSync.prototype._readdirError = function (f, er) {
	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      var abs = this._makeAbs(f)
	      this.cache[abs] = 'FILE'
	      if (abs === this.cwdAbs) {
	        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
	        error.path = this.cwd
	        error.code = er.code
	        throw error
	      }
	      break
	
	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break
	
	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict)
	        throw er
	      if (!this.silent)
	        console.error('glob error', er)
	      break
	  }
	}
	
	GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
	
	  var entries = this._readdir(abs, inGlobStar)
	
	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return
	
	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)
	
	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false)
	
	  var len = entries.length
	  var isSym = this.symlinks[abs]
	
	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return
	
	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue
	
	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true)
	
	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true)
	  }
	}
	
	GlobSync.prototype._processSimple = function (prefix, index) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var exists = this._stat(prefix)
	
	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)
	
	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return
	
	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }
	
	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')
	
	  // Mark this as a match
	  this.matches[index][prefix] = true
	}
	
	// Returns either 'DIR', 'FILE', or false
	GlobSync.prototype._stat = function (f) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'
	
	  if (f.length > this.maxLength)
	    return false
	
	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	
	    if (Array.isArray(c))
	      c = 'DIR'
	
	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return c
	
	    if (needDir && c === 'FILE')
	      return false
	
	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }
	
	  var exists
	  var stat = this.statCache[abs]
	  if (!stat) {
	    var lstat
	    try {
	      lstat = fs.lstatSync(abs)
	    } catch (er) {
	      return false
	    }
	
	    if (lstat.isSymbolicLink()) {
	      try {
	        stat = fs.statSync(abs)
	      } catch (er) {
	        stat = lstat
	      }
	    } else {
	      stat = lstat
	    }
	  }
	
	  this.statCache[abs] = stat
	
	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c
	
	  if (needDir && c !== 'DIR')
	    return false
	
	  return c
	}
	
	GlobSync.prototype._mark = function (p) {
	  return common.mark(this, p)
	}
	
	GlobSync.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}


/***/ },
/* 774 */
/*!**************************!*\
  !*** ./~/glob/common.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	exports.alphasort = alphasort
	exports.alphasorti = alphasorti
	exports.setopts = setopts
	exports.ownProp = ownProp
	exports.makeAbs = makeAbs
	exports.finish = finish
	exports.mark = mark
	exports.isIgnored = isIgnored
	exports.childrenIgnored = childrenIgnored
	
	function ownProp (obj, field) {
	  return Object.prototype.hasOwnProperty.call(obj, field)
	}
	
	var path = __webpack_require__(/*! path */ 521)
	var minimatch = __webpack_require__(/*! minimatch */ 768)
	var isAbsolute = __webpack_require__(/*! path-is-absolute */ 772)
	var Minimatch = minimatch.Minimatch
	
	function alphasorti (a, b) {
	  return a.toLowerCase().localeCompare(b.toLowerCase())
	}
	
	function alphasort (a, b) {
	  return a.localeCompare(b)
	}
	
	function setupIgnores (self, options) {
	  self.ignore = options.ignore || []
	
	  if (!Array.isArray(self.ignore))
	    self.ignore = [self.ignore]
	
	  if (self.ignore.length) {
	    self.ignore = self.ignore.map(ignoreMap)
	  }
	}
	
	// ignore patterns are always in dot:true mode.
	function ignoreMap (pattern) {
	  var gmatcher = null
	  if (pattern.slice(-3) === '/**') {
	    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
	    gmatcher = new Minimatch(gpattern, { dot: true })
	  }
	
	  return {
	    matcher: new Minimatch(pattern, { dot: true }),
	    gmatcher: gmatcher
	  }
	}
	
	function setopts (self, pattern, options) {
	  if (!options)
	    options = {}
	
	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar")
	    }
	    pattern = "**/" + pattern
	  }
	
	  self.silent = !!options.silent
	  self.pattern = pattern
	  self.strict = options.strict !== false
	  self.realpath = !!options.realpath
	  self.realpathCache = options.realpathCache || Object.create(null)
	  self.follow = !!options.follow
	  self.dot = !!options.dot
	  self.mark = !!options.mark
	  self.nodir = !!options.nodir
	  if (self.nodir)
	    self.mark = true
	  self.sync = !!options.sync
	  self.nounique = !!options.nounique
	  self.nonull = !!options.nonull
	  self.nosort = !!options.nosort
	  self.nocase = !!options.nocase
	  self.stat = !!options.stat
	  self.noprocess = !!options.noprocess
	
	  self.maxLength = options.maxLength || Infinity
	  self.cache = options.cache || Object.create(null)
	  self.statCache = options.statCache || Object.create(null)
	  self.symlinks = options.symlinks || Object.create(null)
	
	  setupIgnores(self, options)
	
	  self.changedCwd = false
	  var cwd = process.cwd()
	  if (!ownProp(options, "cwd"))
	    self.cwd = cwd
	  else {
	    self.cwd = path.resolve(options.cwd)
	    self.changedCwd = self.cwd !== cwd
	  }
	
	  self.root = options.root || path.resolve(self.cwd, "/")
	  self.root = path.resolve(self.root)
	  if (process.platform === "win32")
	    self.root = self.root.replace(/\\/g, "/")
	
	  self.cwdAbs = makeAbs(self, self.cwd)
	  self.nomount = !!options.nomount
	
	  // disable comments and negation in Minimatch.
	  // Note that they are not supported in Glob itself anyway.
	  options.nonegate = true
	  options.nocomment = true
	
	  self.minimatch = new Minimatch(pattern, options)
	  self.options = self.minimatch.options
	}
	
	function finish (self) {
	  var nou = self.nounique
	  var all = nou ? [] : Object.create(null)
	
	  for (var i = 0, l = self.matches.length; i < l; i ++) {
	    var matches = self.matches[i]
	    if (!matches || Object.keys(matches).length === 0) {
	      if (self.nonull) {
	        // do like the shell, and spit out the literal glob
	        var literal = self.minimatch.globSet[i]
	        if (nou)
	          all.push(literal)
	        else
	          all[literal] = true
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches)
	      if (nou)
	        all.push.apply(all, m)
	      else
	        m.forEach(function (m) {
	          all[m] = true
	        })
	    }
	  }
	
	  if (!nou)
	    all = Object.keys(all)
	
	  if (!self.nosort)
	    all = all.sort(self.nocase ? alphasorti : alphasort)
	
	  // at *some* point we statted all of these
	  if (self.mark) {
	    for (var i = 0; i < all.length; i++) {
	      all[i] = self._mark(all[i])
	    }
	    if (self.nodir) {
	      all = all.filter(function (e) {
	        var notDir = !(/\/$/.test(e))
	        var c = self.cache[e] || self.cache[makeAbs(self, e)]
	        if (notDir && c)
	          notDir = c !== 'DIR' && !Array.isArray(c)
	        return notDir
	      })
	    }
	  }
	
	  if (self.ignore.length)
	    all = all.filter(function(m) {
	      return !isIgnored(self, m)
	    })
	
	  self.found = all
	}
	
	function mark (self, p) {
	  var abs = makeAbs(self, p)
	  var c = self.cache[abs]
	  var m = p
	  if (c) {
	    var isDir = c === 'DIR' || Array.isArray(c)
	    var slash = p.slice(-1) === '/'
	
	    if (isDir && !slash)
	      m += '/'
	    else if (!isDir && slash)
	      m = m.slice(0, -1)
	
	    if (m !== p) {
	      var mabs = makeAbs(self, m)
	      self.statCache[mabs] = self.statCache[abs]
	      self.cache[mabs] = self.cache[abs]
	    }
	  }
	
	  return m
	}
	
	// lotta situps...
	function makeAbs (self, f) {
	  var abs = f
	  if (f.charAt(0) === '/') {
	    abs = path.join(self.root, f)
	  } else if (isAbsolute(f) || f === '') {
	    abs = f
	  } else if (self.changedCwd) {
	    abs = path.resolve(self.cwd, f)
	  } else {
	    abs = path.resolve(f)
	  }
	
	  if (process.platform === 'win32')
	    abs = abs.replace(/\\/g, '/')
	
	  return abs
	}
	
	
	// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
	// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
	function isIgnored (self, path) {
	  if (!self.ignore.length)
	    return false
	
	  return self.ignore.some(function(item) {
	    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}
	
	function childrenIgnored (self, path) {
	  if (!self.ignore.length)
	    return false
	
	  return self.ignore.some(function(item) {
	    return !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}


/***/ },
/* 775 */
/*!********************************!*\
  !*** ./~/inflight/inflight.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(/*! wrappy */ 776)
	var reqs = Object.create(null)
	var once = __webpack_require__(/*! once */ 777)
	
	module.exports = wrappy(inflight)
	
	function inflight (key, cb) {
	  if (reqs[key]) {
	    reqs[key].push(cb)
	    return null
	  } else {
	    reqs[key] = [cb]
	    return makeres(key)
	  }
	}
	
	function makeres (key) {
	  return once(function RES () {
	    var cbs = reqs[key]
	    var len = cbs.length
	    var args = slice(arguments)
	    for (var i = 0; i < len; i++) {
	      cbs[i].apply(null, args)
	    }
	    if (cbs.length > len) {
	      // added more in the interim.
	      // de-zalgo, just in case, but don't call again.
	      cbs.splice(0, len)
	      process.nextTick(function () {
	        RES.apply(null, args)
	      })
	    } else {
	      delete reqs[key]
	    }
	  })
	}
	
	function slice (args) {
	  var length = args.length
	  var array = []
	
	  for (var i = 0; i < length; i++) array[i] = args[i]
	  return array
	}


/***/ },
/* 776 */
/*!****************************!*\
  !*** ./~/wrappy/wrappy.js ***!
  \****************************/
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)
	
	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')
	
	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })
	
	  return wrapper
	
	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 777 */
/*!************************!*\
  !*** ./~/once/once.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(/*! wrappy */ 776)
	module.exports = wrappy(once)
	
	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})
	
	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}


/***/ },
/* 778 */
/*!***************************!*\
  !*** ./~/mkdirp/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(/*! path */ 521);
	var fs = __webpack_require__(/*! fs */ 531);
	var _0777 = parseInt('0777', 8);
	
	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
	
	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;
	
	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}
	
	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	
	    p = path.resolve(p);
	
	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;
	
	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }
	
	    return made;
	};


/***/ },
/* 779 */
/*!*************************************!*\
  !*** ./~/fstream/lib/dir-writer.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	// It is expected that, when .add() returns false, the consumer
	// of the DirWriter will pause until a "drain" event occurs. Note
	// that this is *almost always going to be the case*, unless the
	// thing being written is some sort of unsupported type, and thus
	// skipped over.
	
	module.exports = DirWriter
	
	var Writer = __webpack_require__(/*! ./writer.js */ 763)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var mkdir = __webpack_require__(/*! mkdirp */ 778)
	var path = __webpack_require__(/*! path */ 521)
	var collect = __webpack_require__(/*! ./collect.js */ 780)
	
	inherits(DirWriter, Writer)
	
	function DirWriter (props) {
	  var self = this
	  if (!(self instanceof DirWriter)) {
	    self.error('DirWriter must be called as constructor.', null, true)
	  }
	
	  // should already be established as a Directory type
	  if (props.type !== 'Directory' || !props.Directory) {
	    self.error('Non-directory type ' + props.type + ' ' +
	      JSON.stringify(props), null, true)
	  }
	
	  Writer.call(this, props)
	}
	
	DirWriter.prototype._create = function () {
	  var self = this
	  mkdir(self._path, Writer.dirmode, function (er) {
	    if (er) return self.error(er)
	    // ready to start getting entries!
	    self.ready = true
	    self.emit('ready')
	    self._process()
	  })
	}
	
	// a DirWriter has an add(entry) method, but its .write() doesn't
	// do anything.  Why a no-op rather than a throw?  Because this
	// leaves open the door for writing directory metadata for
	// gnu/solaris style dumpdirs.
	DirWriter.prototype.write = function () {
	  return true
	}
	
	DirWriter.prototype.end = function () {
	  this._ended = true
	  this._process()
	}
	
	DirWriter.prototype.add = function (entry) {
	  var self = this
	
	  // console.error('\tadd', entry._path, '->', self._path)
	  collect(entry)
	  if (!self.ready || self._currentEntry) {
	    self._buffer.push(entry)
	    return false
	  }
	
	  // create a new writer, and pipe the incoming entry into it.
	  if (self._ended) {
	    return self.error('add after end')
	  }
	
	  self._buffer.push(entry)
	  self._process()
	
	  return this._buffer.length === 0
	}
	
	DirWriter.prototype._process = function () {
	  var self = this
	
	  // console.error('DW Process p=%j', self._processing, self.basename)
	
	  if (self._processing) return
	
	  var entry = self._buffer.shift()
	  if (!entry) {
	    // console.error("DW Drain")
	    self.emit('drain')
	    if (self._ended) self._finish()
	    return
	  }
	
	  self._processing = true
	  // console.error("DW Entry", entry._path)
	
	  self.emit('entry', entry)
	
	  // ok, add this entry
	  //
	  // don't allow recursive copying
	  var p = entry
	  var pp
	  do {
	    pp = p._path || p.path
	    if (pp === self.root._path || pp === self._path ||
	      (pp && pp.indexOf(self._path) === 0)) {
	      // console.error('DW Exit (recursive)', entry.basename, self._path)
	      self._processing = false
	      if (entry._collected) entry.pipe()
	      return self._process()
	    }
	    p = p.parent
	  } while (p)
	
	  // console.error("DW not recursive")
	
	  // chop off the entry's root dir, replace with ours
	  var props = {
	    parent: self,
	    root: self.root || self,
	    type: entry.type,
	    depth: self.depth + 1
	  }
	
	  pp = entry._path || entry.path || entry.props.path
	  if (entry.parent) {
	    pp = pp.substr(entry.parent._path.length + 1)
	  }
	  // get rid of any ../../ shenanigans
	  props.path = path.join(self.path, path.join('/', pp))
	
	  // if i have a filter, the child should inherit it.
	  props.filter = self.filter
	
	  // all the rest of the stuff, copy over from the source.
	  Object.keys(entry.props).forEach(function (k) {
	    if (!props.hasOwnProperty(k)) {
	      props[k] = entry.props[k]
	    }
	  })
	
	  // not sure at this point what kind of writer this is.
	  var child = self._currentChild = new Writer(props)
	  child.on('ready', function () {
	    // console.error("DW Child Ready", child.type, child._path)
	    // console.error("  resuming", entry._path)
	    entry.pipe(child)
	    entry.resume()
	  })
	
	  // XXX Make this work in node.
	  // Long filenames should not break stuff.
	  child.on('error', function (er) {
	    if (child._swallowErrors) {
	      self.warn(er)
	      child.emit('end')
	      child.emit('close')
	    } else {
	      self.emit('error', er)
	    }
	  })
	
	  // we fire _end internally *after* end, so that we don't move on
	  // until any "end" listeners have had their chance to do stuff.
	  child.on('close', onend)
	  var ended = false
	  function onend () {
	    if (ended) return
	    ended = true
	    // console.error("* DW Child end", child.basename)
	    self._currentChild = null
	    self._processing = false
	    self._process()
	  }
	}


/***/ },
/* 780 */
/*!**********************************!*\
  !*** ./~/fstream/lib/collect.js ***!
  \**********************************/
/***/ function(module, exports) {

	module.exports = collect
	
	function collect (stream) {
	  if (stream._collected) return
	
	  if (stream._paused) return stream.on('resume', collect.bind(null, stream))
	
	  stream._collected = true
	  stream.pause()
	
	  stream.on('data', save)
	  stream.on('end', save)
	  var buf = []
	  function save (b) {
	    if (typeof b === 'string') b = new Buffer(b)
	    if (Buffer.isBuffer(b) && !b.length) return
	    buf.push(b)
	  }
	
	  stream.on('entry', saveEntry)
	  var entryBuffer = []
	  function saveEntry (e) {
	    collect(e)
	    entryBuffer.push(e)
	  }
	
	  stream.on('proxy', proxyPause)
	  function proxyPause (p) {
	    p.pause()
	  }
	
	  // replace the pipe method with a new version that will
	  // unlock the buffered stuff.  if you just call .pipe()
	  // without a destination, then it'll re-play the events.
	  stream.pipe = (function (orig) {
	    return function (dest) {
	      // console.error(' === open the pipes', dest && dest.path)
	
	      // let the entries flow through one at a time.
	      // Once they're all done, then we can resume completely.
	      var e = 0
	      ;(function unblockEntry () {
	        var entry = entryBuffer[e++]
	        // console.error(" ==== unblock entry", entry && entry.path)
	        if (!entry) return resume()
	        entry.on('end', unblockEntry)
	        if (dest) dest.add(entry)
	        else stream.emit('entry', entry)
	      })()
	
	      function resume () {
	        stream.removeListener('entry', saveEntry)
	        stream.removeListener('data', save)
	        stream.removeListener('end', save)
	
	        stream.pipe = orig
	        if (dest) stream.pipe(dest)
	
	        buf.forEach(function (b) {
	          if (b) stream.emit('data', b)
	          else stream.emit('end')
	        })
	
	        stream.resume()
	      }
	
	      return dest
	    }
	  })(stream.pipe)
	}


/***/ },
/* 781 */
/*!**************************************!*\
  !*** ./~/fstream/lib/link-writer.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = LinkWriter
	
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	var Writer = __webpack_require__(/*! ./writer.js */ 763)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var path = __webpack_require__(/*! path */ 521)
	var rimraf = __webpack_require__(/*! rimraf */ 764)
	
	inherits(LinkWriter, Writer)
	
	function LinkWriter (props) {
	  var self = this
	  if (!(self instanceof LinkWriter)) {
	    throw new Error('LinkWriter must be called as constructor.')
	  }
	
	  // should already be established as a Link type
	  if (!((props.type === 'Link' && props.Link) ||
	    (props.type === 'SymbolicLink' && props.SymbolicLink))) {
	    throw new Error('Non-link type ' + props.type)
	  }
	
	  if (props.linkpath === '') props.linkpath = '.'
	  if (!props.linkpath) {
	    self.error('Need linkpath property to create ' + props.type)
	  }
	
	  Writer.call(this, props)
	}
	
	LinkWriter.prototype._create = function () {
	  // console.error(" LW _create")
	  var self = this
	  var hard = self.type === 'Link' || process.platform === 'win32'
	  var link = hard ? 'link' : 'symlink'
	  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath
	
	  // can only change the link path by clobbering
	  // For hard links, let's just assume that's always the case, since
	  // there's no good way to read them if we don't already know.
	  if (hard) return clobber(self, lp, link)
	
	  fs.readlink(self._path, function (er, p) {
	    // only skip creation if it's exactly the same link
	    if (p && p === lp) return finish(self)
	    clobber(self, lp, link)
	  })
	}
	
	function clobber (self, lp, link) {
	  rimraf(self._path, function (er) {
	    if (er) return self.error(er)
	    create(self, lp, link)
	  })
	}
	
	function create (self, lp, link) {
	  fs[link](lp, self._path, function (er) {
	    // if this is a hard link, and we're in the process of writing out a
	    // directory, it's very possible that the thing we're linking to
	    // doesn't exist yet (especially if it was intended as a symlink),
	    // so swallow ENOENT errors here and just soldier in.
	    // Additionally, an EPERM or EACCES can happen on win32 if it's trying
	    // to make a link to a directory.  Again, just skip it.
	    // A better solution would be to have fs.symlink be supported on
	    // windows in some nice fashion.
	    if (er) {
	      if ((er.code === 'ENOENT' ||
	        er.code === 'EACCES' ||
	        er.code === 'EPERM') && process.platform === 'win32') {
	        self.ready = true
	        self.emit('ready')
	        self.emit('end')
	        self.emit('close')
	        self.end = self._finish = function () {}
	      } else return self.error(er)
	    }
	    finish(self)
	  })
	}
	
	function finish (self) {
	  self.ready = true
	  self.emit('ready')
	  if (self._ended && !self._finished) self._finish()
	}
	
	LinkWriter.prototype.end = function () {
	  // console.error("LW finish in end")
	  this._ended = true
	  if (this.ready) {
	    this._finished = true
	    this._finish()
	  }
	}


/***/ },
/* 782 */
/*!**************************************!*\
  !*** ./~/fstream/lib/file-writer.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = FileWriter
	
	var fs = __webpack_require__(/*! graceful-fs */ 752)
	var Writer = __webpack_require__(/*! ./writer.js */ 763)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var EOF = {}
	
	inherits(FileWriter, Writer)
	
	function FileWriter (props) {
	  var self = this
	  if (!(self instanceof FileWriter)) {
	    throw new Error('FileWriter must be called as constructor.')
	  }
	
	  // should already be established as a File type
	  if (props.type !== 'File' || !props.File) {
	    throw new Error('Non-file type ' + props.type)
	  }
	
	  self._buffer = []
	  self._bytesWritten = 0
	
	  Writer.call(this, props)
	}
	
	FileWriter.prototype._create = function () {
	  var self = this
	  if (self._stream) return
	
	  var so = {}
	  if (self.props.flags) so.flags = self.props.flags
	  so.mode = Writer.filemode
	  if (self._old && self._old.blksize) so.bufferSize = self._old.blksize
	
	  self._stream = fs.createWriteStream(self._path, so)
	
	  self._stream.on('open', function () {
	    // console.error("FW open", self._buffer, self._path)
	    self.ready = true
	    self._buffer.forEach(function (c) {
	      if (c === EOF) self._stream.end()
	      else self._stream.write(c)
	    })
	    self.emit('ready')
	    // give this a kick just in case it needs it.
	    self.emit('drain')
	  })
	
	  self._stream.on('error', function (er) { self.emit('error', er) })
	
	  self._stream.on('drain', function () { self.emit('drain') })
	
	  self._stream.on('close', function () {
	    // console.error('\n\nFW Stream Close', self._path, self.size)
	    self._finish()
	  })
	}
	
	FileWriter.prototype.write = function (c) {
	  var self = this
	
	  self._bytesWritten += c.length
	
	  if (!self.ready) {
	    if (!Buffer.isBuffer(c) && typeof c !== 'string') {
	      throw new Error('invalid write data')
	    }
	    self._buffer.push(c)
	    return false
	  }
	
	  var ret = self._stream.write(c)
	  // console.error('\t-- fw wrote, _stream says', ret, self._stream._queue.length)
	
	  // allow 2 buffered writes, because otherwise there's just too
	  // much stop and go bs.
	  if (ret === false && self._stream._queue) {
	    return self._stream._queue.length <= 2
	  } else {
	    return ret
	  }
	}
	
	FileWriter.prototype.end = function (c) {
	  var self = this
	
	  if (c) self.write(c)
	
	  if (!self.ready) {
	    self._buffer.push(EOF)
	    return false
	  }
	
	  return self._stream.end()
	}
	
	FileWriter.prototype._finish = function () {
	  var self = this
	  if (typeof self.size === 'number' && self._bytesWritten !== self.size) {
	    self.error(
	      'Did not get expected byte count.\n' +
	      'expect: ' + self.size + '\n' +
	      'actual: ' + self._bytesWritten)
	  }
	  Writer.prototype._finish.call(self)
	}


/***/ },
/* 783 */
/*!***************************************!*\
  !*** ./~/fstream/lib/proxy-writer.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// A writer for when we don't know what kind of thing
	// the thing is.  That is, it's not explicitly set,
	// so we're going to make it whatever the thing already
	// is, or "File"
	//
	// Until then, collect all events.
	
	module.exports = ProxyWriter
	
	var Writer = __webpack_require__(/*! ./writer.js */ 763)
	var getType = __webpack_require__(/*! ./get-type.js */ 757)
	var inherits = __webpack_require__(/*! inherits */ 610)
	var collect = __webpack_require__(/*! ./collect.js */ 780)
	var fs = __webpack_require__(/*! fs */ 531)
	
	inherits(ProxyWriter, Writer)
	
	function ProxyWriter (props) {
	  var self = this
	  if (!(self instanceof ProxyWriter)) {
	    throw new Error('ProxyWriter must be called as constructor.')
	  }
	
	  self.props = props
	  self._needDrain = false
	
	  Writer.call(self, props)
	}
	
	ProxyWriter.prototype._stat = function () {
	  var self = this
	  var props = self.props
	  // stat the thing to see what the proxy should be.
	  var stat = props.follow ? 'stat' : 'lstat'
	
	  fs[stat](props.path, function (er, current) {
	    var type
	    if (er || !current) {
	      type = 'File'
	    } else {
	      type = getType(current)
	    }
	
	    props[type] = true
	    props.type = self.type = type
	
	    self._old = current
	    self._addProxy(Writer(props, current))
	  })
	}
	
	ProxyWriter.prototype._addProxy = function (proxy) {
	  // console.error("~~ set proxy", this.path)
	  var self = this
	  if (self._proxy) {
	    return self.error('proxy already set')
	  }
	
	  self._proxy = proxy
	  ;[
	    'ready',
	    'error',
	    'close',
	    'pipe',
	    'drain',
	    'warn'
	  ].forEach(function (ev) {
	    proxy.on(ev, self.emit.bind(self, ev))
	  })
	
	  self.emit('proxy', proxy)
	
	  var calls = self._buffer
	  calls.forEach(function (c) {
	    // console.error("~~ ~~ proxy buffered call", c[0], c[1])
	    proxy[c[0]].apply(proxy, c[1])
	  })
	  self._buffer.length = 0
	  if (self._needsDrain) self.emit('drain')
	}
	
	ProxyWriter.prototype.add = function (entry) {
	  // console.error("~~ proxy add")
	  collect(entry)
	
	  if (!this._proxy) {
	    this._buffer.push(['add', [entry]])
	    this._needDrain = true
	    return false
	  }
	  return this._proxy.add(entry)
	}
	
	ProxyWriter.prototype.write = function (c) {
	  // console.error('~~ proxy write')
	  if (!this._proxy) {
	    this._buffer.push(['write', [c]])
	    this._needDrain = true
	    return false
	  }
	  return this._proxy.write(c)
	}
	
	ProxyWriter.prototype.end = function (c) {
	  // console.error('~~ proxy end')
	  if (!this._proxy) {
	    this._buffer.push(['end', [c]])
	    return false
	  }
	  return this._proxy.end(c)
	}


/***/ },
/* 784 */
/*!****************************************!*\
  !*** ./~/block-stream/block-stream.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// write data to it, and it'll emit data in 512 byte blocks.
	// if you .end() or .flush(), it'll emit whatever it's got,
	// padded with nulls to 512 bytes.
	
	module.exports = BlockStream
	
	var Stream = __webpack_require__(/*! stream */ 604).Stream
	  , inherits = __webpack_require__(/*! inherits */ 610)
	  , assert = __webpack_require__(/*! assert */ 635).ok
	  , debug = process.env.DEBUG ? console.error : function () {}
	
	function BlockStream (size, opt) {
	  this.writable = this.readable = true
	  this._opt = opt || {}
	  this._chunkSize = size || 512
	  this._offset = 0
	  this._buffer = []
	  this._bufferLength = 0
	  if (this._opt.nopad) this._zeroes = false
	  else {
	    this._zeroes = new Buffer(this._chunkSize)
	    for (var i = 0; i < this._chunkSize; i ++) {
	      this._zeroes[i] = 0
	    }
	  }
	}
	
	inherits(BlockStream, Stream)
	
	BlockStream.prototype.write = function (c) {
	  // debug("   BS write", c)
	  if (this._ended) throw new Error("BlockStream: write after end")
	  if (c && !Buffer.isBuffer(c)) c = new Buffer(c + "")
	  if (c.length) {
	    this._buffer.push(c)
	    this._bufferLength += c.length
	  }
	  // debug("pushed onto buffer", this._bufferLength)
	  if (this._bufferLength >= this._chunkSize) {
	    if (this._paused) {
	      // debug("   BS paused, return false, need drain")
	      this._needDrain = true
	      return false
	    }
	    this._emitChunk()
	  }
	  return true
	}
	
	BlockStream.prototype.pause = function () {
	  // debug("   BS pausing")
	  this._paused = true
	}
	
	BlockStream.prototype.resume = function () {
	  // debug("   BS resume")
	  this._paused = false
	  return this._emitChunk()
	}
	
	BlockStream.prototype.end = function (chunk) {
	  // debug("end", chunk)
	  if (typeof chunk === "function") cb = chunk, chunk = null
	  if (chunk) this.write(chunk)
	  this._ended = true
	  this.flush()
	}
	
	BlockStream.prototype.flush = function () {
	  this._emitChunk(true)
	}
	
	BlockStream.prototype._emitChunk = function (flush) {
	  // debug("emitChunk flush=%j emitting=%j paused=%j", flush, this._emitting, this._paused)
	
	  // emit a <chunkSize> chunk
	  if (flush && this._zeroes) {
	    // debug("    BS push zeroes", this._bufferLength)
	    // push a chunk of zeroes
	    var padBytes = (this._bufferLength % this._chunkSize)
	    if (padBytes !== 0) padBytes = this._chunkSize - padBytes
	    if (padBytes > 0) {
	      // debug("padBytes", padBytes, this._zeroes.slice(0, padBytes))
	      this._buffer.push(this._zeroes.slice(0, padBytes))
	      this._bufferLength += padBytes
	      // debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)
	    }
	  }
	
	  if (this._emitting || this._paused) return
	  this._emitting = true
	
	  // debug("    BS entering loops")
	  var bufferIndex = 0
	  while (this._bufferLength >= this._chunkSize &&
	         (flush || !this._paused)) {
	    // debug("     BS data emission loop", this._bufferLength)
	
	    var out
	      , outOffset = 0
	      , outHas = this._chunkSize
	
	    while (outHas > 0 && (flush || !this._paused) ) {
	      // debug("    BS data inner emit loop", this._bufferLength)
	      var cur = this._buffer[bufferIndex]
	        , curHas = cur.length - this._offset
	      // debug("cur=", cur)
	      // debug("curHas=%j", curHas)
	      // If it's not big enough to fill the whole thing, then we'll need
	      // to copy multiple buffers into one.  However, if it is big enough,
	      // then just slice out the part we want, to save unnecessary copying.
	      // Also, need to copy if we've already done some copying, since buffers
	      // can't be joined like cons strings.
	      if (out || curHas < outHas) {
	        out = out || new Buffer(this._chunkSize)
	        cur.copy(out, outOffset,
	                 this._offset, this._offset + Math.min(curHas, outHas))
	      } else if (cur.length === outHas && this._offset === 0) {
	        // shortcut -- cur is exactly long enough, and no offset.
	        out = cur
	      } else {
	        // slice out the piece of cur that we need.
	        out = cur.slice(this._offset, this._offset + outHas)
	      }
	
	      if (curHas > outHas) {
	        // means that the current buffer couldn't be completely output
	        // update this._offset to reflect how much WAS written
	        this._offset += outHas
	        outHas = 0
	      } else {
	        // output the entire current chunk.
	        // toss it away
	        outHas -= curHas
	        outOffset += curHas
	        bufferIndex ++
	        this._offset = 0
	      }
	    }
	
	    this._bufferLength -= this._chunkSize
	    assert(out.length === this._chunkSize)
	    // debug("emitting data", out)
	    // debug("   BS emitting, paused=%j", this._paused, this._bufferLength)
	    this.emit("data", out)
	    out = null
	  }
	  // debug("    BS out of loops", this._bufferLength)
	
	  // whatever is left, it's not enough to fill up a block, or we're paused
	  this._buffer = this._buffer.slice(bufferIndex)
	  if (this._paused) {
	    // debug("    BS paused, leaving", this._bufferLength)
	    this._needsDrain = true
	    this._emitting = false
	    return
	  }
	
	  // if flushing, and not using null-padding, then need to emit the last
	  // chunk(s) sitting in the queue.  We know that it's not enough to
	  // fill up a whole block, because otherwise it would have been emitted
	  // above, but there may be some offset.
	  var l = this._buffer.length
	  if (flush && !this._zeroes && l) {
	    if (l === 1) {
	      if (this._offset) {
	        this.emit("data", this._buffer[0].slice(this._offset))
	      } else {
	        this.emit("data", this._buffer[0])
	      }
	    } else {
	      var outHas = this._bufferLength
	        , out = new Buffer(outHas)
	        , outOffset = 0
	      for (var i = 0; i < l; i ++) {
	        var cur = this._buffer[i]
	          , curHas = cur.length - this._offset
	        cur.copy(out, outOffset, this._offset)
	        this._offset = 0
	        outOffset += curHas
	        this._bufferLength -= curHas
	      }
	      this.emit("data", out)
	    }
	    // truncate
	    this._buffer.length = 0
	    this._bufferLength = 0
	    this._offset = 0
	  }
	
	  // now either drained or ended
	  // debug("either draining, or ended", this._bufferLength, this._ended)
	  // means that we've flushed out all that we can so far.
	  if (this._needDrain) {
	    // debug("emitting drain", this._bufferLength)
	    this._needDrain = false
	    this.emit("drain")
	  }
	
	  if ((this._bufferLength === 0) && this._ended && !this._endEmitted) {
	    // debug("emitting end", this._bufferLength)
	    this._endEmitted = true
	    this.emit("end")
	  }
	
	  this._emitting = false
	
	  // debug("    BS no longer emitting", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)
	}


/***/ },
/* 785 */
/*!*********************************************!*\
  !*** ./~/tar/lib/extended-header-writer.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	module.exports = ExtendedHeaderWriter
	
	var inherits = __webpack_require__(/*! inherits */ 610)
	  , EntryWriter = __webpack_require__(/*! ./entry-writer.js */ 746)
	
	inherits(ExtendedHeaderWriter, EntryWriter)
	
	var tar = __webpack_require__(/*! ../tar.js */ 744)
	  , path = __webpack_require__(/*! path */ 521)
	  , TarHeader = __webpack_require__(/*! ./header.js */ 747)
	
	// props is the props of the thing we need to write an
	// extended header for.
	// Don't be shy with it.  Just encode everything.
	function ExtendedHeaderWriter (props) {
	  // console.error(">> ehw ctor")
	  var me = this
	
	  if (!(me instanceof ExtendedHeaderWriter)) {
	    return new ExtendedHeaderWriter(props)
	  }
	
	  me.fields = props
	
	  var p =
	    { path : ("PaxHeader" + path.join("/", props.path || ""))
	             .replace(/\\/g, "/").substr(0, 100)
	    , mode : props.mode || 0666
	    , uid : props.uid || 0
	    , gid : props.gid || 0
	    , size : 0 // will be set later
	    , mtime : props.mtime || Date.now() / 1000
	    , type : "x"
	    , linkpath : ""
	    , ustar : "ustar\0"
	    , ustarver : "00"
	    , uname : props.uname || ""
	    , gname : props.gname || ""
	    , devmaj : props.devmaj || 0
	    , devmin : props.devmin || 0
	    }
	
	
	  EntryWriter.call(me, p)
	  // console.error(">> ehw props", me.props)
	  me.props = p
	
	  me._meta = true
	}
	
	ExtendedHeaderWriter.prototype.end = function () {
	  // console.error(">> ehw end")
	  var me = this
	
	  if (me._ended) return
	  me._ended = true
	
	  me._encodeFields()
	
	  if (me.props.size === 0) {
	    // nothing to write!
	    me._ready = true
	    me._stream.end()
	    return
	  }
	
	  me._stream.write(TarHeader.encode(me.props))
	  me.body.forEach(function (l) {
	    me._stream.write(l)
	  })
	  me._ready = true
	
	  // console.error(">> ehw _process calling end()", me.props)
	  this._stream.end()
	}
	
	ExtendedHeaderWriter.prototype._encodeFields = function () {
	  // console.error(">> ehw _encodeFields")
	  this.body = []
	  if (this.fields.prefix) {
	    this.fields.path = this.fields.prefix + "/" + this.fields.path
	    this.fields.prefix = ""
	  }
	  encodeFields(this.fields, "", this.body, this.fields.noProprietary)
	  var me = this
	  this.body.forEach(function (l) {
	    me.props.size += l.length
	  })
	}
	
	function encodeFields (fields, prefix, body, nop) {
	  // console.error(">> >> ehw encodeFields")
	  // "%d %s=%s\n", <length>, <keyword>, <value>
	  // The length is a decimal number, and includes itself and the \n
	  // Numeric values are decimal strings.
	
	  Object.keys(fields).forEach(function (k) {
	    var val = fields[k]
	      , numeric = tar.numeric[k]
	
	    if (prefix) k = prefix + "." + k
	
	    // already including NODETAR.type, don't need File=true also
	    if (k === fields.type && val === true) return
	
	    switch (k) {
	      // don't include anything that's always handled just fine
	      // in the normal header, or only meaningful in the context
	      // of nodetar
	      case "mode":
	      case "cksum":
	      case "ustar":
	      case "ustarver":
	      case "prefix":
	      case "basename":
	      case "dirname":
	      case "needExtended":
	      case "block":
	      case "filter":
	        return
	
	      case "rdev":
	        if (val === 0) return
	        break
	
	      case "nlink":
	      case "dev": // Truly a hero among men, Creator of Star!
	      case "ino": // Speak his name with reverent awe!  It is:
	        k = "SCHILY." + k
	        break
	
	      default: break
	    }
	
	    if (val && typeof val === "object" &&
	        !Buffer.isBuffer(val)) encodeFields(val, k, body, nop)
	    else if (val === null || val === undefined) return
	    else body.push.apply(body, encodeField(k, val, nop))
	  })
	
	  return body
	}
	
	function encodeField (k, v, nop) {
	  // lowercase keys must be valid, otherwise prefix with
	  // "NODETAR."
	  if (k.charAt(0) === k.charAt(0).toLowerCase()) {
	    var m = k.split(".")[0]
	    if (!tar.knownExtended[m]) k = "NODETAR." + k
	  }
	
	  // no proprietary
	  if (nop && k.charAt(0) !== k.charAt(0).toLowerCase()) {
	    return []
	  }
	
	  if (typeof val === "number") val = val.toString(10)
	
	  var s = new Buffer(" " + k + "=" + v + "\n")
	    , digits = Math.floor(Math.log(s.length) / Math.log(10)) + 1
	
	  // console.error("1 s=%j digits=%j s.length=%d", s.toString(), digits, s.length)
	
	  // if adding that many digits will make it go over that length,
	  // then add one to it. For example, if the string is:
	  // " foo=bar\n"
	  // then that's 9 characters.  With the "9", that bumps the length
	  // up to 10.  However, this is invalid:
	  // "10 foo=bar\n"
	  // but, since that's actually 11 characters, since 10 adds another
	  // character to the length, and the length includes the number
	  // itself.  In that case, just bump it up again.
	  if (s.length + digits >= Math.pow(10, digits)) digits += 1
	  // console.error("2 s=%j digits=%j s.length=%d", s.toString(), digits, s.length)
	
	  var len = digits + s.length
	  // console.error("3 s=%j digits=%j s.length=%d len=%d", s.toString(), digits, s.length, len)
	  var lenBuf = new Buffer("" + len)
	  if (lenBuf.length + s.length !== len) {
	    throw new Error("Bad length calculation\n"+
	                    "len="+len+"\n"+
	                    "lenBuf="+JSON.stringify(lenBuf.toString())+"\n"+
	                    "lenBuf.length="+lenBuf.length+"\n"+
	                    "digits="+digits+"\n"+
	                    "s="+JSON.stringify(s.toString())+"\n"+
	                    "s.length="+s.length)
	  }
	
	  return [lenBuf, s]
	}


/***/ },
/* 786 */
/*!*******************************************!*\
  !*** ./~/tar/lib/global-header-writer.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = GlobalHeaderWriter
	
	var ExtendedHeaderWriter = __webpack_require__(/*! ./extended-header-writer.js */ 785)
	  , inherits = __webpack_require__(/*! inherits */ 610)
	
	inherits(GlobalHeaderWriter, ExtendedHeaderWriter)
	
	function GlobalHeaderWriter (props) {
	  if (!(this instanceof GlobalHeaderWriter)) {
	    return new GlobalHeaderWriter(props)
	  }
	  ExtendedHeaderWriter.call(this, props)
	  this.props.type = "g"
	}


/***/ },
/* 787 */
/*!****************************!*\
  !*** ./~/tar/lib/parse.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	
	// A writable stream.
	// It emits "entry" events, which provide a readable stream that has
	// header info attached.
	
	module.exports = Parse.create = Parse
	
	var stream = __webpack_require__(/*! stream */ 604)
	  , Stream = stream.Stream
	  , BlockStream = __webpack_require__(/*! block-stream */ 784)
	  , tar = __webpack_require__(/*! ../tar.js */ 744)
	  , TarHeader = __webpack_require__(/*! ./header.js */ 747)
	  , Entry = __webpack_require__(/*! ./entry.js */ 748)
	  , BufferEntry = __webpack_require__(/*! ./buffer-entry.js */ 788)
	  , ExtendedHeader = __webpack_require__(/*! ./extended-header.js */ 789)
	  , assert = __webpack_require__(/*! assert */ 635).ok
	  , inherits = __webpack_require__(/*! inherits */ 610)
	  , fstream = __webpack_require__(/*! fstream */ 749)
	
	// reading a tar is a lot like reading a directory
	// However, we're actually not going to run the ctor,
	// since it does a stat and various other stuff.
	// This inheritance gives us the pause/resume/pipe
	// behavior that is desired.
	inherits(Parse, fstream.Reader)
	
	function Parse () {
	  var me = this
	  if (!(me instanceof Parse)) return new Parse()
	
	  // doesn't apply fstream.Reader ctor?
	  // no, becasue we don't want to stat/etc, we just
	  // want to get the entry/add logic from .pipe()
	  Stream.apply(me)
	
	  me.writable = true
	  me.readable = true
	  me._stream = new BlockStream(512)
	  me.position = 0
	  me._ended = false
	
	  me._stream.on("error", function (e) {
	    me.emit("error", e)
	  })
	
	  me._stream.on("data", function (c) {
	    me._process(c)
	  })
	
	  me._stream.on("end", function () {
	    me._streamEnd()
	  })
	
	  me._stream.on("drain", function () {
	    me.emit("drain")
	  })
	}
	
	// overridden in Extract class, since it needs to
	// wait for its DirWriter part to finish before
	// emitting "end"
	Parse.prototype._streamEnd = function () {
	  var me = this
	  if (!me._ended || me._entry) me.error("unexpected eof")
	  me.emit("end")
	}
	
	// a tar reader is actually a filter, not just a readable stream.
	// So, you should pipe a tarball stream into it, and it needs these
	// write/end methods to do that.
	Parse.prototype.write = function (c) {
	  if (this._ended) {
	    // gnutar puts a LOT of nulls at the end.
	    // you can keep writing these things forever.
	    // Just ignore them.
	    for (var i = 0, l = c.length; i > l; i ++) {
	      if (c[i] !== 0) return this.error("write() after end()")
	    }
	    return
	  }
	  return this._stream.write(c)
	}
	
	Parse.prototype.end = function (c) {
	  this._ended = true
	  return this._stream.end(c)
	}
	
	// don't need to do anything, since we're just
	// proxying the data up from the _stream.
	// Just need to override the parent's "Not Implemented"
	// error-thrower.
	Parse.prototype._read = function () {}
	
	Parse.prototype._process = function (c) {
	  assert(c && c.length === 512, "block size should be 512")
	
	  // one of three cases.
	  // 1. A new header
	  // 2. A part of a file/extended header
	  // 3. One of two or more EOF null blocks
	
	  if (this._entry) {
	    var entry = this._entry
	    if(!entry._abort) entry.write(c)
	    else {
	      entry._remaining -= c.length
	      if(entry._remaining < 0) entry._remaining = 0
	    }
	    if (entry._remaining === 0) {
	      entry.end()
	      this._entry = null
	    }
	  } else {
	    // either zeroes or a header
	    var zero = true
	    for (var i = 0; i < 512 && zero; i ++) {
	      zero = c[i] === 0
	    }
	
	    // eof is *at least* 2 blocks of nulls, and then the end of the
	    // file.  you can put blocks of nulls between entries anywhere,
	    // so appending one tarball to another is technically valid.
	    // ending without the eof null blocks is not allowed, however.
	    if (zero) {
	      if (this._eofStarted)
	        this._ended = true
	      this._eofStarted = true
	    } else {
	      this._eofStarted = false
	      this._startEntry(c)
	    }
	  }
	
	  this.position += 512
	}
	
	// take a header chunk, start the right kind of entry.
	Parse.prototype._startEntry = function (c) {
	  var header = new TarHeader(c)
	    , self = this
	    , entry
	    , ev
	    , EntryType
	    , onend
	    , meta = false
	
	  if (null === header.size || !header.cksumValid) {
	    var e = new Error("invalid tar file")
	    e.header = header
	    e.tar_file_offset = this.position
	    e.tar_block = this.position / 512
	    return this.emit("error", e)
	  }
	
	  switch (tar.types[header.type]) {
	    case "File":
	    case "OldFile":
	    case "Link":
	    case "SymbolicLink":
	    case "CharacterDevice":
	    case "BlockDevice":
	    case "Directory":
	    case "FIFO":
	    case "ContiguousFile":
	    case "GNUDumpDir":
	      // start a file.
	      // pass in any extended headers
	      // These ones consumers are typically most interested in.
	      EntryType = Entry
	      ev = "entry"
	      break
	
	    case "GlobalExtendedHeader":
	      // extended headers that apply to the rest of the tarball
	      EntryType = ExtendedHeader
	      onend = function () {
	        self._global = self._global || {}
	        Object.keys(entry.fields).forEach(function (k) {
	          self._global[k] = entry.fields[k]
	        })
	      }
	      ev = "globalExtendedHeader"
	      meta = true
	      break
	
	    case "ExtendedHeader":
	    case "OldExtendedHeader":
	      // extended headers that apply to the next entry
	      EntryType = ExtendedHeader
	      onend = function () {
	        self._extended = entry.fields
	      }
	      ev = "extendedHeader"
	      meta = true
	      break
	
	    case "NextFileHasLongLinkpath":
	      // set linkpath=<contents> in extended header
	      EntryType = BufferEntry
	      onend = function () {
	        self._extended = self._extended || {}
	        self._extended.linkpath = entry.body
	      }
	      ev = "longLinkpath"
	      meta = true
	      break
	
	    case "NextFileHasLongPath":
	    case "OldGnuLongPath":
	      // set path=<contents> in file-extended header
	      EntryType = BufferEntry
	      onend = function () {
	        self._extended = self._extended || {}
	        self._extended.path = entry.body
	      }
	      ev = "longPath"
	      meta = true
	      break
	
	    default:
	      // all the rest we skip, but still set the _entry
	      // member, so that we can skip over their data appropriately.
	      // emit an event to say that this is an ignored entry type?
	      EntryType = Entry
	      ev = "ignoredEntry"
	      break
	  }
	
	  var global, extended
	  if (meta) {
	    global = extended = null
	  } else {
	    var global = this._global
	    var extended = this._extended
	
	    // extendedHeader only applies to one entry, so once we start
	    // an entry, it's over.
	    this._extended = null
	  }
	  entry = new EntryType(header, extended, global)
	  entry.meta = meta
	
	  // only proxy data events of normal files.
	  if (!meta) {
	    entry.on("data", function (c) {
	      me.emit("data", c)
	    })
	  }
	
	  if (onend) entry.on("end", onend)
	
	  this._entry = entry
	  var me = this
	
	  entry.on("pause", function () {
	    me.pause()
	  })
	
	  entry.on("resume", function () {
	    me.resume()
	  })
	
	  if (this.listeners("*").length) {
	    this.emit("*", ev, entry)
	  }
	
	  this.emit(ev, entry)
	
	  // Zero-byte entry.  End immediately.
	  if (entry.props.size === 0) {
	    entry.end()
	    this._entry = null
	  }
	}


/***/ },
/* 788 */
/*!***********************************!*\
  !*** ./~/tar/lib/buffer-entry.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	// just like the Entry class, but it buffers the contents
	//
	// XXX It would be good to set a maximum BufferEntry filesize,
	// since it eats up memory.  In normal operation,
	// these are only for long filenames or link names, which are
	// rarely very big.
	
	module.exports = BufferEntry
	
	var inherits = __webpack_require__(/*! inherits */ 610)
	  , Entry = __webpack_require__(/*! ./entry.js */ 748)
	
	function BufferEntry () {
	  Entry.apply(this, arguments)
	  this._buffer = new Buffer(this.props.size)
	  this._offset = 0
	  this.body = ""
	  this.on("end", function () {
	    this.body = this._buffer.toString().slice(0, -1)
	  })
	}
	
	inherits(BufferEntry, Entry)
	
	// collect the bytes as they come in.
	BufferEntry.prototype.write = function (c) {
	  c.copy(this._buffer, this._offset)
	  this._offset += c.length
	  Entry.prototype.write.call(this, c)
	}


/***/ },
/* 789 */
/*!**************************************!*\
  !*** ./~/tar/lib/extended-header.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	// An Entry consisting of:
	//
	// "%d %s=%s\n", <length>, <keyword>, <value>
	//
	// The length is a decimal number, and includes itself and the \n
	// \0 does not terminate anything.  Only the length terminates the string.
	// Numeric values are decimal strings.
	
	module.exports = ExtendedHeader
	
	var Entry = __webpack_require__(/*! ./entry.js */ 748)
	  , inherits = __webpack_require__(/*! inherits */ 610)
	  , tar = __webpack_require__(/*! ../tar.js */ 744)
	  , numeric = tar.numeric
	  , keyTrans = { "SCHILY.dev": "dev"
	               , "SCHILY.ino": "ino"
	               , "SCHILY.nlink": "nlink" }
	
	function ExtendedHeader () {
	  Entry.apply(this, arguments)
	  this.on("data", this._parse)
	  this.fields = {}
	  this._position = 0
	  this._fieldPos = 0
	  this._state = SIZE
	  this._sizeBuf = []
	  this._keyBuf = []
	  this._valBuf = []
	  this._size = -1
	  this._key = ""
	}
	
	inherits(ExtendedHeader, Entry)
	ExtendedHeader.prototype._parse = parse
	
	var s = 0
	  , states = ExtendedHeader.states = {}
	  , SIZE = states.SIZE = s++
	  , KEY  = states.KEY  = s++
	  , VAL  = states.VAL  = s++
	  , ERR  = states.ERR  = s++
	
	Object.keys(states).forEach(function (s) {
	  states[states[s]] = states[s]
	})
	
	states[s] = null
	
	// char code values for comparison
	var _0 = "0".charCodeAt(0)
	  , _9 = "9".charCodeAt(0)
	  , point = ".".charCodeAt(0)
	  , a = "a".charCodeAt(0)
	  , Z = "Z".charCodeAt(0)
	  , a = "a".charCodeAt(0)
	  , z = "z".charCodeAt(0)
	  , space = " ".charCodeAt(0)
	  , eq = "=".charCodeAt(0)
	  , cr = "\n".charCodeAt(0)
	
	function parse (c) {
	  if (this._state === ERR) return
	
	  for ( var i = 0, l = c.length
	      ; i < l
	      ; this._position++, this._fieldPos++, i++) {
	    // console.error("top of loop, size="+this._size)
	
	    var b = c[i]
	
	    if (this._size >= 0 && this._fieldPos > this._size) {
	      error(this, "field exceeds length="+this._size)
	      return
	    }
	
	    switch (this._state) {
	      case ERR: return
	
	      case SIZE:
	        // console.error("parsing size, b=%d, rest=%j", b, c.slice(i).toString())
	        if (b === space) {
	          this._state = KEY
	          // this._fieldPos = this._sizeBuf.length
	          this._size = parseInt(new Buffer(this._sizeBuf).toString(), 10)
	          this._sizeBuf.length = 0
	          continue
	        }
	        if (b < _0 || b > _9) {
	          error(this, "expected [" + _0 + ".." + _9 + "], got " + b)
	          return
	        }
	        this._sizeBuf.push(b)
	        continue
	
	      case KEY:
	        // can be any char except =, not > size.
	        if (b === eq) {
	          this._state = VAL
	          this._key = new Buffer(this._keyBuf).toString()
	          if (keyTrans[this._key]) this._key = keyTrans[this._key]
	          this._keyBuf.length = 0
	          continue
	        }
	        this._keyBuf.push(b)
	        continue
	
	      case VAL:
	        // field must end with cr
	        if (this._fieldPos === this._size - 1) {
	          // console.error("finished with "+this._key)
	          if (b !== cr) {
	            error(this, "expected \\n at end of field")
	            return
	          }
	          var val = new Buffer(this._valBuf).toString()
	          if (numeric[this._key]) {
	            val = parseFloat(val)
	          }
	          this.fields[this._key] = val
	
	          this._valBuf.length = 0
	          this._state = SIZE
	          this._size = -1
	          this._fieldPos = -1
	          continue
	        }
	        this._valBuf.push(b)
	        continue
	    }
	  }
	}
	
	function error (me, msg) {
	  msg = "invalid header: " + msg
	      + "\nposition=" + me._position
	      + "\nfield position=" + me._fieldPos
	
	  me.error(msg)
	  me.state = ERR
	}


/***/ },
/* 790 */
/*!******************************!*\
  !*** ./~/tar/lib/extract.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	// give it a tarball and a path, and it'll dump the contents
	
	module.exports = Extract
	
	var tar = __webpack_require__(/*! ../tar.js */ 744)
	  , fstream = __webpack_require__(/*! fstream */ 749)
	  , inherits = __webpack_require__(/*! inherits */ 610)
	  , path = __webpack_require__(/*! path */ 521)
	
	function Extract (opts) {
	  if (!(this instanceof Extract)) return new Extract(opts)
	  tar.Parse.apply(this)
	
	  if (typeof opts !== "object") {
	    opts = { path: opts }
	  }
	
	  // better to drop in cwd? seems more standard.
	  opts.path = opts.path || path.resolve("node-tar-extract")
	  opts.type = "Directory"
	  opts.Directory = true
	
	  // similar to --strip or --strip-components
	  opts.strip = +opts.strip
	  if (!opts.strip || opts.strip <= 0) opts.strip = 0
	
	  this._fst = fstream.Writer(opts)
	
	  this.pause()
	  var me = this
	
	  // Hardlinks in tarballs are relative to the root
	  // of the tarball.  So, they need to be resolved against
	  // the target directory in order to be created properly.
	  me.on("entry", function (entry) {
	    // if there's a "strip" argument, then strip off that many
	    // path components.
	    if (opts.strip) {
	      var p = entry.path.split("/").slice(opts.strip).join("/")
	      entry.path = entry.props.path = p
	      if (entry.linkpath) {
	        var lp = entry.linkpath.split("/").slice(opts.strip).join("/")
	        entry.linkpath = entry.props.linkpath = lp
	      }
	    }
	    if (entry.type === "Link") {
	      entry.linkpath = entry.props.linkpath =
	        path.join(opts.path, path.join("/", entry.props.linkpath))
	    }
	
	    if (entry.type === "SymbolicLink") {
	      var dn = path.dirname(entry.path) || ""
	      var linkpath = entry.props.linkpath
	      var target = path.resolve(opts.path, dn, linkpath)
	      if (target.indexOf(opts.path) !== 0) {
	        linkpath = path.join(opts.path, path.join("/", linkpath))
	      }
	      entry.linkpath = entry.props.linkpath = linkpath
	    }
	  })
	
	  this._fst.on("ready", function () {
	    me.pipe(me._fst, { end: false })
	    me.resume()
	  })
	
	  this._fst.on('error', function(err) {
	    me.emit('error', err)
	  })
	
	  this._fst.on('drain', function() {
	    me.emit('drain')
	  })
	
	  // this._fst.on("end", function () {
	  //   console.error("\nEEEE Extract End", me._fst.path)
	  // })
	
	  this._fst.on("close", function () {
	    // console.error("\nEEEE Extract End", me._fst.path)
	    me.emit("finish")
	    me.emit("end")
	    me.emit("close")
	  })
	}
	
	inherits(Extract, tar.Parse)
	
	Extract.prototype._streamEnd = function () {
	  var me = this
	  if (!me._ended || me._entry) me.error("unexpected eof")
	  me._fst.end()
	  // my .end() is coming later.
	}


/***/ },
/* 791 */
/*!**************************!*\
  !*** ./~/unzip/unzip.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.Parse = __webpack_require__(/*! ./lib/parse */ 792);
	exports.Extract = __webpack_require__(/*! ./lib/extract */ 808);

/***/ },
/* 792 */
/*!******************************!*\
  !*** ./~/unzip/lib/parse.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = Parse.create = Parse;
	
	__webpack_require__(/*! setimmediate */ 793);
	var Transform = __webpack_require__(/*! readable-stream/transform */ 794);
	var inherits = __webpack_require__(/*! util */ 597).inherits;
	var zlib = __webpack_require__(/*! zlib */ 605);
	var binary = __webpack_require__(/*! binary */ 796);
	var PullStream = __webpack_require__(/*! pullstream */ 801);
	var MatchStream = __webpack_require__(/*! match-stream */ 806);
	var Entry = __webpack_require__(/*! ./entry */ 807);
	
	inherits(Parse, Transform);
	
	function Parse(opts) {
	  var self = this;
	  if (!(this instanceof Parse)) {
	    return new Parse(opts);
	  }
	
	  Transform.call(this, { lowWaterMark: 0 });
	  this._opts = opts || { verbose: false };
	  this._hasEntryListener = false;
	
	  this._pullStream = new PullStream();
	  this._pullStream.on("error", function (e) {
	    self.emit('error', e);
	  });
	  this._pullStream.once("end", function () {
	    self._streamEnd = true;
	  });
	  this._pullStream.once("finish", function () {
	    self._streamFinish = true;
	  });
	
	  this._readRecord();
	}
	
	Parse.prototype._readRecord = function () {
	  var self = this;
	  this._pullStream.pull(4, function (err, data) {
	    if (err) {
	      return self.emit('error', err);
	    }
	
	    if (data.length === 0) {
	      return;
	    }
	
	    var signature = data.readUInt32LE(0);
	    if (signature === 0x04034b50) {
	      self._readFile();
	    } else if (signature === 0x02014b50) {
	      self._readCentralDirectoryFileHeader();
	    } else if (signature === 0x06054b50) {
	      self._readEndOfCentralDirectoryRecord();
	    } else {
	      err = new Error('invalid signature: 0x' + signature.toString(16));
	      self.emit('error', err);
	    }
	  });
	};
	
	Parse.prototype._readFile = function () {
	  var self = this;
	  this._pullStream.pull(26, function (err, data) {
	    if (err) {
	      return self.emit('error', err);
	    }
	
	    var vars = binary.parse(data)
	      .word16lu('versionsNeededToExtract')
	      .word16lu('flags')
	      .word16lu('compressionMethod')
	      .word16lu('lastModifiedTime')
	      .word16lu('lastModifiedDate')
	      .word32lu('crc32')
	      .word32lu('compressedSize')
	      .word32lu('uncompressedSize')
	      .word16lu('fileNameLength')
	      .word16lu('extraFieldLength')
	      .vars;
	
	    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
	      if (err) {
	        return self.emit('error', err);
	      }
	      fileName = fileName.toString('utf8');
	      var entry = new Entry();
	      entry.path = fileName;
	      entry.props.path = fileName;
	      entry.type = (vars.compressedSize === 0 && /[\/\\]$/.test(fileName)) ? 'Directory' : 'File';
	
	      if (self._opts.verbose) {
	        if (entry.type === 'Directory') {
	          console.log('   creating:', fileName);
	        } else if (entry.type === 'File') {
	          if (vars.compressionMethod === 0) {
	            console.log(' extracting:', fileName);
	          } else {
	            console.log('  inflating:', fileName);
	          }
	        }
	      }
	
	      var hasEntryListener = self._hasEntryListener;
	      if (hasEntryListener) {
	        self.emit('entry', entry);
	      }
	
	      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
	        if (err) {
	          return self.emit('error', err);
	        }
	        if (vars.compressionMethod === 0) {
	          self._pullStream.pull(vars.compressedSize, function (err, compressedData) {
	            if (err) {
	              return self.emit('error', err);
	            }
	
	            if (hasEntryListener) {
	              entry.write(compressedData);
	              entry.end();
	            }
	
	            return self._readRecord();
	          });
	        } else {
	          var fileSizeKnown = !(vars.flags & 0x08);
	
	          var inflater = zlib.createInflateRaw();
	          inflater.on('error', function (err) {
	            self.emit('error', err);
	          });
	
	          if (fileSizeKnown) {
	            entry.size = vars.uncompressedSize;
	            if (hasEntryListener) {
	              entry.on('finish', self._readRecord.bind(self));
	              self._pullStream.pipe(vars.compressedSize, inflater).pipe(entry);
	            } else {
	              self._pullStream.drain(vars.compressedSize, function (err) {
	                if (err) {
	                  return self.emit('error', err);
	                }
	                self._readRecord();
	              });
	            }
	          } else {
	            var descriptorSig = new Buffer(4);
	            descriptorSig.writeUInt32LE(0x08074b50, 0);
	
	            var matchStream = new MatchStream({ pattern: descriptorSig }, function (buf, matched, extra) {
	              if (hasEntryListener) {
	                if (!matched) {
	                  return this.push(buf);
	                }
	                this.push(buf);
	              }
	              setImmediate(function() {
	                self._pullStream.unpipe();
	                self._pullStream.prepend(extra);
	                self._processDataDescriptor(entry);
	              });
	              return this.push(null);
	            });
	
	            self._pullStream.pipe(matchStream);
	            if (hasEntryListener) {
	              matchStream.pipe(inflater).pipe(entry);
	            }
	          }
	        }
	      });
	    });
	  });
	};
	
	Parse.prototype._processDataDescriptor = function (entry) {
	  var self = this;
	  this._pullStream.pull(16, function (err, data) {
	    if (err) {
	      return self.emit('error', err);
	    }
	
	    var vars = binary.parse(data)
	      .word32lu('dataDescriptorSignature')
	      .word32lu('crc32')
	      .word32lu('compressedSize')
	      .word32lu('uncompressedSize')
	      .vars;
	
	    entry.size = vars.uncompressedSize;
	    self._readRecord();
	  });
	};
	
	Parse.prototype._readCentralDirectoryFileHeader = function () {
	  var self = this;
	  this._pullStream.pull(42, function (err, data) {
	    if (err) {
	      return self.emit('error', err);
	    }
	
	    var vars = binary.parse(data)
	      .word16lu('versionMadeBy')
	      .word16lu('versionsNeededToExtract')
	      .word16lu('flags')
	      .word16lu('compressionMethod')
	      .word16lu('lastModifiedTime')
	      .word16lu('lastModifiedDate')
	      .word32lu('crc32')
	      .word32lu('compressedSize')
	      .word32lu('uncompressedSize')
	      .word16lu('fileNameLength')
	      .word16lu('extraFieldLength')
	      .word16lu('fileCommentLength')
	      .word16lu('diskNumber')
	      .word16lu('internalFileAttributes')
	      .word32lu('externalFileAttributes')
	      .word32lu('offsetToLocalFileHeader')
	      .vars;
	
	    return self._pullStream.pull(vars.fileNameLength, function (err, fileName) {
	      if (err) {
	        return self.emit('error', err);
	      }
	      fileName = fileName.toString('utf8');
	
	      self._pullStream.pull(vars.extraFieldLength, function (err, extraField) {
	        if (err) {
	          return self.emit('error', err);
	        }
	        self._pullStream.pull(vars.fileCommentLength, function (err, fileComment) {
	          if (err) {
	            return self.emit('error', err);
	          }
	          return self._readRecord();
	        });
	      });
	    });
	  });
	};
	
	Parse.prototype._readEndOfCentralDirectoryRecord = function () {
	  var self = this;
	  this._pullStream.pull(18, function (err, data) {
	    if (err) {
	      return self.emit('error', err);
	    }
	
	    var vars = binary.parse(data)
	      .word16lu('diskNumber')
	      .word16lu('diskStart')
	      .word16lu('numberOfRecordsOnDisk')
	      .word16lu('numberOfRecords')
	      .word32lu('sizeOfCentralDirectory')
	      .word32lu('offsetToStartOfCentralDirectory')
	      .word16lu('commentLength')
	      .vars;
	
	    if (vars.commentLength) {
	      setImmediate(function() {
	        self._pullStream.pull(vars.commentLength, function (err, comment) {
	          if (err) {
	            return self.emit('error', err);
	          }
	          comment = comment.toString('utf8');
	          return self._pullStream.end();
	        });
	      });
	
	    } else {
	      self._pullStream.end();
	    }
	  });
	};
	
	Parse.prototype._transform = function (chunk, encoding, callback) {
	  if (this._pullStream.write(chunk)) {
	    return callback();
	  }
	
	  this._pullStream.once('drain', callback);
	};
	
	Parse.prototype.pipe = function (dest, opts) {
	  var self = this;
	  if (typeof dest.add === "function") {
	    self.on("entry", function (entry) {
	      dest.add(entry);
	    })
	  }
	  return Transform.prototype.pipe.apply(this, arguments);
	};
	
	Parse.prototype._flush = function (callback) {
	  if (!this._streamEnd || !this._streamFinish) {
	    return setImmediate(this._flush.bind(this, callback));
	  }
	
	  this.emit('close');
	  return callback();
	};
	
	Parse.prototype.addListener = function(type, listener) {
	  if ('entry' === type) {
	    this._hasEntryListener = true;
	  }
	  return Transform.prototype.addListener.call(this, type, listener);
	};
	
	Parse.prototype.on = Parse.prototype.addListener;


/***/ },
/* 793 */
/*!****************************************!*\
  !*** ./~/setimmediate/setImmediate.js ***!
  \****************************************/
/***/ function(module, exports) {

	(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var setImmediate;
	
	    function addFromSetImmediateArguments(args) {
	        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
	        return nextHandle++;
	    }
	
	    // This function accepts the same arguments as setImmediate, but
	    // returns a function that requires no arguments.
	    function partiallyApplied(handler) {
	        var args = [].slice.call(arguments, 1);
	        return function() {
	            if (typeof handler === "function") {
	                handler.apply(undefined, args);
	            } else {
	                (new Function("" + handler))();
	            }
	        };
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(partiallyApplied(runIfPresent, handle), 0);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    task();
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function installNextTickImplementation() {
	        setImmediate = function() {
	            var handle = addFromSetImmediateArguments(arguments);
	            process.nextTick(partiallyApplied(runIfPresent, handle));
	            return handle;
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        setImmediate = function() {
	            var handle = addFromSetImmediateArguments(arguments);
	            global.postMessage(messagePrefix + handle, "*");
	            return handle;
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        setImmediate = function() {
	            var handle = addFromSetImmediateArguments(arguments);
	            channel.port2.postMessage(handle);
	            return handle;
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        setImmediate = function() {
	            var handle = addFromSetImmediateArguments(arguments);
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	            return handle;
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        setImmediate = function() {
	            var handle = addFromSetImmediateArguments(arguments);
	            setTimeout(partiallyApplied(runIfPresent, handle), 0);
	            return handle;
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));


/***/ },
/* 794 */
/*!****************************************!*\
  !*** ./~/readable-stream/transform.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_transform.js */ 795)


/***/ },
/* 795 */
/*!****************************************************!*\
  !*** ./~/readable-stream/lib/_stream_transform.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(/*! ./_stream_duplex */ 608);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 609);
	util.inherits = __webpack_require__(/*! inherits */ 610);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	
	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (!util.isNullOrUndefined(data))
	    stream.push(data);
	
	  if (cb)
	    cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	
	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(options, this);
	
	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}
	
	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};
	
	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;
	
	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	
	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');
	
	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');
	
	  return stream.push(null);
	}


/***/ },
/* 796 */
/*!***************************!*\
  !*** ./~/binary/index.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	var Chainsaw = __webpack_require__(/*! chainsaw */ 797);
	var EventEmitter = __webpack_require__(/*! events */ 614).EventEmitter;
	var Buffers = __webpack_require__(/*! buffers */ 799);
	var Vars = __webpack_require__(/*! ./lib/vars.js */ 800);
	var Stream = __webpack_require__(/*! stream */ 604).Stream;
	
	exports = module.exports = function (bufOrEm, eventName) {
	    if (Buffer.isBuffer(bufOrEm)) {
	        return exports.parse(bufOrEm);
	    }
	    
	    var s = exports.stream();
	    if (bufOrEm && bufOrEm.pipe) {
	        bufOrEm.pipe(s);
	    }
	    else if (bufOrEm) {
	        bufOrEm.on(eventName || 'data', function (buf) {
	            s.write(buf);
	        });
	        
	        bufOrEm.on('end', function () {
	            s.end();
	        });
	    }
	    return s;
	};
	
	exports.stream = function (input) {
	    if (input) return exports.apply(null, arguments);
	    
	    var pending = null;
	    function getBytes (bytes, cb, skip) {
	        pending = {
	            bytes : bytes,
	            skip : skip,
	            cb : function (buf) {
	                pending = null;
	                cb(buf);
	            },
	        };
	        dispatch();
	    }
	    
	    var offset = null;
	    function dispatch () {
	        if (!pending) {
	            if (caughtEnd) done = true;
	            return;
	        }
	        if (typeof pending === 'function') {
	            pending();
	        }
	        else {
	            var bytes = offset + pending.bytes;
	            
	            if (buffers.length >= bytes) {
	                var buf;
	                if (offset == null) {
	                    buf = buffers.splice(0, bytes);
	                    if (!pending.skip) {
	                        buf = buf.slice();
	                    }
	                }
	                else {
	                    if (!pending.skip) {
	                        buf = buffers.slice(offset, bytes);
	                    }
	                    offset = bytes;
	                }
	                
	                if (pending.skip) {
	                    pending.cb();
	                }
	                else {
	                    pending.cb(buf);
	                }
	            }
	        }
	    }
	    
	    function builder (saw) {
	        function next () { if (!done) saw.next() }
	        
	        var self = words(function (bytes, cb) {
	            return function (name) {
	                getBytes(bytes, function (buf) {
	                    vars.set(name, cb(buf));
	                    next();
	                });
	            };
	        });
	        
	        self.tap = function (cb) {
	            saw.nest(cb, vars.store);
	        };
	        
	        self.into = function (key, cb) {
	            if (!vars.get(key)) vars.set(key, {});
	            var parent = vars;
	            vars = Vars(parent.get(key));
	            
	            saw.nest(function () {
	                cb.apply(this, arguments);
	                this.tap(function () {
	                    vars = parent;
	                });
	            }, vars.store);
	        };
	        
	        self.flush = function () {
	            vars.store = {};
	            next();
	        };
	        
	        self.loop = function (cb) {
	            var end = false;
	            
	            saw.nest(false, function loop () {
	                this.vars = vars.store;
	                cb.call(this, function () {
	                    end = true;
	                    next();
	                }, vars.store);
	                this.tap(function () {
	                    if (end) saw.next()
	                    else loop.call(this)
	                }.bind(this));
	            }, vars.store);
	        };
	        
	        self.buffer = function (name, bytes) {
	            if (typeof bytes === 'string') {
	                bytes = vars.get(bytes);
	            }
	            
	            getBytes(bytes, function (buf) {
	                vars.set(name, buf);
	                next();
	            });
	        };
	        
	        self.skip = function (bytes) {
	            if (typeof bytes === 'string') {
	                bytes = vars.get(bytes);
	            }
	            
	            getBytes(bytes, function () {
	                next();
	            });
	        };
	        
	        self.scan = function find (name, search) {
	            if (typeof search === 'string') {
	                search = new Buffer(search);
	            }
	            else if (!Buffer.isBuffer(search)) {
	                throw new Error('search must be a Buffer or a string');
	            }
	            
	            var taken = 0;
	            pending = function () {
	                var pos = buffers.indexOf(search, offset + taken);
	                var i = pos-offset-taken;
	                if (pos !== -1) {
	                    pending = null;
	                    if (offset != null) {
	                        vars.set(
	                            name,
	                            buffers.slice(offset, offset + taken + i)
	                        );
	                        offset += taken + i + search.length;
	                    }
	                    else {
	                        vars.set(
	                            name,
	                            buffers.slice(0, taken + i)
	                        );
	                        buffers.splice(0, taken + i + search.length);
	                    }
	                    next();
	                    dispatch();
	                } else {
	                    i = Math.max(buffers.length - search.length - offset - taken, 0);
					}
	                taken += i;
	            };
	            dispatch();
	        };
	        
	        self.peek = function (cb) {
	            offset = 0;
	            saw.nest(function () {
	                cb.call(this, vars.store);
	                this.tap(function () {
	                    offset = null;
	                });
	            });
	        };
	        
	        return self;
	    };
	    
	    var stream = Chainsaw.light(builder);
	    stream.writable = true;
	    
	    var buffers = Buffers();
	    
	    stream.write = function (buf) {
	        buffers.push(buf);
	        dispatch();
	    };
	    
	    var vars = Vars();
	    
	    var done = false, caughtEnd = false;
	    stream.end = function () {
	        caughtEnd = true;
	    };
	    
	    stream.pipe = Stream.prototype.pipe;
	    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {
	        stream[name] = EventEmitter.prototype[name];
	    });
	    
	    return stream;
	};
	
	exports.parse = function parse (buffer) {
	    var self = words(function (bytes, cb) {
	        return function (name) {
	            if (offset + bytes <= buffer.length) {
	                var buf = buffer.slice(offset, offset + bytes);
	                offset += bytes;
	                vars.set(name, cb(buf));
	            }
	            else {
	                vars.set(name, null);
	            }
	            return self;
	        };
	    });
	    
	    var offset = 0;
	    var vars = Vars();
	    self.vars = vars.store;
	    
	    self.tap = function (cb) {
	        cb.call(self, vars.store);
	        return self;
	    };
	    
	    self.into = function (key, cb) {
	        if (!vars.get(key)) {
	            vars.set(key, {});
	        }
	        var parent = vars;
	        vars = Vars(parent.get(key));
	        cb.call(self, vars.store);
	        vars = parent;
	        return self;
	    };
	    
	    self.loop = function (cb) {
	        var end = false;
	        var ender = function () { end = true };
	        while (end === false) {
	            cb.call(self, ender, vars.store);
	        }
	        return self;
	    };
	    
	    self.buffer = function (name, size) {
	        if (typeof size === 'string') {
	            size = vars.get(size);
	        }
	        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
	        offset += size;
	        vars.set(name, buf);
	        
	        return self;
	    };
	    
	    self.skip = function (bytes) {
	        if (typeof bytes === 'string') {
	            bytes = vars.get(bytes);
	        }
	        offset += bytes;
	        
	        return self;
	    };
	    
	    self.scan = function (name, search) {
	        if (typeof search === 'string') {
	            search = new Buffer(search);
	        }
	        else if (!Buffer.isBuffer(search)) {
	            throw new Error('search must be a Buffer or a string');
	        }
	        vars.set(name, null);
	        
	        // simple but slow string search
	        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
	            for (
	                var j = 0;
	                j < search.length && buffer[offset+i+j] === search[j];
	                j++
	            );
	            if (j === search.length) break;
	        }
	        
	        vars.set(name, buffer.slice(offset, offset + i));
	        offset += i + search.length;
	        return self;
	    };
	    
	    self.peek = function (cb) {
	        var was = offset;
	        cb.call(self, vars.store);
	        offset = was;
	        return self;
	    };
	    
	    self.flush = function () {
	        vars.store = {};
	        return self;
	    };
	    
	    self.eof = function () {
	        return offset >= buffer.length;
	    };
	    
	    return self;
	};
	
	// convert byte strings to unsigned little endian numbers
	function decodeLEu (bytes) {
	    var acc = 0;
	    for (var i = 0; i < bytes.length; i++) {
	        acc += Math.pow(256,i) * bytes[i];
	    }
	    return acc;
	}
	
	// convert byte strings to unsigned big endian numbers
	function decodeBEu (bytes) {
	    var acc = 0;
	    for (var i = 0; i < bytes.length; i++) {
	        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
	    }
	    return acc;
	}
	
	// convert byte strings to signed big endian numbers
	function decodeBEs (bytes) {
	    var val = decodeBEu(bytes);
	    if ((bytes[0] & 0x80) == 0x80) {
	        val -= Math.pow(256, bytes.length);
	    }
	    return val;
	}
	
	// convert byte strings to signed little endian numbers
	function decodeLEs (bytes) {
	    var val = decodeLEu(bytes);
	    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {
	        val -= Math.pow(256, bytes.length);
	    }
	    return val;
	}
	
	function words (decode) {
	    var self = {};
	    
	    [ 1, 2, 4, 8 ].forEach(function (bytes) {
	        var bits = bytes * 8;
	        
	        self['word' + bits + 'le']
	        = self['word' + bits + 'lu']
	        = decode(bytes, decodeLEu);
	        
	        self['word' + bits + 'ls']
	        = decode(bytes, decodeLEs);
	        
	        self['word' + bits + 'be']
	        = self['word' + bits + 'bu']
	        = decode(bytes, decodeBEu);
	        
	        self['word' + bits + 'bs']
	        = decode(bytes, decodeBEs);
	    });
	    
	    // word8be(n) == word8le(n) for all n
	    self.word8 = self.word8u = self.word8be;
	    self.word8s = self.word8bs;
	    
	    return self;
	}


/***/ },
/* 797 */
/*!*****************************!*\
  !*** ./~/chainsaw/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var Traverse = __webpack_require__(/*! traverse */ 798);
	var EventEmitter = __webpack_require__(/*! events */ 614).EventEmitter;
	
	module.exports = Chainsaw;
	function Chainsaw (builder) {
	    var saw = Chainsaw.saw(builder, {});
	    var r = builder.call(saw.handlers, saw);
	    if (r !== undefined) saw.handlers = r;
	    saw.record();
	    return saw.chain();
	};
	
	Chainsaw.light = function ChainsawLight (builder) {
	    var saw = Chainsaw.saw(builder, {});
	    var r = builder.call(saw.handlers, saw);
	    if (r !== undefined) saw.handlers = r;
	    return saw.chain();
	};
	
	Chainsaw.saw = function (builder, handlers) {
	    var saw = new EventEmitter;
	    saw.handlers = handlers;
	    saw.actions = [];
	
	    saw.chain = function () {
	        var ch = Traverse(saw.handlers).map(function (node) {
	            if (this.isRoot) return node;
	            var ps = this.path;
	
	            if (typeof node === 'function') {
	                this.update(function () {
	                    saw.actions.push({
	                        path : ps,
	                        args : [].slice.call(arguments)
	                    });
	                    return ch;
	                });
	            }
	        });
	
	        process.nextTick(function () {
	            saw.emit('begin');
	            saw.next();
	        });
	
	        return ch;
	    };
	
	    saw.pop = function () {
	        return saw.actions.shift();
	    };
	
	    saw.next = function () {
	        var action = saw.pop();
	
	        if (!action) {
	            saw.emit('end');
	        }
	        else if (!action.trap) {
	            var node = saw.handlers;
	            action.path.forEach(function (key) { node = node[key] });
	            node.apply(saw.handlers, action.args);
	        }
	    };
	
	    saw.nest = function (cb) {
	        var args = [].slice.call(arguments, 1);
	        var autonext = true;
	
	        if (typeof cb === 'boolean') {
	            var autonext = cb;
	            cb = args.shift();
	        }
	
	        var s = Chainsaw.saw(builder, {});
	        var r = builder.call(s.handlers, s);
	
	        if (r !== undefined) s.handlers = r;
	
	        // If we are recording...
	        if ("undefined" !== typeof saw.step) {
	            // ... our children should, too
	            s.record();
	        }
	
	        cb.apply(s.chain(), args);
	        if (autonext !== false) s.on('end', saw.next);
	    };
	
	    saw.record = function () {
	        upgradeChainsaw(saw);
	    };
	
	    ['trap', 'down', 'jump'].forEach(function (method) {
	        saw[method] = function () {
	            throw new Error("To use the trap, down and jump features, please "+
	                            "call record() first to start recording actions.");
	        };
	    });
	
	    return saw;
	};
	
	function upgradeChainsaw(saw) {
	    saw.step = 0;
	
	    // override pop
	    saw.pop = function () {
	        return saw.actions[saw.step++];
	    };
	
	    saw.trap = function (name, cb) {
	        var ps = Array.isArray(name) ? name : [name];
	        saw.actions.push({
	            path : ps,
	            step : saw.step,
	            cb : cb,
	            trap : true
	        });
	    };
	
	    saw.down = function (name) {
	        var ps = (Array.isArray(name) ? name : [name]).join('/');
	        var i = saw.actions.slice(saw.step).map(function (x) {
	            if (x.trap && x.step <= saw.step) return false;
	            return x.path.join('/') == ps;
	        }).indexOf(true);
	
	        if (i >= 0) saw.step += i;
	        else saw.step = saw.actions.length;
	
	        var act = saw.actions[saw.step - 1];
	        if (act && act.trap) {
	            // It's a trap!
	            saw.step = act.step;
	            act.cb();
	        }
	        else saw.next();
	    };
	
	    saw.jump = function (step) {
	        saw.step = step;
	        saw.next();
	    };
	};


/***/ },
/* 798 */
/*!*****************************!*\
  !*** ./~/traverse/index.js ***!
  \*****************************/
/***/ function(module, exports) {

	module.exports = Traverse;
	function Traverse (obj) {
	    if (!(this instanceof Traverse)) return new Traverse(obj);
	    this.value = obj;
	}
	
	Traverse.prototype.get = function (ps) {
	    var node = this.value;
	    for (var i = 0; i < ps.length; i ++) {
	        var key = ps[i];
	        if (!Object.hasOwnProperty.call(node, key)) {
	            node = undefined;
	            break;
	        }
	        node = node[key];
	    }
	    return node;
	};
	
	Traverse.prototype.set = function (ps, value) {
	    var node = this.value;
	    for (var i = 0; i < ps.length - 1; i ++) {
	        var key = ps[i];
	        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
	        node = node[key];
	    }
	    node[ps[i]] = value;
	    return value;
	};
	
	Traverse.prototype.map = function (cb) {
	    return walk(this.value, cb, true);
	};
	
	Traverse.prototype.forEach = function (cb) {
	    this.value = walk(this.value, cb, false);
	    return this.value;
	};
	
	Traverse.prototype.reduce = function (cb, init) {
	    var skip = arguments.length === 1;
	    var acc = skip ? this.value : init;
	    this.forEach(function (x) {
	        if (!this.isRoot || !skip) {
	            acc = cb.call(this, acc, x);
	        }
	    });
	    return acc;
	};
	
	Traverse.prototype.deepEqual = function (obj) {
	    if (arguments.length !== 1) {
	        throw new Error(
	            'deepEqual requires exactly one object to compare against'
	        );
	    }
	    
	    var equal = true;
	    var node = obj;
	    
	    this.forEach(function (y) {
	        var notEqual = (function () {
	            equal = false;
	            //this.stop();
	            return undefined;
	        }).bind(this);
	        
	        //if (node === undefined || node === null) return notEqual();
	        
	        if (!this.isRoot) {
	        /*
	            if (!Object.hasOwnProperty.call(node, this.key)) {
	                return notEqual();
	            }
	        */
	            if (typeof node !== 'object') return notEqual();
	            node = node[this.key];
	        }
	        
	        var x = node;
	        
	        this.post(function () {
	            node = x;
	        });
	        
	        var toS = function (o) {
	            return Object.prototype.toString.call(o);
	        };
	        
	        if (this.circular) {
	            if (Traverse(obj).get(this.circular.path) !== x) notEqual();
	        }
	        else if (typeof x !== typeof y) {
	            notEqual();
	        }
	        else if (x === null || y === null || x === undefined || y === undefined) {
	            if (x !== y) notEqual();
	        }
	        else if (x.__proto__ !== y.__proto__) {
	            notEqual();
	        }
	        else if (x === y) {
	            // nop
	        }
	        else if (typeof x === 'function') {
	            if (x instanceof RegExp) {
	                // both regexps on account of the __proto__ check
	                if (x.toString() != y.toString()) notEqual();
	            }
	            else if (x !== y) notEqual();
	        }
	        else if (typeof x === 'object') {
	            if (toS(y) === '[object Arguments]'
	            || toS(x) === '[object Arguments]') {
	                if (toS(x) !== toS(y)) {
	                    notEqual();
	                }
	            }
	            else if (x instanceof Date || y instanceof Date) {
	                if (!(x instanceof Date) || !(y instanceof Date)
	                || x.getTime() !== y.getTime()) {
	                    notEqual();
	                }
	            }
	            else {
	                var kx = Object.keys(x);
	                var ky = Object.keys(y);
	                if (kx.length !== ky.length) return notEqual();
	                for (var i = 0; i < kx.length; i++) {
	                    var k = kx[i];
	                    if (!Object.hasOwnProperty.call(y, k)) {
	                        notEqual();
	                    }
	                }
	            }
	        }
	    });
	    
	    return equal;
	};
	
	Traverse.prototype.paths = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.path); 
	    });
	    return acc;
	};
	
	Traverse.prototype.nodes = function () {
	    var acc = [];
	    this.forEach(function (x) {
	        acc.push(this.node);
	    });
	    return acc;
	};
	
	Traverse.prototype.clone = function () {
	    var parents = [], nodes = [];
	    
	    return (function clone (src) {
	        for (var i = 0; i < parents.length; i++) {
	            if (parents[i] === src) {
	                return nodes[i];
	            }
	        }
	        
	        if (typeof src === 'object' && src !== null) {
	            var dst = copy(src);
	            
	            parents.push(src);
	            nodes.push(dst);
	            
	            Object.keys(src).forEach(function (key) {
	                dst[key] = clone(src[key]);
	            });
	            
	            parents.pop();
	            nodes.pop();
	            return dst;
	        }
	        else {
	            return src;
	        }
	    })(this.value);
	};
	
	function walk (root, cb, immutable) {
	    var path = [];
	    var parents = [];
	    var alive = true;
	    
	    return (function walker (node_) {
	        var node = immutable ? copy(node_) : node_;
	        var modifiers = {};
	        
	        var state = {
	            node : node,
	            node_ : node_,
	            path : [].concat(path),
	            parent : parents.slice(-1)[0],
	            key : path.slice(-1)[0],
	            isRoot : path.length === 0,
	            level : path.length,
	            circular : null,
	            update : function (x) {
	                if (!state.isRoot) {
	                    state.parent.node[state.key] = x;
	                }
	                state.node = x;
	            },
	            'delete' : function () {
	                delete state.parent.node[state.key];
	            },
	            remove : function () {
	                if (Array.isArray(state.parent.node)) {
	                    state.parent.node.splice(state.key, 1);
	                }
	                else {
	                    delete state.parent.node[state.key];
	                }
	            },
	            before : function (f) { modifiers.before = f },
	            after : function (f) { modifiers.after = f },
	            pre : function (f) { modifiers.pre = f },
	            post : function (f) { modifiers.post = f },
	            stop : function () { alive = false }
	        };
	        
	        if (!alive) return state;
	        
	        if (typeof node === 'object' && node !== null) {
	            state.isLeaf = Object.keys(node).length == 0;
	            
	            for (var i = 0; i < parents.length; i++) {
	                if (parents[i].node_ === node_) {
	                    state.circular = parents[i];
	                    break;
	                }
	            }
	        }
	        else {
	            state.isLeaf = true;
	        }
	        
	        state.notLeaf = !state.isLeaf;
	        state.notRoot = !state.isRoot;
	        
	        // use return values to update if defined
	        var ret = cb.call(state, state.node);
	        if (ret !== undefined && state.update) state.update(ret);
	        if (modifiers.before) modifiers.before.call(state, state.node);
	        
	        if (typeof state.node == 'object'
	        && state.node !== null && !state.circular) {
	            parents.push(state);
	            
	            var keys = Object.keys(state.node);
	            keys.forEach(function (key, i) {
	                path.push(key);
	                
	                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
	                
	                var child = walker(state.node[key]);
	                if (immutable && Object.hasOwnProperty.call(state.node, key)) {
	                    state.node[key] = child.node;
	                }
	                
	                child.isLast = i == keys.length - 1;
	                child.isFirst = i == 0;
	                
	                if (modifiers.post) modifiers.post.call(state, child);
	                
	                path.pop();
	            });
	            parents.pop();
	        }
	        
	        if (modifiers.after) modifiers.after.call(state, state.node);
	        
	        return state;
	    })(root).node;
	}
	
	Object.keys(Traverse.prototype).forEach(function (key) {
	    Traverse[key] = function (obj) {
	        var args = [].slice.call(arguments, 1);
	        var t = Traverse(obj);
	        return t[key].apply(t, args);
	    };
	});
	
	function copy (src) {
	    if (typeof src === 'object' && src !== null) {
	        var dst;
	        
	        if (Array.isArray(src)) {
	            dst = [];
	        }
	        else if (src instanceof Date) {
	            dst = new Date(src);
	        }
	        else if (src instanceof Boolean) {
	            dst = new Boolean(src);
	        }
	        else if (src instanceof Number) {
	            dst = new Number(src);
	        }
	        else if (src instanceof String) {
	            dst = new String(src);
	        }
	        else {
	            dst = Object.create(Object.getPrototypeOf(src));
	        }
	        
	        Object.keys(src).forEach(function (key) {
	            dst[key] = src[key];
	        });
	        return dst;
	    }
	    else return src;
	}


/***/ },
/* 799 */
/*!****************************!*\
  !*** ./~/buffers/index.js ***!
  \****************************/
/***/ function(module, exports) {

	module.exports = Buffers;
	
	function Buffers (bufs) {
	    if (!(this instanceof Buffers)) return new Buffers(bufs);
	    this.buffers = bufs || [];
	    this.length = this.buffers.reduce(function (size, buf) {
	        return size + buf.length
	    }, 0);
	}
	
	Buffers.prototype.push = function () {
	    for (var i = 0; i < arguments.length; i++) {
	        if (!Buffer.isBuffer(arguments[i])) {
	            throw new TypeError('Tried to push a non-buffer');
	        }
	    }
	    
	    for (var i = 0; i < arguments.length; i++) {
	        var buf = arguments[i];
	        this.buffers.push(buf);
	        this.length += buf.length;
	    }
	    return this.length;
	};
	
	Buffers.prototype.unshift = function () {
	    for (var i = 0; i < arguments.length; i++) {
	        if (!Buffer.isBuffer(arguments[i])) {
	            throw new TypeError('Tried to unshift a non-buffer');
	        }
	    }
	    
	    for (var i = 0; i < arguments.length; i++) {
	        var buf = arguments[i];
	        this.buffers.unshift(buf);
	        this.length += buf.length;
	    }
	    return this.length;
	};
	
	Buffers.prototype.copy = function (dst, dStart, start, end) {
	    return this.slice(start, end).copy(dst, dStart, 0, end - start);
	};
	
	Buffers.prototype.splice = function (i, howMany) {
	    var buffers = this.buffers;
	    var index = i >= 0 ? i : this.length - i;
	    var reps = [].slice.call(arguments, 2);
	    
	    if (howMany === undefined) {
	        howMany = this.length - index;
	    }
	    else if (howMany > this.length - index) {
	        howMany = this.length - index;
	    }
	    
	    for (var i = 0; i < reps.length; i++) {
	        this.length += reps[i].length;
	    }
	    
	    var removed = new Buffers();
	    var bytes = 0;
	    
	    var startBytes = 0;
	    for (
	        var ii = 0;
	        ii < buffers.length && startBytes + buffers[ii].length < index;
	        ii ++
	    ) { startBytes += buffers[ii].length }
	    
	    if (index - startBytes > 0) {
	        var start = index - startBytes;
	        
	        if (start + howMany < buffers[ii].length) {
	            removed.push(buffers[ii].slice(start, start + howMany));
	            
	            var orig = buffers[ii];
	            //var buf = new Buffer(orig.length - howMany);
	            var buf0 = new Buffer(start);
	            for (var i = 0; i < start; i++) {
	                buf0[i] = orig[i];
	            }
	            
	            var buf1 = new Buffer(orig.length - start - howMany);
	            for (var i = start + howMany; i < orig.length; i++) {
	                buf1[ i - howMany - start ] = orig[i]
	            }
	            
	            if (reps.length > 0) {
	                var reps_ = reps.slice();
	                reps_.unshift(buf0);
	                reps_.push(buf1);
	                buffers.splice.apply(buffers, [ ii, 1 ].concat(reps_));
	                ii += reps_.length;
	                reps = [];
	            }
	            else {
	                buffers.splice(ii, 1, buf0, buf1);
	                //buffers[ii] = buf;
	                ii += 2;
	            }
	        }
	        else {
	            removed.push(buffers[ii].slice(start));
	            buffers[ii] = buffers[ii].slice(0, start);
	            ii ++;
	        }
	    }
	    
	    if (reps.length > 0) {
	        buffers.splice.apply(buffers, [ ii, 0 ].concat(reps));
	        ii += reps.length;
	    }
	    
	    while (removed.length < howMany) {
	        var buf = buffers[ii];
	        var len = buf.length;
	        var take = Math.min(len, howMany - removed.length);
	        
	        if (take === len) {
	            removed.push(buf);
	            buffers.splice(ii, 1);
	        }
	        else {
	            removed.push(buf.slice(0, take));
	            buffers[ii] = buffers[ii].slice(take);
	        }
	    }
	    
	    this.length -= removed.length;
	    
	    return removed;
	};
	 
	Buffers.prototype.slice = function (i, j) {
	    var buffers = this.buffers;
	    if (j === undefined) j = this.length;
	    if (i === undefined) i = 0;
	    
	    if (j > this.length) j = this.length;
	    
	    var startBytes = 0;
	    for (
	        var si = 0;
	        si < buffers.length && startBytes + buffers[si].length <= i;
	        si ++
	    ) { startBytes += buffers[si].length }
	    
	    var target = new Buffer(j - i);
	    
	    var ti = 0;
	    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
	        var len = buffers[ii].length;
	        
	        var start = ti === 0 ? i - startBytes : 0;
	        var end = ti + len >= j - i
	            ? Math.min(start + (j - i) - ti, len)
	            : len
	        ;
	        
	        buffers[ii].copy(target, ti, start, end);
	        ti += end - start;
	    }
	    
	    return target;
	};
	
	Buffers.prototype.pos = function (i) {
	    if (i < 0 || i >= this.length) throw new Error('oob');
	    var l = i, bi = 0, bu = null;
	    for (;;) {
	        bu = this.buffers[bi];
	        if (l < bu.length) {
	            return {buf: bi, offset: l};
	        } else {
	            l -= bu.length;
	        }
	        bi++;
	    }
	};
	
	Buffers.prototype.get = function get (i) {
	    var pos = this.pos(i);
	
	    return this.buffers[pos.buf].get(pos.offset);
	};
	
	Buffers.prototype.set = function set (i, b) {
	    var pos = this.pos(i);
	
	    return this.buffers[pos.buf].set(pos.offset, b);
	};
	
	Buffers.prototype.indexOf = function (needle, offset) {
	    if ("string" === typeof needle) {
	        needle = new Buffer(needle);
	    } else if (needle instanceof Buffer) {
	        // already a buffer
	    } else {
	        throw new Error('Invalid type for a search string');
	    }
	
	    if (!needle.length) {
	        return 0;
	    }
	
	    if (!this.length) {
	        return -1;
	    }
	
	    var i = 0, j = 0, match = 0, mstart, pos = 0;
	
	    // start search from a particular point in the virtual buffer
	    if (offset) {
	        var p = this.pos(offset);
	        i = p.buf;
	        j = p.offset;
	        pos = offset;
	    }
	
	    // for each character in virtual buffer
	    for (;;) {
	        while (j >= this.buffers[i].length) {
	            j = 0;
	            i++;
	
	            if (i >= this.buffers.length) {
	                // search string not found
	                return -1;
	            }
	        }
	
	        var char = this.buffers[i][j];
	
	        if (char == needle[match]) {
	            // keep track where match started
	            if (match == 0) {
	                mstart = {
	                    i: i,
	                    j: j,
	                    pos: pos
	                };
	            }
	            match++;
	            if (match == needle.length) {
	                // full match
	                return mstart.pos;
	            }
	        } else if (match != 0) {
	            // a partial match ended, go back to match starting position
	            // this will continue the search at the next character
	            i = mstart.i;
	            j = mstart.j;
	            pos = mstart.pos;
	            match = 0;
	        }
	
	        j++;
	        pos++;
	    }
	};
	
	Buffers.prototype.toBuffer = function() {
	    return this.slice();
	}
	
	Buffers.prototype.toString = function(encoding, start, end) {
	    return this.slice(start, end).toString(encoding);
	}


/***/ },
/* 800 */
/*!******************************!*\
  !*** ./~/binary/lib/vars.js ***!
  \******************************/
/***/ function(module, exports) {

	module.exports = function (store) {
	    function getset (name, value) {
	        var node = vars.store;
	        var keys = name.split('.');
	        keys.slice(0,-1).forEach(function (k) {
	            if (node[k] === undefined) node[k] = {};
	            node = node[k]
	        });
	        var key = keys[keys.length - 1];
	        if (arguments.length == 1) {
	            return node[key];
	        }
	        else {
	            return node[key] = value;
	        }
	    }
	    
	    var vars = {
	        get : function (name) {
	            return getset(name);
	        },
	        set : function (name, value) {
	            return getset(name, value);
	        },
	        store : store || {},
	    };
	    return vars;
	};


/***/ },
/* 801 */
/*!************************************!*\
  !*** ./~/pullstream/pullstream.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = PullStream;
	
	__webpack_require__(/*! setimmediate */ 793);
	var inherits = __webpack_require__(/*! util */ 597).inherits;
	var PassThrough = __webpack_require__(/*! readable-stream/passthrough */ 802);
	var over = __webpack_require__(/*! over */ 804);
	var SliceStream = __webpack_require__(/*! slice-stream */ 805);
	
	function PullStream(opts) {
	  var self = this;
	  this.opts = opts || {};
	  PassThrough.call(this, opts);
	  this.once('finish', function() {
	    self._writesFinished = true;
	    if (self._flushed) {
	      self._finish();
	    }
	  });
	  this.on('readable', function() {
	    self._process();
	  });
	}
	inherits(PullStream, PassThrough);
	
	PullStream.prototype.pull = over([
	  [over.numberOptionalWithDefault(null), over.func, function (len, callback) {
	    if (len === 0) {
	      return callback(null, new Buffer(0));
	    }
	
	    var self = this;
	    pullServiceRequest();
	
	    function pullServiceRequest() {
	      self._serviceRequests = null;
	      if (self._flushed) {
	        return callback(new Error('End of Stream'));
	      }
	
	      var data = self.read(len || undefined);
	      if (data) {
	        setImmediate(callback.bind(null, null, data));
	      } else {
	        self._serviceRequests = pullServiceRequest;
	      }
	    }
	  }]
	]);
	
	PullStream.prototype.pullUpTo = over([
	  [over.numberOptionalWithDefault(null), function (len) {
	    var data = this.read(len);
	    if (len && !data) {
	      data = this.read();
	    }
	    return data;
	  }]
	]);
	
	PullStream.prototype.pipe = over([
	  [over.numberOptionalWithDefault(null), over.object, function (len, destStream) {
	    if (!len) {
	      return PassThrough.prototype.pipe.call(this, destStream);
	    }
	
	    if (len === 0) {
	      return destStream.end();
	    }
	
	
	    var pullstream = this;
	    pullstream
	      .pipe(new SliceStream({ length: len }, function (buf, sliceEnd, extra) {
	        if (!sliceEnd) {
	          return this.push(buf);
	        }
	        pullstream.unpipe();
	        pullstream.unshift(extra);
	        this.push(buf);
	        return this.push(null);
	      }))
	      .pipe(destStream);
	
	    return destStream;
	  }]
	]);
	
	PullStream.prototype._process = function () {
	  if (this._serviceRequests) {
	    this._serviceRequests();
	  }
	};
	
	PullStream.prototype.prepend = function (chunk) {
	  this.unshift(chunk);
	};
	
	PullStream.prototype.drain = function (len, callback) {
	  if (this._flushed) {
	    return callback(new Error('End of Stream'));
	  }
	
	  var data = this.pullUpTo(len);
	  var bytesDrained = data && data.length || 0;
	  if (bytesDrained === len) {
	     setImmediate(callback);
	  } else if (bytesDrained > 0) {
	    this.drain(len - bytesDrained, callback);
	  } else {
	    //internal buffer is empty, wait until data can be consumed
	    this.once('readable', this.drain.bind(this, len - bytesDrained, callback));
	  }
	};
	
	PullStream.prototype._flush = function (callback) {
	  var self = this;
	  if (this._readableState.length > 0) {
	    return setImmediate(self._flush.bind(self, callback));
	  }
	
	  this._flushed = true;
	  if (self._writesFinished) {
	    self._finish(callback);
	  } else {
	    callback();
	  }
	};
	
	PullStream.prototype._finish = function (callback) {
	  callback = callback || function () {};
	  if (this._serviceRequests) {
	    this._serviceRequests();
	  }
	  setImmediate(callback);
	};


/***/ },
/* 802 */
/*!******************************************!*\
  !*** ./~/readable-stream/passthrough.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_passthrough.js */ 803)


/***/ },
/* 803 */
/*!******************************************************!*\
  !*** ./~/readable-stream/lib/_stream_passthrough.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(/*! ./_stream_transform */ 795);
	
	/*<replacement>*/
	var util = __webpack_require__(/*! core-util-is */ 609);
	util.inherits = __webpack_require__(/*! inherits */ 610);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 804 */
/*!****************************!*\
  !*** ./~/over/overload.js ***!
  \****************************/
/***/ function(module, exports) {

	'use strict';
	
	// overloadDefs
	// self, overloadDefs
	var overload = module.exports = function () {
	  var self, selfSet = false, overloadDefs;
	  if (arguments.length === 1) {
	    overloadDefs = arguments[0];
	  } else {
	    selfSet = true;
	    self = arguments[0];
	    overloadDefs = arguments[1];
	  }
	  return function () {
	    if (!selfSet) {
	      self = this;
	    }
	    var args = Array.prototype.slice.call(arguments);
	    var overloadMatchData = findOverload(overloadDefs, args);
	    if (!overloadMatchData) {
	      throw new Error(createErrorMessage('No match found.', overloadDefs));
	    }
	    var overloadFn = overloadMatchData.def[overloadMatchData.def.length - 1];
	    return overloadFn.apply(self, overloadMatchData.args);
	  };
	};
	
	var findOverload = overload.findOverload = function (overloadDefs, args) {
	  for (var i = 0; i < overloadDefs.length; i++) {
	    if (i === overloadDefs.length - 1 && typeof(overloadDefs[i]) === 'function') {
	      return { args: args, def: [overloadDefs[i]] };
	    }
	    var newArgs;
	    if (newArgs = isMatch(overloadDefs[i], args)) {
	      return { args: newArgs, def: overloadDefs[i] };
	    }
	  }
	  return null;
	};
	
	function isMatch(overloadDef, args) {
	  var overloadDefIdx;
	  var argIdx;
	  var newArgs = [];
	  for (overloadDefIdx = 0, argIdx = 0; overloadDefIdx < overloadDef.length - 1; overloadDefIdx++) {
	    if (typeof(overloadDef[overloadDefIdx]) !== 'function') {
	      throw new Error("Invalid overload definition. Array should only contain functions.");
	    }
	    //console.log('overloadDef/arg:', overloadDef[overloadDefIdx], args[argIdx]);
	    var result = overloadDef[overloadDefIdx](args[argIdx]);
	    //console.log('result:', result);
	    if (result) {
	      if (result.hasOwnProperty('defaultValue')) {
	        newArgs.push(result.defaultValue);
	      } else {
	        if (overloadDef[overloadDefIdx].optional && args[argIdx] === null) {
	          argIdx++;
	          newArgs.push(overloadDef[overloadDefIdx].defaultValue);
	          continue;
	        }
	        newArgs.push(args[argIdx]);
	        argIdx++;
	      }
	    } else {
	      if (overloadDef[overloadDefIdx].optional) {
	        newArgs.push(overloadDef[overloadDefIdx].defaultValue);
	        continue;
	      }
	      return false;
	    }
	  }
	  //console.log('compares', overloadDefIdx, overloadDef.length - 1, argIdx, args.length, newArgs.length);
	  if (overloadDefIdx === overloadDef.length - 1 && argIdx >= args.length) {
	    return newArgs;
	  }
	  return false;
	}
	
	function createErrorMessage(message, overloadDefs) {
	  message += '\n';
	  message += '  Possible matches:\n';
	  for (var i = 0; i < overloadDefs.length; i++) {
	    var overloadDef = overloadDefs[i];
	    if (typeof(overloadDef) === 'function') {
	      message += '   [default]\n';
	    } else {
	      var matchers = overloadDef.slice(0, overloadDef.length - 1);
	      matchers = matchers.map(function (m) {
	        if (!m) {
	          return '[invalid argument definition]';
	        }
	        return m.name || m;
	      });
	      if (matchers.length === 0) {
	        message += '   ()\n';
	      } else {
	        message += '   (' + matchers.join(', ') + ')\n';
	      }
	    }
	  }
	  return message;
	}
	
	// --- func
	overload.func = function func(arg) {
	  return typeof(arg) === 'function';
	};
	
	overload.funcOptional = function funcOptional(arg) {
	  if (!arg) {
	    return true;
	  }
	  return overload.func(arg);
	};
	overload.funcOptional.optional = true;
	
	overload.funcOptionalWithDefault = function (def) {
	  var fn = function funcOptionalWithDefault(arg) {
	    if (arg === undefined) {
	      return false;
	    }
	    return overload.func(arg);
	  };
	  fn.optional = true;
	  fn.defaultValue = def;
	  return fn;
	};
	
	// --- callback
	overload.callbackOptional = function callbackOptional(arg) {
	  if (!arg) {
	    return { defaultValue: function defaultCallback() {} };
	  }
	  return overload.func(arg);
	};
	overload.callbackOptional.optional = true;
	
	// --- string
	overload.string = function string(arg) {
	  return typeof(arg) === 'string';
	};
	
	overload.stringOptional = function stringOptional(arg) {
	  if (!arg) {
	    return true;
	  }
	  return overload.string(arg);
	};
	overload.stringOptional.optional = true;
	
	overload.stringOptionalWithDefault = function (def) {
	  var fn = function stringOptionalWithDefault(arg) {
	    if (arg === undefined) {
	      return false;
	    }
	    return overload.string(arg);
	  };
	  fn.optional = true;
	  fn.defaultValue = def;
	  return fn;
	};
	
	// --- number
	overload.number = function number(arg) {
	  return typeof(arg) === 'number';
	};
	
	overload.numberOptional = function numberOptional(arg) {
	  if (!arg) {
	    return true;
	  }
	  return overload.number(arg);
	};
	overload.numberOptional.optional = true;
	
	overload.numberOptionalWithDefault = function (def) {
	  var fn = function numberOptionalWithDefault(arg) {
	    if (arg === undefined) {
	      return false;
	    }
	    return overload.number(arg);
	  };
	  fn.optional = true;
	  fn.defaultValue = def;
	  return fn;
	};
	
	// --- array
	overload.array = function array(arg) {
	  return arg instanceof Array;
	};
	
	overload.arrayOptional = function arrayOptional(arg) {
	  if (!arg) {
	    return true;
	  }
	  return overload.array(arg);
	};
	overload.arrayOptional.optional = true;
	
	overload.arrayOptionalWithDefault = function (def) {
	  var fn = function arrayOptionalWithDefault(arg) {
	    if (arg === undefined) {
	      return false;
	    }
	    return overload.array(arg);
	  };
	  fn.optional = true;
	  fn.defaultValue = def;
	  return fn;
	};
	
	// --- object
	overload.object = function object(arg) {
	  return typeof(arg) === 'object';
	};
	
	overload.objectOptional = function objectOptional(arg) {
	  if (!arg) {
	    return true;
	  }
	  return overload.object(arg);
	};
	overload.objectOptional.optional = true;
	
	overload.objectOptionalWithDefault = function (def) {
	  var fn = function objectOptionalWithDefault(arg) {
	    if (arg === undefined) {
	      return false;
	    }
	    return overload.object(arg);
	  };
	  fn.optional = true;
	  fn.defaultValue = def;
	  return fn;
	};


/***/ },
/* 805 */
/*!***************************************!*\
  !*** ./~/slice-stream/slicestream.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = SliceStream;
	
	var Transform = __webpack_require__(/*! readable-stream/transform */ 794);
	var inherits = __webpack_require__(/*! util */ 597).inherits;
	
	inherits(SliceStream, Transform);
	
	function SliceStream(opts, sliceFn) {
	  if (!(this instanceof SliceStream)) {
	    return new SliceStream(opts, sliceFn);
	  }
	
	  this._opts = opts;
	  this._accumulatedLength = 0;
	  this.sliceFn = sliceFn;
	
	  Transform.call(this);
	}
	
	SliceStream.prototype._transform = function (chunk, encoding, callback) {
	  this._accumulatedLength += chunk.length;
	
	  if (this._accumulatedLength >= this._opts.length) {
	    //todo handle more than one slice in a stream
	    var offset = chunk.length - (this._accumulatedLength - this._opts.length);
	    this.sliceFn(chunk.slice(0, offset), true, chunk.slice(offset));
	    callback();
	  } else {
	    this.sliceFn(chunk);
	    callback();
	  }
	};


/***/ },
/* 806 */
/*!*********************************!*\
  !*** ./~/match-stream/match.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = Match;
	
	var Transform = __webpack_require__(/*! stream */ 604).Transform;
	var inherits = __webpack_require__(/*! util */ 597).inherits;
	var Buffers = __webpack_require__(/*! buffers */ 799);
	
	if (!Transform) {
	  Transform = __webpack_require__(/*! readable-stream/transform */ 794);
	}
	
	inherits(Match, Transform);
	
	function Match(opts, matchFn) {
	  if (!(this instanceof Match)) {
	    return new Match(opts, matchFn);
	  }
	
	  //todo - better handle opts e.g. pattern.length can't be > highWaterMark
	  this._opts = opts;
	  if (typeof this._opts.pattern === "string") {
	    this._opts.pattern = new Buffer(this._opts.pattern);
	  }
	  this._matchFn = matchFn;
	  this._bufs = Buffers();
	
	  Transform.call(this);
	}
	
	Match.prototype._transform = function (chunk, encoding, callback) {
	  var pattern = this._opts.pattern;
	  this._bufs.push(chunk);
	
	  var index = this._bufs.indexOf(pattern);
	  if (index >= 0) {
	    processMatches.call(this, index, pattern, callback);
	  } else {
	    var buf = this._bufs.splice(0, this._bufs.length - chunk.length);
	    if (buf && buf.length > 0) {
	      this._matchFn(buf.toBuffer());
	    }
	    callback();
	  }
	};
	
	function processMatches(index, pattern, callback) {
	  var buf = this._bufs.splice(0, index).toBuffer();
	  if (this._opts.consume) {
	    this._bufs.splice(0, pattern.length);
	  }
	  this._matchFn(buf, pattern, this._bufs.toBuffer());
	
	  index = this._bufs.indexOf(pattern);
	  if (index > 0 || this._opts.consume && index === 0) {
	    process.nextTick(processMatches.bind(this, index, pattern, callback));
	  } else {
	    callback();
	  }
	}


/***/ },
/* 807 */
/*!******************************!*\
  !*** ./~/unzip/lib/entry.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = Entry;
	
	var PassThrough = __webpack_require__(/*! readable-stream/passthrough */ 802);
	var inherits = __webpack_require__(/*! util */ 597).inherits;
	
	inherits(Entry, PassThrough);
	
	function Entry () {
	  PassThrough.call(this);
	  this.props = {};
	}
	
	Entry.prototype.autodrain = function () {
	  this.on('readable', this.read.bind(this));
	};


/***/ },
/* 808 */
/*!********************************!*\
  !*** ./~/unzip/lib/extract.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = Extract;
	
	var Parse = __webpack_require__(/*! ../unzip */ 791).Parse;
	var Writer = __webpack_require__(/*! fstream */ 749).Writer;
	var Writable = __webpack_require__(/*! readable-stream/writable */ 809);
	var path = __webpack_require__(/*! path */ 521);
	var inherits = __webpack_require__(/*! util */ 597).inherits;
	
	inherits(Extract, Writable);
	
	function Extract (opts) {
	  var self = this;
	  if (!(this instanceof Extract)) {
	    return new Extract(opts);
	  }
	
	  Writable.apply(this);
	  this._opts = opts || { verbose: false };
	
	  this._parser = Parse(this._opts);
	  this._parser.on('error', function(err) {
	    self.emit('error', err);
	  });
	  this.on('finish', function() {
	    self._parser.end();
	  });
	
	  var writer = Writer({
	    type: 'Directory',
	    path: opts.path
	  });
	  writer.on('error', function(err) {
	    self.emit('error', err);
	  });
	  writer.on('close', function() {
	    self.emit('close')
	  });
	
	  this.on('pipe', function(source) {
	    if (opts.verbose && source.path) {
	      console.log('Archive: ', source.path);
	    }
	  });
	
	  this._parser.pipe(writer);
	}
	
	Extract.prototype._write = function (chunk, encoding, callback) {
	  if (this._parser.write(chunk)) {
	    return callback();
	  }
	
	  return this._parser.once('drain', callback);
	};


/***/ },
/* 809 */
/*!***************************************!*\
  !*** ./~/readable-stream/writable.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ 616)


/***/ }
/******/ ]);
//# sourceMappingURL=pluginapi.js.map